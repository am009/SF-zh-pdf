\documentclass[12pt]{report}
\usepackage[utf8x]{inputenc}

%Warning: tipa declares many non-standard macros used by utf8x to
%interpret utf8 characters but extra packages might have to be added
%such as "textgreek" for Greek letters not already in tipa
%or "stmaryrd" for mathematical symbols.
%Utf8 codes missing a LaTeX interpretation can be defined by using
%\DeclareUnicodeCharacter{code}{interpretation}.
%Use coqdoc's option -p to add new packages or declarations.
\usepackage{tipa}

\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage{coqdoc}
\usepackage{amsmath,amssymb}
\usepackage{url}
\usepackage{ctex}
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% This file has been automatically generated with the command
%% coqdoc -toc -interpolate -utf8 --latex -p \usepackage{ctex} -Q . LF -o all.tex BibTest.v PostscriptTest.v AltAutoTest.v AutoTest.v ExtractionTest.v ImpCEvalFunTest.v ImpParserTest.v ImpTest.v RelTest.v IndPrinciplesTest.v ProofObjectsTest.v MapsTest.v IndPropTest.v LogicTest.v TacticsTest.v PolyTest.v ListsTest.v InductionTest.v BasicsTest.v PrefaceTest.v Bib.v Postscript.v AltAuto.v Auto.v Extraction.v ImpCEvalFun.v ImpParser.v Imp.v Rel.v IndPrinciples.v ProofObjects.v Maps.v IndProp.v Logic.v Tactics.v Poly.v Lists.v Induction.v Basics.v Preface.v 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\coqlibrary{LF.BibTest}{Library }{LF.BibTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Bib}{\coqdoclibrary{Bib}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.BibTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.BibTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.BibTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.BibTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Bib}{\coqdoclibrary{Bib}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BibTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.PostscriptTest}{Library }{LF.PostscriptTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Postscript}{\coqdoclibrary{Postscript}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.PostscriptTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.PostscriptTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.PostscriptTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.PostscriptTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Postscript}{\coqdoclibrary{Postscript}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PostscriptTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.AltAutoTest}{Library }{LF.AltAutoTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.AltAuto}{\coqdoclibrary{AltAuto}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.AltAutoTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.AltAutoTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.AltAutoTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.AltAutoTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.AltAuto}{\coqdoclibrary{AltAuto}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.AltAutoTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  re\_opt  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: re\_opt".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.AltAuto.manual grade for re opt}{\coqdocdefinition{manual\_grade\_for\_re\_opt}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  pumping\_redux  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: pumping\_redux".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.AltAuto.manual grade for pumping redux}{\coqdocdefinition{manual\_grade\_for\_pumping\_redux}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 3".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 6".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- re\_opt ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- pumping\_redux ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.AutoTest}{Library }{LF.AutoTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Auto}{\coqdoclibrary{Auto}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.AutoTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.AutoTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.AutoTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.AutoTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Auto}{\coqdoclibrary{Auto}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.AutoTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.ExtractionTest}{Library }{LF.ExtractionTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Extraction}{\coqdoclibrary{Extraction}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.ExtractionTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.ExtractionTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.ExtractionTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.ExtractionTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Extraction}{\coqdoclibrary{Extraction}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ExtractionTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.ImpCEvalFunTest}{Library }{LF.ImpCEvalFunTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.ImpCEvalFun}{\coqdoclibrary{ImpCEvalFun}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.ImpCEvalFunTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.ImpCEvalFunTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.ImpCEvalFunTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.ImpCEvalFunTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.ImpCEvalFun}{\coqdoclibrary{ImpCEvalFun}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpCEvalFunTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  pup\_to\_n  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> pup\_to\_n".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.ImpCEvalFun.pup to n}{\coqdocaxiom{pup\_to\_n}} (\coqref{LF.Imp.com}{\coqdocinductive{Imp.com}}).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.ImpCEvalFun.pup to n}{\coqdocaxiom{pup\_to\_n}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpCEvalFunTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  ceval\_step\_\_ceval\_inf  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: ceval\_step\_\_ceval\_inf".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 6".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.ImpCEvalFun.manual grade for ceval step  ceval inf}{\coqdocdefinition{manual\_grade\_for\_ceval\_step\_\_ceval\_inf}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  ceval\_\_ceval\_step  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> ceval\_\_ceval\_step".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.ImpCEvalFun.ceval  ceval step}{\coqdocaxiom{ceval\_\_ceval\_step}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{c} : \coqref{LF.Imp.com}{\coqdocinductive{Imp.com}}) (\coqdocvar{st} \coqdocvar{st'} : \coqref{LF.Imp.state}{\coqdocdefinition{Imp.state}}),\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Imp.ceval}{\coqdocinductive{Imp.ceval}} \coqdocvariable{c} \coqdocvariable{st} \coqdocvariable{st'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{0.50em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{i} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvariable{st} \coqdocvariable{c} \coqdocvariable{i} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} @\coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqref{LF.Imp.state}{\coqdocdefinition{Imp.state}} \coqdocvariable{st'})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.ImpCEvalFun.ceval  ceval step}{\coqdocaxiom{ceval\_\_ceval\_step}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpCEvalFunTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 11".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 11".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- pup\_to\_n ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.ImpCEvalFun.pup to n}{\coqdocaxiom{pup\_to\_n}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- ceval\_step\_\_ceval\_inf ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- ceval\_\_ceval\_step ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.ImpCEvalFun.ceval  ceval step}{\coqdocaxiom{ceval\_\_ceval\_step}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.ImpParserTest}{Library }{LF.ImpParserTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.ImpParser}{\coqdoclibrary{ImpParser}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.ImpParserTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.ImpParserTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.ImpParserTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.ImpParserTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.ImpParser}{\coqdoclibrary{ImpParser}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpParserTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.ImpTest}{Library }{LF.ImpTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Imp}{\coqdoclibrary{Imp}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.ImpTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.ImpTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.ImpTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.ImpTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Imp}{\coqdoclibrary{Imp}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  optimize\_0plus\_b\_sound  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> AExp.optimize\_0plus\_b\_sound".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Imp.AExp.optimize 0plus b sound}{\coqdocaxiom{AExp.optimize\_0plus\_b\_sound}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} \coqdocvar{b} : \coqref{LF.Imp.AExp.bexp}{\coqdocinductive{AExp.bexp}}, \coqref{LF.Imp.AExp.beval}{\coqdocdefinition{AExp.beval}} (\coqref{LF.Imp.AExp.optimize 0plus b}{\coqdocaxiom{AExp.optimize\_0plus\_b}} \coqdocvariable{b}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Imp.AExp.beval}{\coqdocdefinition{AExp.beval}} \coqdocvariable{b})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.AExp.optimize 0plus b sound}{\coqdocaxiom{AExp.optimize\_0plus\_b\_sound}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  bevalR  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> AExp.beval\_iff\_bevalR".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Imp.AExp.beval iff bevalR}{\coqdocaxiom{AExp.beval\_iff\_bevalR}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{b} : \coqref{LF.Imp.AExp.bexp}{\coqdocinductive{AExp.bexp}}) (\coqdocvar{bv} : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}}), \coqref{LF.Imp.AExp.bevalR}{\coqdocinductive{AExp.bevalR}} \coqdocvariable{b} \coqdocvariable{bv} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{LF.Imp.AExp.beval}{\coqdocdefinition{AExp.beval}} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{bv})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.AExp.beval iff bevalR}{\coqdocaxiom{AExp.beval\_iff\_bevalR}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  ceval\_example2  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> ceval\_example2".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Imp.ceval example2}{\coqdocaxiom{ceval\_example2}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Imp.empty st}{\coqdocdefinition{empty\_st}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqref{LF.Imp.ANum}{\coqdocconstructor{ANum}} 0\coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqref{LF.Imp.ANum}{\coqdocconstructor{ANum}} 1\coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}} \coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqref{LF.Imp.ANum}{\coqdocconstructor{ANum}} 2\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} @\coqref{LF.Maps.t update}{\coqdocdefinition{Maps.t\_update}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} (@\coqref{LF.Maps.t update}{\coqdocdefinition{Maps.t\_update}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} (\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.:::x '!->' x}{\coqdocnotation{!->}} 0) \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} 1) \coqref{LF.Imp.Z}{\coqdocdefinition{Z}} 2)).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.ceval example2}{\coqdocaxiom{ceval\_example2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  loop\_never\_stops  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> loop\_never\_stops".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Imp.loop never stops}{\coqdocaxiom{loop\_never\_stops}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{st} \coqdocvar{st'} : \coqref{LF.Imp.state}{\coqdocdefinition{state}}, \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Imp.loop}{\coqdocdefinition{loop}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.loop never stops}{\coqdocaxiom{loop\_never\_stops}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  no\_whiles\_eqv  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> no\_whiles\_eqv".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Imp.no whiles eqv}{\coqdocaxiom{no\_whiles\_eqv}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{c} : \coqref{LF.Imp.com}{\coqdocinductive{com}}, \coqref{LF.Imp.no whiles}{\coqdocdefinition{no\_whiles}} \coqdocvariable{c} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{LF.Imp.no whilesR}{\coqdocinductive{no\_whilesR}} \coqdocvariable{c})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.no whiles eqv}{\coqdocaxiom{no\_whiles\_eqv}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  no\_whiles\_terminating  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: no\_whiles\_terminating".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 6".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Imp.manual grade for no whiles terminating}{\coqdocdefinition{manual\_grade\_for\_no\_whiles\_terminating}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  stack\_compiler  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> s\_execute1".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Imp.s execute1}{\coqdocaxiom{s\_execute1}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Imp.s execute}{\coqdocaxiom{s\_execute}} \coqref{LF.Imp.empty st}{\coqdocdefinition{empty\_st}} (@\coqexternalref{nil}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Imp.SPush}{\coqdocconstructor{SPush}} 5 \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} (\coqref{LF.Imp.SPush}{\coqdocconstructor{SPush}} 3 \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqref{LF.Imp.SPush}{\coqdocconstructor{SPush}} 1 \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqref{LF.Imp.SMinus}{\coqdocconstructor{SMinus}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} @\coqexternalref{nil}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} \coqref{LF.Imp.sinstr}{\coqdocinductive{sinstr}})\%\coqdocvar{list}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
(2 \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} 5 \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} @\coqexternalref{nil}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\%\coqdocvar{list})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.s execute1}{\coqdocaxiom{s\_execute1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> s\_execute2".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Imp.s execute2}{\coqdocaxiom{s\_execute2}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Imp.s execute}{\coqdocaxiom{s\_execute}} (\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.:::x '!->' x}{\coqdocnotation{!->}} 3) (3 \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} (4 \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} @\coqexternalref{nil}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\%\coqdocvar{list})\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Imp.SPush}{\coqdocconstructor{SPush}} 4 \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} (\coqref{LF.Imp.SLoad}{\coqdocconstructor{SLoad}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqref{LF.Imp.SMult}{\coqdocconstructor{SMult}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqref{LF.Imp.SPlus}{\coqdocconstructor{SPlus}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} @\coqexternalref{nil}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} \coqref{LF.Imp.sinstr}{\coqdocinductive{sinstr}})\%\coqdocvar{list}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
(15 \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} 4 \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} @\coqexternalref{nil}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\%\coqdocvar{list})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.s execute2}{\coqdocaxiom{s\_execute2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> s\_compile1".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Imp.s compile1}{\coqdocaxiom{s\_compile1}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Imp.s compile}{\coqdocaxiom{s\_compile}} (\coqref{LF.Imp.AId}{\coqdocconstructor{AId}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '-' x}{\coqdocnotation{-}} \coqref{LF.Imp.ANum}{\coqdocconstructor{ANum}} 2 \coqref{LF.Imp.::imp scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{LF.Imp.AId}{\coqdocconstructor{AId}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
(\coqref{LF.Imp.SLoad}{\coqdocconstructor{SLoad}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqref{LF.Imp.SPush}{\coqdocconstructor{SPush}} 2 \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqref{LF.Imp.SLoad}{\coqdocconstructor{SLoad}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqref{LF.Imp.SMult}{\coqdocconstructor{SMult}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqref{LF.Imp.SMinus}{\coqdocconstructor{SMinus}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} @\coqexternalref{nil}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} \coqref{LF.Imp.sinstr}{\coqdocinductive{sinstr}})\%\coqdocvar{list})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.s compile1}{\coqdocaxiom{s\_compile1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  stack\_compiler\_correct  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> s\_compile\_correct".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 6".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Imp.s compile correct}{\coqdocaxiom{s\_compile\_correct}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{st} : \coqref{LF.Imp.state}{\coqdocdefinition{state}}) (\coqdocvar{e} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}}),\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Imp.s execute}{\coqdocaxiom{s\_execute}} \coqdocvariable{st} (@\coqexternalref{nil}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqref{LF.Imp.s compile}{\coqdocaxiom{s\_compile}} \coqdocvariable{e}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} (\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvariable{e} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} @\coqexternalref{nil}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{nil}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\%\coqdocvar{list})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.s compile correct}{\coqdocaxiom{s\_compile\_correct}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  break\_imp  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> BreakImp.break\_ignore".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Imp.BreakImp.break ignore}{\coqdocaxiom{BreakImp.break\_ignore}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{c} : \coqref{LF.Imp.BreakImp.com}{\coqdocinductive{BreakImp.com}}) (\coqdocvar{st} \coqdocvar{st'} : \coqref{LF.Imp.state}{\coqdocdefinition{state}}) (\coqdocvar{s} : \coqref{LF.Imp.BreakImp.result}{\coqdocinductive{BreakImp.result}}),\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Imp.BreakImp.ceval}{\coqdocinductive{BreakImp.ceval}} (\coqref{LF.Imp.BreakImp.CSeq}{\coqdocconstructor{BreakImp.CSeq}} \coqref{LF.Imp.BreakImp.CBreak}{\coqdocconstructor{BreakImp.CBreak}} \coqdocvariable{c}) \coqdocvariable{st} \coqdocvariable{s} \coqdocvariable{st'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{st} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{st'})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.BreakImp.break ignore}{\coqdocaxiom{BreakImp.break\_ignore}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> BreakImp.while\_continue".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Imp.BreakImp.while continue}{\coqdocaxiom{BreakImp.while\_continue}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{b} : \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}}) (\coqdocvar{c} : \coqref{LF.Imp.BreakImp.com}{\coqdocinductive{BreakImp.com}}) (\coqdocvar{st} \coqdocvar{st'} : \coqref{LF.Imp.state}{\coqdocdefinition{state}}) (\coqdocvar{s} : \coqref{LF.Imp.BreakImp.result}{\coqdocinductive{BreakImp.result}}),\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Imp.BreakImp.ceval}{\coqdocinductive{BreakImp.ceval}} (\coqref{LF.Imp.BreakImp.CWhile}{\coqdocconstructor{BreakImp.CWhile}} \coqdocvariable{b} \coqdocvariable{c}) \coqdocvariable{st} \coqdocvariable{s} \coqdocvariable{st'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Imp.BreakImp.SContinue}{\coqdocconstructor{BreakImp.SContinue}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.BreakImp.while continue}{\coqdocaxiom{BreakImp.while\_continue}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> BreakImp.while\_stops\_on\_break".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Imp.BreakImp.while stops on break}{\coqdocaxiom{BreakImp.while\_stops\_on\_break}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{b} : \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}}) (\coqdocvar{c} : \coqref{LF.Imp.BreakImp.com}{\coqdocinductive{BreakImp.com}}) (\coqdocvar{st} \coqdocvar{st'} : \coqref{LF.Imp.state}{\coqdocdefinition{state}}),\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Imp.BreakImp.ceval}{\coqdocinductive{BreakImp.ceval}} \coqdocvariable{c} \coqdocvariable{st} \coqref{LF.Imp.BreakImp.SBreak}{\coqdocconstructor{BreakImp.SBreak}} \coqdocvariable{st'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Imp.BreakImp.ceval}{\coqdocinductive{BreakImp.ceval}} (\coqref{LF.Imp.BreakImp.CWhile}{\coqdocconstructor{BreakImp.CWhile}} \coqdocvariable{b} \coqdocvariable{c}) \coqdocvariable{st} \coqref{LF.Imp.BreakImp.SContinue}{\coqdocconstructor{BreakImp.SContinue}} \coqdocvariable{st'})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.BreakImp.while stops on break}{\coqdocaxiom{BreakImp.while\_stops\_on\_break}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ImpTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 23".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 35".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- AExp.optimize\_0plus\_b\_sound ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.AExp.optimize 0plus b sound}{\coqdocaxiom{AExp.optimize\_0plus\_b\_sound}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- AExp.beval\_iff\_bevalR ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.AExp.beval iff bevalR}{\coqdocaxiom{AExp.beval\_iff\_bevalR}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- ceval\_example2 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.ceval example2}{\coqdocaxiom{ceval\_example2}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- loop\_never\_stops ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.loop never stops}{\coqdocaxiom{loop\_never\_stops}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- no\_whiles\_eqv ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.no whiles eqv}{\coqdocaxiom{no\_whiles\_eqv}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- no\_whiles\_terminating ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- s\_execute1 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.s execute1}{\coqdocaxiom{s\_execute1}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- s\_execute2 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.s execute2}{\coqdocaxiom{s\_execute2}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- s\_compile1 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.s compile1}{\coqdocaxiom{s\_compile1}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- s\_compile\_correct ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.s compile correct}{\coqdocaxiom{s\_compile\_correct}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- BreakImp.break\_ignore ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.BreakImp.break ignore}{\coqdocaxiom{BreakImp.break\_ignore}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- BreakImp.while\_continue ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.BreakImp.while continue}{\coqdocaxiom{BreakImp.while\_continue}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- BreakImp.while\_stops\_on\_break ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Imp.BreakImp.while stops on break}{\coqdocaxiom{BreakImp.while\_stops\_on\_break}}.\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.RelTest}{Library }{LF.RelTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Rel}{\coqdoclibrary{Rel}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.RelTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.RelTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.RelTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.RelTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Rel}{\coqdoclibrary{Rel}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.RelTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.IndPrinciplesTest}{Library }{LF.IndPrinciplesTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.IndPrinciples}{\coqdoclibrary{IndPrinciples}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.IndPrinciplesTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.IndPrinciplesTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.IndPrinciplesTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.IndPrinciplesTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.IndPrinciples}{\coqdoclibrary{IndPrinciples}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPrinciplesTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.ProofObjectsTest}{Library }{LF.ProofObjectsTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.ProofObjects}{\coqdoclibrary{ProofObjects}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.ProofObjectsTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.ProofObjectsTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.ProofObjectsTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.ProofObjectsTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.ProofObjects}{\coqdoclibrary{ProofObjects}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ProofObjectsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  eight\_is\_even  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> ev\_8".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.ProofObjects.ev 8}{\coqdocaxiom{ev\_8}} ((\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 8)).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.ProofObjects.ev 8}{\coqdocaxiom{ev\_8}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ProofObjectsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> ev\_8'".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.ProofObjects.ev 8'}{\coqdocaxiom{ev\_8'}} ((\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 8)).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.ProofObjects.ev 8'}{\coqdocaxiom{ev\_8'}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ProofObjectsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  equality\_\_leibniz\_equality  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> MyEquality.equality\_\_leibniz\_equality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.ProofObjects.MyEquality.equality  leibniz equality}{\coqdocaxiom{MyEquality.equality\_\_leibniz\_equality}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y} : \coqdocvariable{X}),\coqdoceol
\coqdocindent{0.50em}
@\coqref{LF.ProofObjects.MyEquality.eq}{\coqdocinductive{MyEquality.eq}} \coqdocvariable{X} \coqdocvariable{x} \coqdocvariable{y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{\ensuremath{\forall}} \coqdocvar{P} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}, \coqdocvariable{P} \coqdocvariable{x} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P} \coqdocvariable{y})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.ProofObjects.MyEquality.equality  leibniz equality}{\coqdocaxiom{MyEquality.equality\_\_leibniz\_equality}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ProofObjectsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 4".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 4".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- ev\_8 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.ProofObjects.ev 8}{\coqdocaxiom{ev\_8}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- ev\_8' ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.ProofObjects.ev 8'}{\coqdocaxiom{ev\_8'}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- MyEquality.equality\_\_leibniz\_equality ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.ProofObjects.MyEquality.equality  leibniz equality}{\coqdocaxiom{MyEquality.equality\_\_leibniz\_equality}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.MapsTest}{Library }{LF.MapsTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Maps}{\coqdoclibrary{Maps}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.MapsTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.MapsTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.MapsTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.MapsTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Maps}{\coqdoclibrary{Maps}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.MapsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  t\_update\_same  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> t\_update\_same".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Maps.t update same}{\coqdocaxiom{t\_update\_same}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{m} : \coqref{LF.Maps.total map}{\coqdocdefinition{total\_map}} \coqdocvariable{A}) (\coqdocvar{x} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}), \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{m} \coqdocvariable{x}\coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Maps.t update same}{\coqdocaxiom{t\_update\_same}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.MapsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  t\_update\_permute  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> t\_update\_permute".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Maps.t update permute}{\coqdocaxiom{t\_update\_permute}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{m} : \coqref{LF.Maps.total map}{\coqdocdefinition{total\_map}} \coqdocvariable{A}) (\coqdocvar{v1} \coqdocvar{v2} : \coqdocvariable{A}) (\coqdocvar{x1} \coqdocvar{x2} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}),\coqdoceol
\coqdocindent{0.50em}
\coqdocvariable{x2} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{x1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x1} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{v1}\coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{x2} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{v2}\coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x2} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{v2}\coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{x1} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{v1}\coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Maps.t update permute}{\coqdocaxiom{t\_update\_permute}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.MapsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 5".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 5".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- t\_update\_same ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Maps.t update same}{\coqdocaxiom{t\_update\_same}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- t\_update\_permute ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Maps.t update permute}{\coqdocaxiom{t\_update\_permute}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.IndPropTest}{Library }{LF.IndPropTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.IndProp}{\coqdoclibrary{IndProp}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.IndPropTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.IndPropTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.IndPropTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.IndPropTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.IndProp}{\coqdoclibrary{IndProp}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPropTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  ev\_double  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> ev\_double".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.IndProp.ev double}{\coqdocaxiom{ev\_double}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n}))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.ev double}{\coqdocaxiom{ev\_double}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPropTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  inversion\_practice  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> SSSSev\_\_even".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.IndProp.SSSSev  even}{\coqdocaxiom{SSSSev\_\_even}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n})))) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.SSSSev  even}{\coqdocaxiom{SSSSev\_\_even}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPropTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  ev5\_nonsense  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> ev5\_nonsense".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.IndProp.ev5 nonsense}{\coqdocaxiom{ev5\_nonsense}} ((\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 5 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} 2 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 9)).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.ev5 nonsense}{\coqdocaxiom{ev5\_nonsense}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPropTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  ev\_sum  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> ev\_sum".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.IndProp.ev sum}{\coqdocaxiom{ev\_sum}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.ev sum}{\coqdocaxiom{ev\_sum}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPropTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  ev\_ev\_\_ev  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> ev\_ev\_\_ev".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.IndProp.ev ev  ev}{\coqdocaxiom{ev\_ev\_\_ev}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{m})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.ev ev  ev}{\coqdocaxiom{ev\_ev\_\_ev}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPropTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  R\_provability  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: R.R\_provability".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.IndProp.R.manual grade for R provability}{\coqdocdefinition{R.manual\_grade\_for\_R\_provability}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  subsequence  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> subseq\_refl".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.IndProp.subseq refl}{\coqdocaxiom{subseq\_refl}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqref{LF.IndProp.subseq}{\coqdocinductive{subseq}} \coqdocvariable{l} \coqdocvariable{l})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.subseq refl}{\coqdocaxiom{subseq\_refl}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPropTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> subseq\_app".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.IndProp.subseq app}{\coqdocaxiom{subseq\_app}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} \coqdocvar{l1} \coqdocvar{l2} \coqdocvar{l3} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqref{LF.IndProp.subseq}{\coqdocinductive{subseq}} \coqdocvariable{l1} \coqdocvariable{l2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.subseq}{\coqdocinductive{subseq}} \coqdocvariable{l1} (\coqdocvariable{l2} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{l3}))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.subseq app}{\coqdocaxiom{subseq\_app}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPropTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  exp\_match\_ex1  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> empty\_is\_empty".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.IndProp.empty is empty}{\coqdocaxiom{empty\_is\_empty}} ((\coqdockw{\ensuremath{\forall}} (\coqdocvar{T} : \coqdockw{Type}) (\coqdocvar{s} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}), \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} @\coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}} \coqdocvariable{T}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.empty is empty}{\coqdocaxiom{empty\_is\_empty}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPropTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> MUnion'".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.IndProp.MUnion'}{\coqdocaxiom{MUnion'}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{T} : \coqdockw{Type}) (\coqdocvar{s} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}) (\coqdocvar{re1} \coqdocvar{re2} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{0.50em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re1} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} @\coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} \coqdocvariable{T} \coqdocvariable{re1} \coqdocvariable{re2})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.MUnion'}{\coqdocaxiom{MUnion'}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPropTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> MStar'".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.IndProp.MStar'}{\coqdocaxiom{MStar'}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{T} : \coqdockw{Type}) (\coqdocvar{ss} : \coqref{LF.Poly.list}{\coqdocinductive{list}} (\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T})) (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{0.50em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{s} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}, @\coqref{LF.Logic.In}{\coqdocdefinition{In}} (\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}) \coqdocvariable{s} \coqdocvariable{ss} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{0.50em}
@\coqref{LF.Poly.fold}{\coqdocdefinition{fold}} (\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}) (\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}) (@\coqref{LF.Poly.app}{\coqdocdefinition{app}} \coqdocvariable{T}) \coqdocvariable{ss} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{]}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} @\coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{T} \coqdocvariable{re})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.MStar'}{\coqdocaxiom{MStar'}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPropTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  re\_not\_empty  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> re\_not\_empty".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.IndProp.re not empty}{\coqdocaxiom{re\_not\_empty}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{T} : \coqdockw{Type}, \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.re not empty}{\coqdocaxiom{re\_not\_empty}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPropTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> re\_not\_empty\_correct".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.IndProp.re not empty correct}{\coqdocaxiom{re\_not\_empty\_correct}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{T} : \coqdockw{Type}) (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{0.50em}
\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{s} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} @\coqref{LF.IndProp.re not empty}{\coqdocaxiom{re\_not\_empty}} \coqdocvariable{T} \coqdocvariable{re} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.re not empty correct}{\coqdocaxiom{re\_not\_empty\_correct}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPropTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  weak\_pumping  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Pumping.weak\_pumping".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 10".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.IndProp.Pumping.weak pumping}{\coqdocaxiom{Pumping.weak\_pumping}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{T} : \coqdockw{Type}) (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) (\coqdocvar{s} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{0.50em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{0.50em}
@\coqref{LF.IndProp.Pumping.pumping constant}{\coqdocdefinition{Pumping.pumping\_constant}} \coqdocvariable{T} \coqdocvariable{re} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} @\coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{T} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{0.50em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{s1} \coqdocvar{s2} \coqdocvar{s3} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}}\coqdoceol
\coqdocindent{1.50em}
\coqdocvariable{s} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{s1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s2} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s3} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{1.50em}
\coqdocvariable{s2} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{s1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} @\coqref{LF.IndProp.Pumping.napp}{\coqdocdefinition{Pumping.napp}} \coqdocvariable{T} \coqdocvariable{m} \coqdocvariable{s2} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s3} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.Pumping.weak pumping}{\coqdocaxiom{Pumping.weak\_pumping}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPropTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  reflect\_iff  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> reflect\_iff".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.IndProp.reflect iff}{\coqdocaxiom{reflect\_iff}} ((\coqdockw{\ensuremath{\forall}} (\coqdocvar{P} : \coqdockw{Prop}) (\coqdocvar{b} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}), \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} \coqdocvariable{P} \coqdocvariable{b} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.reflect iff}{\coqdocaxiom{reflect\_iff}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPropTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  eqbP\_practice  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> eqbP\_practice".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.IndProp.eqbP practice}{\coqdocaxiom{eqbP\_practice}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}), \coqref{LF.IndProp.count}{\coqdocdefinition{count}} \coqdocvariable{n} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} @\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqdocvariable{n} \coqdocvariable{l})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.eqbP practice}{\coqdocaxiom{eqbP\_practice}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.IndPropTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  nostutter\_defn  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: nostutter".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.IndProp.manual grade for nostutter}{\coqdocdefinition{manual\_grade\_for\_nostutter}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  filter\_challenge  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: filter\_challenge".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 6".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.IndProp.manual grade for filter challenge}{\coqdocdefinition{manual\_grade\_for\_filter\_challenge}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 25".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 46".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- ev\_double ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.ev double}{\coqdocaxiom{ev\_double}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- SSSSev\_\_even ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.SSSSev  even}{\coqdocaxiom{SSSSev\_\_even}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- ev5\_nonsense ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.ev5 nonsense}{\coqdocaxiom{ev5\_nonsense}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- ev\_sum ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.ev sum}{\coqdocaxiom{ev\_sum}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- R\_provability ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- empty\_is\_empty ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.empty is empty}{\coqdocaxiom{empty\_is\_empty}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- MUnion' ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.MUnion'}{\coqdocaxiom{MUnion'}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- MStar' ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.MStar'}{\coqdocaxiom{MStar'}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- re\_not\_empty ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.re not empty}{\coqdocaxiom{re\_not\_empty}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- re\_not\_empty\_correct ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.re not empty correct}{\coqdocaxiom{re\_not\_empty\_correct}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- reflect\_iff ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.reflect iff}{\coqdocaxiom{reflect\_iff}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- eqbP\_practice ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.eqbP practice}{\coqdocaxiom{eqbP\_practice}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- nostutter ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- ev\_ev\_\_ev ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.ev ev  ev}{\coqdocaxiom{ev\_ev\_\_ev}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- subseq\_refl ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.subseq refl}{\coqdocaxiom{subseq\_refl}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- subseq\_app ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.subseq app}{\coqdocaxiom{subseq\_app}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- Pumping.weak\_pumping ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.IndProp.Pumping.weak pumping}{\coqdocaxiom{Pumping.weak\_pumping}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- filter\_challenge ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.LogicTest}{Library }{LF.LogicTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Logic}{\coqdoclibrary{Logic}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.LogicTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.LogicTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.LogicTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.LogicTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Logic}{\coqdoclibrary{Logic}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  and\_exercise  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> and\_exercise".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.and exercise}{\coqdocaxiom{and\_exercise}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0)).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.and exercise}{\coqdocaxiom{and\_exercise}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  and\_assoc  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> and\_assoc".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.and assoc}{\coqdocaxiom{and\_assoc}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} : \coqdockw{Prop}, \coqdocvariable{P} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{Q} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{R} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{R})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.and assoc}{\coqdocaxiom{and\_assoc}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  mult\_eq\_0  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> mult\_eq\_0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.mult eq 0}{\coqdocaxiom{mult\_eq\_0}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0)).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.mult eq 0}{\coqdocaxiom{mult\_eq\_0}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  or\_commut  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> or\_commut".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.or commut}{\coqdocaxiom{or\_commut}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop}, \coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{P})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.or commut}{\coqdocaxiom{or\_commut}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  double\_neg\_inf  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: double\_neg\_inf".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Logic.manual grade for double neg inf}{\coqdocdefinition{manual\_grade\_for\_double\_neg\_inf}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  contrapositive  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> contrapositive".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.contrapositive}{\coqdocaxiom{contrapositive}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqdocvariable{P})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.contrapositive}{\coqdocaxiom{contrapositive}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  not\_both\_true\_and\_false  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> not\_both\_true\_and\_false".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.not both true and false}{\coqdocaxiom{not\_both\_true\_and\_false}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{P} : \coqdockw{Prop}, \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqdocvariable{P}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.not both true and false}{\coqdocaxiom{not\_both\_true\_and\_false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  informal\_not\_PNP  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: informal\_not\_PNP".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Logic.manual grade for informal not PNP}{\coqdocdefinition{manual\_grade\_for\_informal\_not\_PNP}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  or\_distributes\_over\_and  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> or\_distributes\_over\_and".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.or distributes over and}{\coqdocaxiom{or\_distributes\_over\_and}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} : \coqdockw{Prop}, \coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{Q} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{R} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{R}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.or distributes over and}{\coqdocaxiom{or\_distributes\_over\_and}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  dist\_not\_exists  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> dist\_not\_exists".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.dist not exists}{\coqdocaxiom{dist\_not\_exists}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{P} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}),\coqdoceol
\coqdocindent{0.50em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x} : \coqdocvariable{X}, \coqdocvariable{P} \coqdocvariable{x}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x} : \coqdocvariable{X}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqdocvariable{P} \coqdocvariable{x}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.dist not exists}{\coqdocaxiom{dist\_not\_exists}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  dist\_exists\_or  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> dist\_exists\_or".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.dist exists or}{\coqdocaxiom{dist\_exists\_or}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{P} \coqdocvar{Q} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}),\coqdoceol
\coqdocindent{0.50em}
\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x} : \coqdocvariable{X}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{P} \coqdocvariable{x} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{Q} \coqdocvariable{x}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x} : \coqdocvariable{X}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{P} \coqdocvariable{x}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x} : \coqdocvariable{X}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{Q} \coqdocvariable{x}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.dist exists or}{\coqdocaxiom{dist\_exists\_or}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  In\_map\_iff  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> In\_map\_iff".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.In map iff}{\coqdocaxiom{In\_map\_iff}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{A} \coqdocvar{B} : \coqdockw{Type}) (\coqdocvar{f} : \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{B}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{A}) (\coqdocvar{y} : \coqdocvariable{B}),\coqdoceol
\coqdocindent{0.50em}
@\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{B} \coqdocvariable{y} (@\coqref{LF.Poly.map}{\coqdocdefinition{map}} \coqdocvariable{A} \coqdocvariable{B} \coqdocvariable{f} \coqdocvariable{l}) \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x} : \coqdocvariable{A}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{f} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{y} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} @\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{A} \coqdocvariable{x} \coqdocvariable{l}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.In map iff}{\coqdocaxiom{In\_map\_iff}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  In\_app\_iff  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> In\_app\_iff".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.In app iff}{\coqdocaxiom{In\_app\_iff}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{l} \coqdocvar{l'} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{A}) (\coqdocvar{a} : \coqdocvariable{A}),\coqdoceol
\coqdocindent{0.50em}
@\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{A} \coqdocvariable{a} (\coqdocvariable{l} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{l'}) \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} @\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{A} \coqdocvariable{a} \coqdocvariable{l} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} @\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{A} \coqdocvariable{a} \coqdocvariable{l'})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.In app iff}{\coqdocaxiom{In\_app\_iff}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  All  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> All".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.All}{\coqdocaxiom{All}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{T} : \coqdockw{Type}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.All}{\coqdocaxiom{All}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  combine\_odd\_even  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> combine\_odd\_even".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.combine odd even}{\coqdocaxiom{combine\_odd\_even}} ((\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.combine odd even}{\coqdocaxiom{combine\_odd\_even}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  tr\_rev\_correct  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> tr\_rev\_correct".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 6".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.tr rev correct}{\coqdocaxiom{tr\_rev\_correct}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{X} : \coqdockw{Type}, @\coqref{LF.Logic.tr rev}{\coqdocdefinition{tr\_rev}} \coqdocvariable{X} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} @\coqref{LF.Poly.rev}{\coqdocdefinition{rev}} \coqdocvariable{X})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.tr rev correct}{\coqdocaxiom{tr\_rev\_correct}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  evenb\_double\_conv  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> evenb\_double\_conv".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.evenb double conv}{\coqdocaxiom{evenb\_double\_conv}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{0.50em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{k} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{if} \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvariable{n} \coqdockw{then} \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{k} \coqdockw{else} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{k})\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.evenb double conv}{\coqdocaxiom{evenb\_double\_conv}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  logical\_connectives  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> andb\_true\_iff".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.andb true iff}{\coqdocaxiom{andb\_true\_iff}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} \coqdocvar{b1} \coqdocvar{b2} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}, \coqdocvariable{b1} \coqref{LF.Basics.:::x 'x26x26' x}{\coqdocnotation{\&\&}} \coqdocvariable{b2} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{b1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{b2} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.andb true iff}{\coqdocaxiom{andb\_true\_iff}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> orb\_true\_iff".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.orb true iff}{\coqdocaxiom{orb\_true\_iff}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} \coqdocvar{b1} \coqdocvar{b2} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}, \coqdocvariable{b1} \coqref{LF.Basics.:::x '||' x}{\coqdocnotation{||}} \coqdocvariable{b2} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{b1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{b2} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.orb true iff}{\coqdocaxiom{orb\_true\_iff}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  eqb\_neq  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> eqb\_neq".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.eqb neq}{\coqdocaxiom{eqb\_neq}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{y}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{x} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{y})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.eqb neq}{\coqdocaxiom{eqb\_neq}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  eqb\_list  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> eqb\_list".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.eqb list}{\coqdocaxiom{eqb\_list}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{A} : \coqdockw{Type}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.eqb list}{\coqdocaxiom{eqb\_list}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  All\_forallb  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> forallb\_true\_iff".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.forallb true iff}{\coqdocaxiom{forallb\_true\_iff}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{test} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{0.50em}
@\coqref{LF.Logic.forallb}{\coqdocdefinition{forallb}} \coqdocvariable{X} \coqdocvariable{test} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} @\coqref{LF.Logic.All}{\coqdocaxiom{All}} \coqdocvariable{X} (\coqdockw{fun} \coqdocvar{x} : \coqdocvariable{X} \ensuremath{\Rightarrow} \coqdocvariable{test} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}) \coqdocvariable{l})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.forallb true iff}{\coqdocaxiom{forallb\_true\_iff}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  excluded\_middle\_irrefutable  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> excluded\_middle\_irrefutable".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.excluded middle irrefutable}{\coqdocaxiom{excluded\_middle\_irrefutable}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{P} : \coqdockw{Prop}, \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqdocvariable{P}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.excluded middle irrefutable}{\coqdocaxiom{excluded\_middle\_irrefutable}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  not\_exists\_dist  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> not\_exists\_dist".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Logic.not exists dist}{\coqdocaxiom{not\_exists\_dist}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Logic.excluded middle}{\coqdocdefinition{excluded\_middle}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{0.50em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{P} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}),\coqdoceol
\coqdocindent{0.50em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x} : \coqdocvariable{X}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqdocvariable{P} \coqdocvariable{x}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{\ensuremath{\forall}} \coqdocvar{x} : \coqdocvariable{X}, \coqdocvariable{P} \coqdocvariable{x})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.not exists dist}{\coqdocaxiom{not\_exists\_dist}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.LogicTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 46".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 52".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- and\_exercise ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.and exercise}{\coqdocaxiom{and\_exercise}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- and\_assoc ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.and assoc}{\coqdocaxiom{and\_assoc}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- mult\_eq\_0 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.mult eq 0}{\coqdocaxiom{mult\_eq\_0}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- or\_commut ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.or commut}{\coqdocaxiom{or\_commut}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- contrapositive ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.contrapositive}{\coqdocaxiom{contrapositive}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- not\_both\_true\_and\_false ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.not both true and false}{\coqdocaxiom{not\_both\_true\_and\_false}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- or\_distributes\_over\_and ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.or distributes over and}{\coqdocaxiom{or\_distributes\_over\_and}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- dist\_not\_exists ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.dist not exists}{\coqdocaxiom{dist\_not\_exists}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- dist\_exists\_or ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.dist exists or}{\coqdocaxiom{dist\_exists\_or}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- In\_map\_iff ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.In map iff}{\coqdocaxiom{In\_map\_iff}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- In\_app\_iff ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.In app iff}{\coqdocaxiom{In\_app\_iff}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- All ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.All}{\coqdocaxiom{All}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- combine\_odd\_even ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.combine odd even}{\coqdocaxiom{combine\_odd\_even}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- tr\_rev\_correct ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.tr rev correct}{\coqdocaxiom{tr\_rev\_correct}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- evenb\_double\_conv ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.evenb double conv}{\coqdocaxiom{evenb\_double\_conv}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- andb\_true\_iff ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.andb true iff}{\coqdocaxiom{andb\_true\_iff}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- orb\_true\_iff ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.orb true iff}{\coqdocaxiom{orb\_true\_iff}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- eqb\_neq ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.eqb neq}{\coqdocaxiom{eqb\_neq}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- eqb\_list ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.eqb list}{\coqdocaxiom{eqb\_list}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- forallb\_true\_iff ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.forallb true iff}{\coqdocaxiom{forallb\_true\_iff}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- excluded\_middle\_irrefutable ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.excluded middle irrefutable}{\coqdocaxiom{excluded\_middle\_irrefutable}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- double\_neg\_inf ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- informal\_not\_PNP ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- not\_exists\_dist ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.not exists dist}{\coqdocaxiom{not\_exists\_dist}}.\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.TacticsTest}{Library }{LF.TacticsTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Tactics}{\coqdoclibrary{Tactics}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.TacticsTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.TacticsTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.TacticsTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.TacticsTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Tactics}{\coqdoclibrary{Tactics}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.TacticsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  apply\_exercise1  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> rev\_exercise1".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Tactics.rev exercise1}{\coqdocaxiom{rev\_exercise1}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{l} \coqdocvar{l'} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} @\coqref{LF.Poly.rev}{\coqdocdefinition{rev}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqdocvariable{l'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{l'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} @\coqref{LF.Poly.rev}{\coqdocdefinition{rev}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqdocvariable{l})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.rev exercise1}{\coqdocaxiom{rev\_exercise1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.TacticsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  injection\_ex3  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> injection\_ex3".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Tactics.injection ex3}{\coqdocaxiom{injection\_ex3}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvariable{X}) (\coqdocvar{l} \coqdocvar{j} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{0.50em}
\coqdocvariable{x} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{y} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{z} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{j} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{j} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{z} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{y})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.injection ex3}{\coqdocaxiom{injection\_ex3}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.TacticsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  discriminate\_ex3  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> discriminate\_ex3".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Tactics.discriminate ex3}{\coqdocaxiom{discriminate\_ex3}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvariable{X}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{x} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{y} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{z})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.discriminate ex3}{\coqdocaxiom{discriminate\_ex3}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.TacticsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  eqb\_true  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> eqb\_true".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Tactics.eqb true}{\coqdocaxiom{eqb\_true}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{m}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.eqb true}{\coqdocaxiom{eqb\_true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.TacticsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  eqb\_true\_informal  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: informal\_proof".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Tactics.manual grade for informal proof}{\coqdocdefinition{manual\_grade\_for\_informal\_proof}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  plus\_n\_n\_injective  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> plus\_n\_n\_injective".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Tactics.plus n n injective}{\coqdocaxiom{plus\_n\_n\_injective}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.plus n n injective}{\coqdocaxiom{plus\_n\_n\_injective}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.TacticsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  gen\_dep\_practice  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> nth\_error\_after\_last".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Tactics.nth error after last}{\coqdocaxiom{nth\_error\_after\_last}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{0.50em}
@\coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{X} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} @\coqref{LF.Poly.nth error}{\coqdocdefinition{nth\_error}} \coqdocvariable{X} \coqdocvariable{l} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} @\coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \coqdocvariable{X})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.nth error after last}{\coqdocaxiom{nth\_error\_after\_last}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.TacticsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  destruct\_eqn\_practice  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> bool\_fn\_applied\_thrice".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Tactics.bool fn applied thrice}{\coqdocaxiom{bool\_fn\_applied\_thrice}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{f} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{b} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}), \coqdocvariable{f} (\coqdocvariable{f} (\coqdocvariable{f} \coqdocvariable{b})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{f} \coqdocvariable{b})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.bool fn applied thrice}{\coqdocaxiom{bool\_fn\_applied\_thrice}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.TacticsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  eqb\_sym  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> eqb\_sym".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Tactics.eqb sym}{\coqdocaxiom{eqb\_sym}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{m}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{m} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{n}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.eqb sym}{\coqdocaxiom{eqb\_sym}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.TacticsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  split\_combine  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: split\_combine".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Tactics.manual grade for split combine}{\coqdocdefinition{manual\_grade\_for\_split\_combine}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  filter\_exercise  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> filter\_exercise".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Tactics.filter exercise}{\coqdocaxiom{filter\_exercise}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{test} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{x} : \coqdocvariable{X}) (\coqdocvar{l} \coqdocvar{lf} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{0.50em}
@\coqref{LF.Poly.filter}{\coqdocdefinition{filter}} \coqdocvariable{X} \coqdocvariable{test} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{x} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{lf} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{test} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.filter exercise}{\coqdocaxiom{filter\_exercise}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.TacticsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  forall\_exists\_challenge  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> existsb\_existsb'".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 6".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Tactics.existsb existsb'}{\coqdocaxiom{existsb\_existsb'}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{test} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{0.50em}
@\coqref{LF.Tactics.existsb}{\coqdocaxiom{existsb}} \coqdocvariable{X} \coqdocvariable{test} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} @\coqref{LF.Tactics.existsb'}{\coqdocaxiom{existsb'}} \coqdocvariable{X} \coqdocvariable{test} \coqdocvariable{l})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.existsb existsb'}{\coqdocaxiom{existsb\_existsb'}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.TacticsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 20".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 34".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- rev\_exercise1 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.rev exercise1}{\coqdocaxiom{rev\_exercise1}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- injection\_ex3 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.injection ex3}{\coqdocaxiom{injection\_ex3}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- discriminate\_ex3 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.discriminate ex3}{\coqdocaxiom{discriminate\_ex3}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- eqb\_true ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.eqb true}{\coqdocaxiom{eqb\_true}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- plus\_n\_n\_injective ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.plus n n injective}{\coqdocaxiom{plus\_n\_n\_injective}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- nth\_error\_after\_last ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.nth error after last}{\coqdocaxiom{nth\_error\_after\_last}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- bool\_fn\_applied\_thrice ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.bool fn applied thrice}{\coqdocaxiom{bool\_fn\_applied\_thrice}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- eqb\_sym ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.eqb sym}{\coqdocaxiom{eqb\_sym}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- informal\_proof ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- split\_combine ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- filter\_exercise ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.filter exercise}{\coqdocaxiom{filter\_exercise}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- existsb\_existsb' ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Tactics.existsb existsb'}{\coqdocaxiom{existsb\_existsb'}}.\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.PolyTest}{Library }{LF.PolyTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Poly}{\coqdoclibrary{Poly}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.PolyTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.PolyTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.PolyTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.PolyTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Poly}{\coqdoclibrary{Poly}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  mumble\_grumble  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: mumble\_grumble".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Poly.manual grade for mumble grumble}{\coqdocdefinition{manual\_grade\_for\_mumble\_grumble}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  split  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> split".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.split}{\coqdocaxiom{split}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}, \coqref{LF.Poly.list}{\coqdocinductive{list}} (\coqdocvariable{X} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{Y}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{Y})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.split}{\coqdocaxiom{split}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> test\_split".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.test split}{\coqdocaxiom{test\_split}} (\coqdoceol
\coqdocnoindent
(@\coqref{LF.Poly.split}{\coqdocaxiom{split}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}1\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}2\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.test split}{\coqdocaxiom{test\_split}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  filter\_even\_gt7  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> test\_filter\_even\_gt7\_1".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.test filter even gt7 1}{\coqdocaxiom{test\_filter\_even\_gt7\_1}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Poly.filter even gt7}{\coqdocaxiom{filter\_even\_gt7}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 6\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 9\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 10\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 12\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 8\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}10\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 12\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 8\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.test filter even gt7 1}{\coqdocaxiom{test\_filter\_even\_gt7\_1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> test\_filter\_even\_gt7\_2".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.test filter even gt7 2}{\coqdocaxiom{test\_filter\_even\_gt7\_2}} ((\coqref{LF.Poly.filter even gt7}{\coqdocaxiom{filter\_even\_gt7}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 6\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 19\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 129\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{]}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.test filter even gt7 2}{\coqdocaxiom{test\_filter\_even\_gt7\_2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  partition  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> partition".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.partition}{\coqdocaxiom{partition}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{X} : \coqdockw{Type}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.partition}{\coqdocaxiom{partition}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> test\_partition1".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.test partition1}{\coqdocaxiom{test\_partition1}} ((@\coqref{LF.Poly.partition}{\coqdocaxiom{partition}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.test partition1}{\coqdocaxiom{test\_partition1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> test\_partition2".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.test partition2}{\coqdocaxiom{test\_partition2}} (\coqdoceol
\coqdocnoindent
(@\coqref{LF.Poly.partition}{\coqdocaxiom{partition}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} (\coqdockw{fun} \coqdocvar{\_} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \ensuremath{\Rightarrow} \coqref{LF.Basics.false}{\coqdocconstructor{false}}) \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 9\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 0\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{]}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 9\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 0\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.test partition2}{\coqdocaxiom{test\_partition2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  map\_rev  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> map\_rev".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.map rev}{\coqdocaxiom{map\_rev}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}) (\coqdocvar{f} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{0.50em}
@\coqref{LF.Poly.map}{\coqdocdefinition{map}} \coqdocvariable{X} \coqdocvariable{Y} \coqdocvariable{f} (@\coqref{LF.Poly.rev}{\coqdocdefinition{rev}} \coqdocvariable{X} \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} @\coqref{LF.Poly.rev}{\coqdocdefinition{rev}} \coqdocvariable{Y} (@\coqref{LF.Poly.map}{\coqdocdefinition{map}} \coqdocvariable{X} \coqdocvariable{Y} \coqdocvariable{f} \coqdocvariable{l}))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.map rev}{\coqdocaxiom{map\_rev}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  flat\_map  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> flat\_map".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.flat map}{\coqdocaxiom{flat\_map}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{Y}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{Y})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.flat map}{\coqdocaxiom{flat\_map}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> test\_flat\_map1".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.test flat map1}{\coqdocaxiom{test\_flat\_map1}} (\coqdoceol
\coqdocnoindent
(@\coqref{LF.Poly.flat map}{\coqdocaxiom{flat\_map}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} (\coqdockw{fun} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \ensuremath{\Rightarrow} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} \coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} \coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}) \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.test flat map1}{\coqdocaxiom{test\_flat\_map1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  fold\_types\_different  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: fold\_types\_different".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Poly.manual grade for fold types different}{\coqdocdefinition{manual\_grade\_for\_fold\_types\_different}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  fold\_length  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Exercises.fold\_length\_correct".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.Exercises.fold length correct}{\coqdocaxiom{Exercises.fold\_length\_correct}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}), @\coqref{LF.Poly.Exercises.fold length}{\coqdocdefinition{Exercises.fold\_length}} \coqdocvariable{X} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} @\coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{X} \coqdocvariable{l})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.fold length correct}{\coqdocaxiom{Exercises.fold\_length\_correct}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  fold\_map  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: Exercises.fold\_map".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Poly.Exercises.manual grade for fold map}{\coqdocdefinition{Exercises.manual\_grade\_for\_fold\_map}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  currying  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Exercises.uncurry\_curry".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.Exercises.uncurry curry}{\coqdocaxiom{Exercises.uncurry\_curry}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} \coqdocvar{Y} \coqdocvar{Z} : \coqdockw{Type}) (\coqdocvar{f} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z}) (\coqdocvar{x} : \coqdocvariable{X}) (\coqdocvar{y} : \coqdocvariable{Y}),\coqdoceol
\coqdocindent{0.50em}
@\coqref{LF.Poly.Exercises.prod curry}{\coqdocdefinition{Exercises.prod\_curry}} \coqdocvariable{X} \coqdocvariable{Y} \coqdocvariable{Z} (@\coqref{LF.Poly.Exercises.prod uncurry}{\coqdocaxiom{Exercises.prod\_uncurry}} \coqdocvariable{X} \coqdocvariable{Y} \coqdocvariable{Z} \coqdocvariable{f}) \coqdocvariable{x} \coqdocvariable{y} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{f} \coqdocvariable{x} \coqdocvariable{y})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.uncurry curry}{\coqdocaxiom{Exercises.uncurry\_curry}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Exercises.curry\_uncurry".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.Exercises.curry uncurry}{\coqdocaxiom{Exercises.curry\_uncurry}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} \coqdocvar{Y} \coqdocvar{Z} : \coqdockw{Type}) (\coqdocvar{f} : \coqdocvariable{X} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z}) (\coqdocvar{p} : \coqdocvariable{X} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{Y}),\coqdoceol
\coqdocindent{0.50em}
@\coqref{LF.Poly.Exercises.prod uncurry}{\coqdocaxiom{Exercises.prod\_uncurry}} \coqdocvariable{X} \coqdocvariable{Y} \coqdocvariable{Z} (@\coqref{LF.Poly.Exercises.prod curry}{\coqdocdefinition{Exercises.prod\_curry}} \coqdocvariable{X} \coqdocvariable{Y} \coqdocvariable{Z} \coqdocvariable{f}) \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{f} \coqdocvariable{p})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.curry uncurry}{\coqdocaxiom{Exercises.curry\_uncurry}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  nth\_error\_informal  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: Exercises.informal\_proof".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Poly.Exercises.manual grade for informal proof}{\coqdocdefinition{Exercises.manual\_grade\_for\_informal\_proof}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  church\_succ  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Exercises.Church.succ\_2".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.Exercises.Church.succ 2}{\coqdocaxiom{Exercises.Church.succ\_2}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Poly.Exercises.Church.succ}{\coqdocaxiom{Exercises.Church.succ}} \coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{Exercises.Church.one}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{Exercises.Church.two}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.succ 2}{\coqdocaxiom{Exercises.Church.succ\_2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Exercises.Church.succ\_3".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.Exercises.Church.succ 3}{\coqdocaxiom{Exercises.Church.succ\_3}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Poly.Exercises.Church.succ}{\coqdocaxiom{Exercises.Church.succ}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{Exercises.Church.two}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{Exercises.Church.three}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.succ 3}{\coqdocaxiom{Exercises.Church.succ\_3}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  church\_plus  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Exercises.Church.plus\_2".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.Exercises.Church.plus 2}{\coqdocaxiom{Exercises.Church.plus\_2}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{Exercises.Church.plus}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{Exercises.Church.two}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{Exercises.Church.three}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{Exercises.Church.plus}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{Exercises.Church.three}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{Exercises.Church.two}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.plus 2}{\coqdocaxiom{Exercises.Church.plus\_2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Exercises.Church.plus\_3".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.Exercises.Church.plus 3}{\coqdocaxiom{Exercises.Church.plus\_3}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{Exercises.Church.plus}}\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{Exercises.Church.plus}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{Exercises.Church.two}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{Exercises.Church.two}})\coqdoceol
\coqdocindent{1.50em}
\coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{Exercises.Church.three}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{Exercises.Church.plus}} \coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{Exercises.Church.one}}\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{Exercises.Church.plus}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{Exercises.Church.three}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{Exercises.Church.three}}))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.plus 3}{\coqdocaxiom{Exercises.Church.plus\_3}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  church\_mult  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Exercises.Church.mult\_1".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.Exercises.Church.mult 1}{\coqdocaxiom{Exercises.Church.mult\_1}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Poly.Exercises.Church.mult}{\coqdocaxiom{Exercises.Church.mult}} \coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{Exercises.Church.one}} \coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{Exercises.Church.one}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{Exercises.Church.one}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.mult 1}{\coqdocaxiom{Exercises.Church.mult\_1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Exercises.Church.mult\_2".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.Exercises.Church.mult 2}{\coqdocaxiom{Exercises.Church.mult\_2}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Poly.Exercises.Church.mult}{\coqdocaxiom{Exercises.Church.mult}} \coqref{LF.Poly.Exercises.Church.zero}{\coqdocdefinition{Exercises.Church.zero}}\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{Exercises.Church.plus}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{Exercises.Church.three}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{Exercises.Church.three}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Poly.Exercises.Church.zero}{\coqdocdefinition{Exercises.Church.zero}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.mult 2}{\coqdocaxiom{Exercises.Church.mult\_2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Exercises.Church.mult\_3".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.Exercises.Church.mult 3}{\coqdocaxiom{Exercises.Church.mult\_3}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Poly.Exercises.Church.mult}{\coqdocaxiom{Exercises.Church.mult}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{Exercises.Church.two}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{Exercises.Church.three}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{Exercises.Church.plus}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{Exercises.Church.three}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{Exercises.Church.three}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.mult 3}{\coqdocaxiom{Exercises.Church.mult\_3}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  church\_exp  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Exercises.Church.exp\_1".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.Exercises.Church.exp 1}{\coqdocaxiom{Exercises.Church.exp\_1}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Poly.Exercises.Church.exp}{\coqdocaxiom{Exercises.Church.exp}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{Exercises.Church.two}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{Exercises.Church.two}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{Exercises.Church.plus}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{Exercises.Church.two}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{Exercises.Church.two}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.exp 1}{\coqdocaxiom{Exercises.Church.exp\_1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Exercises.Church.exp\_2".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.Exercises.Church.exp 2}{\coqdocaxiom{Exercises.Church.exp\_2}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Poly.Exercises.Church.exp}{\coqdocaxiom{Exercises.Church.exp}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{Exercises.Church.three}} \coqref{LF.Poly.Exercises.Church.zero}{\coqdocdefinition{Exercises.Church.zero}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{Exercises.Church.one}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.exp 2}{\coqdocaxiom{Exercises.Church.exp\_2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Exercises.Church.exp\_3".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Poly.Exercises.Church.exp 3}{\coqdocaxiom{Exercises.Church.exp\_3}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Poly.Exercises.Church.exp}{\coqdocaxiom{Exercises.Church.exp}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{Exercises.Church.three}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{Exercises.Church.two}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{Exercises.Church.plus}}\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Poly.Exercises.Church.mult}{\coqdocaxiom{Exercises.Church.mult}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{Exercises.Church.two}}\coqdoceol
\coqdocindent{3.00em}
(\coqref{LF.Poly.Exercises.Church.mult}{\coqdocaxiom{Exercises.Church.mult}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{Exercises.Church.two}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{Exercises.Church.two}}))\coqdoceol
\coqdocindent{1.50em}
\coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{Exercises.Church.one}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.exp 3}{\coqdocaxiom{Exercises.Church.exp\_3}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PolyTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 19".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 30".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- mumble\_grumble ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- split ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.split}{\coqdocaxiom{split}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- test\_split ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.test split}{\coqdocaxiom{test\_split}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- test\_filter\_even\_gt7\_1 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.test filter even gt7 1}{\coqdocaxiom{test\_filter\_even\_gt7\_1}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- test\_filter\_even\_gt7\_2 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.test filter even gt7 2}{\coqdocaxiom{test\_filter\_even\_gt7\_2}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- partition ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.partition}{\coqdocaxiom{partition}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- test\_partition1 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.test partition1}{\coqdocaxiom{test\_partition1}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- test\_partition2 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.test partition2}{\coqdocaxiom{test\_partition2}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- map\_rev ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.map rev}{\coqdocaxiom{map\_rev}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- flat\_map ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.flat map}{\coqdocaxiom{flat\_map}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- test\_flat\_map1 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.test flat map1}{\coqdocaxiom{test\_flat\_map1}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- Exercises.fold\_length\_correct ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.fold length correct}{\coqdocaxiom{Exercises.fold\_length\_correct}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- fold\_map ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- fold\_types\_different ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- Exercises.uncurry\_curry ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.uncurry curry}{\coqdocaxiom{Exercises.uncurry\_curry}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- Exercises.curry\_uncurry ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.curry uncurry}{\coqdocaxiom{Exercises.curry\_uncurry}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- informal\_proof ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- Exercises.Church.succ\_2 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.succ 2}{\coqdocaxiom{Exercises.Church.succ\_2}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- Exercises.Church.succ\_3 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.succ 3}{\coqdocaxiom{Exercises.Church.succ\_3}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- Exercises.Church.plus\_2 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.plus 2}{\coqdocaxiom{Exercises.Church.plus\_2}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- Exercises.Church.plus\_3 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.plus 3}{\coqdocaxiom{Exercises.Church.plus\_3}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- Exercises.Church.mult\_1 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.mult 1}{\coqdocaxiom{Exercises.Church.mult\_1}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- Exercises.Church.mult\_2 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.mult 2}{\coqdocaxiom{Exercises.Church.mult\_2}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- Exercises.Church.mult\_3 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.mult 3}{\coqdocaxiom{Exercises.Church.mult\_3}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- Exercises.Church.exp\_1 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.exp 1}{\coqdocaxiom{Exercises.Church.exp\_1}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- Exercises.Church.exp\_2 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.exp 2}{\coqdocaxiom{Exercises.Church.exp\_2}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- Exercises.Church.exp\_3 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Poly.Exercises.Church.exp 3}{\coqdocaxiom{Exercises.Church.exp\_3}}.\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.ListsTest}{Library }{LF.ListsTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Lists}{\coqdoclibrary{Lists}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.ListsTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.ListsTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.ListsTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.ListsTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Lists}{\coqdoclibrary{Lists}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  snd\_fst\_is\_swap  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.snd\_fst\_is\_swap".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.snd fst is swap}{\coqdocaxiom{NatList.snd\_fst\_is\_swap}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} \coqdocvar{p} : \coqref{LF.Lists.NatList.natprod}{\coqdocinductive{NatList.natprod}},\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Lists.NatList.pair}{\coqdocconstructor{NatList.pair}} (\coqref{LF.Lists.NatList.snd}{\coqdocdefinition{NatList.snd}} \coqdocvariable{p}) (\coqref{LF.Lists.NatList.fst}{\coqdocdefinition{NatList.fst}} \coqdocvariable{p}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.swap pair}{\coqdocdefinition{NatList.swap\_pair}} \coqdocvariable{p})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.snd fst is swap}{\coqdocaxiom{NatList.snd\_fst\_is\_swap}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  list\_funs  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.test\_nonzeros".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.test nonzeros}{\coqdocaxiom{NatList.test\_nonzeros}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Lists.NatList.nonzeros}{\coqdocaxiom{NatList.nonzeros}}\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 0\coqdoceol
\coqdocindent{3.00em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1\coqdoceol
\coqdocindent{4.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 0\coqdoceol
\coqdocindent{6.00em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 2\coqdoceol
\coqdocindent{7.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 3 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 0 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 0 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}}))))))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 2 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 3 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}})))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test nonzeros}{\coqdocaxiom{NatList.test\_nonzeros}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.test\_oddmembers".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.test oddmembers}{\coqdocaxiom{NatList.test\_oddmembers}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Lists.NatList.oddmembers}{\coqdocaxiom{NatList.oddmembers}}\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 0\coqdoceol
\coqdocindent{3.00em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1\coqdoceol
\coqdocindent{4.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 0\coqdoceol
\coqdocindent{6.00em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 2\coqdoceol
\coqdocindent{7.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 3 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 0 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 0 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}}))))))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 3 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}}))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test oddmembers}{\coqdocaxiom{NatList.test\_oddmembers}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.test\_countoddmembers2".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.test countoddmembers2}{\coqdocaxiom{NatList.test\_countoddmembers2}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Lists.NatList.countoddmembers}{\coqdocaxiom{NatList.countoddmembers}}\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 0 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 2 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 4 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}}))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0)).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test countoddmembers2}{\coqdocaxiom{NatList.test\_countoddmembers2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.test\_countoddmembers3".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.test countoddmembers3}{\coqdocaxiom{NatList.test\_countoddmembers3}} ((\coqref{LF.Lists.NatList.countoddmembers}{\coqdocaxiom{NatList.countoddmembers}} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0)).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test countoddmembers3}{\coqdocaxiom{NatList.test\_countoddmembers3}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  alternate  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.test\_alternate1".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.test alternate1}{\coqdocaxiom{NatList.test\_alternate1}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Lists.NatList.alternate}{\coqdocaxiom{NatList.alternate}}\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 2 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 3 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}})))\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 4 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 5 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 6 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}}))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 4\coqdoceol
\coqdocindent{3.00em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 2\coqdoceol
\coqdocindent{4.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 5 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 3 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 6 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}}))))))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test alternate1}{\coqdocaxiom{NatList.test\_alternate1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.test\_alternate2".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.test alternate2}{\coqdocaxiom{NatList.test\_alternate2}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Lists.NatList.alternate}{\coqdocaxiom{NatList.alternate}} (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}})\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 4 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 5 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 6 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}}))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 4 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 5 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 6 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}}))))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test alternate2}{\coqdocaxiom{NatList.test\_alternate2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.test\_alternate4".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.test alternate4}{\coqdocaxiom{NatList.test\_alternate4}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Lists.NatList.alternate}{\coqdocaxiom{NatList.alternate}} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}}\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 20 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 30 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 20 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 30 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}}))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test alternate4}{\coqdocaxiom{NatList.test\_alternate4}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  bag\_functions  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.test\_count2".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.test count2}{\coqdocaxiom{NatList.test\_count2}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Lists.NatList.count}{\coqdocaxiom{NatList.count}} 6\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1\coqdoceol
\coqdocindent{3.00em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 2\coqdoceol
\coqdocindent{4.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 3\coqdoceol
\coqdocindent{6.00em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 4 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}})))))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
0)).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test count2}{\coqdocaxiom{NatList.test\_count2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.test\_sum1".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.test sum1}{\coqdocaxiom{NatList.test\_sum1}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Lists.NatList.count}{\coqdocaxiom{NatList.count}} 1\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Lists.NatList.sum}{\coqdocaxiom{NatList.sum}}\coqdoceol
\coqdocindent{3.00em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 2 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 3 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}})))\coqdoceol
\coqdocindent{3.00em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 4 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}})))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 3)).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test sum1}{\coqdocaxiom{NatList.test\_sum1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.test\_add1".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.test add1}{\coqdocaxiom{NatList.test\_add1}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Lists.NatList.count}{\coqdocaxiom{NatList.count}} 1\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Lists.NatList.add}{\coqdocaxiom{NatList.add}} 1\coqdoceol
\coqdocindent{3.00em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 4 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}})))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 3)).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test add1}{\coqdocaxiom{NatList.test\_add1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.test\_add2".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.test add2}{\coqdocaxiom{NatList.test\_add2}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Lists.NatList.count}{\coqdocaxiom{NatList.count}} 5\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Lists.NatList.add}{\coqdocaxiom{NatList.add}} 1\coqdoceol
\coqdocindent{3.00em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 4 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}})))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0)).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test add2}{\coqdocaxiom{NatList.test\_add2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.test\_member1".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.test member1}{\coqdocaxiom{NatList.test\_member1}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Lists.NatList.member}{\coqdocaxiom{NatList.member}} 1\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 4 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}}))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test member1}{\coqdocaxiom{NatList.test\_member1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.test\_member2".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.test member2}{\coqdocaxiom{NatList.test\_member2}} (\coqdoceol
\coqdocnoindent
(\coqref{LF.Lists.NatList.member}{\coqdocaxiom{NatList.member}} 2\coqdoceol
\coqdocindent{1.50em}
(\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 4 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}}))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test member2}{\coqdocaxiom{NatList.test\_member2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  bag\_theorem  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: NatList.bag\_theorem".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Lists.NatList.manual grade for bag theorem}{\coqdocdefinition{NatList.manual\_grade\_for\_bag\_theorem}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  list\_exercises  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.app\_nil\_r".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.app nil r}{\coqdocaxiom{NatList.app\_nil\_r}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{NatList.natlist}}, \coqref{LF.Lists.NatList.app}{\coqdocdefinition{NatList.app}} \coqdocvariable{l} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{NatList.nil}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{l})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.app nil r}{\coqdocaxiom{NatList.app\_nil\_r}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.rev\_app\_distr".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.rev app distr}{\coqdocaxiom{NatList.rev\_app\_distr}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} \coqdocvar{l1} \coqdocvar{l2} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{NatList.natlist}},\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Lists.NatList.rev}{\coqdocdefinition{NatList.rev}} (\coqref{LF.Lists.NatList.app}{\coqdocdefinition{NatList.app}} \coqdocvariable{l1} \coqdocvariable{l2}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Lists.NatList.app}{\coqdocdefinition{NatList.app}} (\coqref{LF.Lists.NatList.rev}{\coqdocdefinition{NatList.rev}} \coqdocvariable{l2}) (\coqref{LF.Lists.NatList.rev}{\coqdocdefinition{NatList.rev}} \coqdocvariable{l1}))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.rev app distr}{\coqdocaxiom{NatList.rev\_app\_distr}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.rev\_involutive".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.rev involutive}{\coqdocaxiom{NatList.rev\_involutive}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{NatList.natlist}}, \coqref{LF.Lists.NatList.rev}{\coqdocdefinition{NatList.rev}} (\coqref{LF.Lists.NatList.rev}{\coqdocdefinition{NatList.rev}} \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{l})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.rev involutive}{\coqdocaxiom{NatList.rev\_involutive}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.app\_assoc4".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.app assoc4}{\coqdocaxiom{NatList.app\_assoc4}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} \coqdocvar{l1} \coqdocvar{l2} \coqdocvar{l3} \coqdocvar{l4} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{NatList.natlist}},\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Lists.NatList.app}{\coqdocdefinition{NatList.app}} \coqdocvariable{l1} (\coqref{LF.Lists.NatList.app}{\coqdocdefinition{NatList.app}} \coqdocvariable{l2} (\coqref{LF.Lists.NatList.app}{\coqdocdefinition{NatList.app}} \coqdocvariable{l3} \coqdocvariable{l4})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Lists.NatList.app}{\coqdocdefinition{NatList.app}} (\coqref{LF.Lists.NatList.app}{\coqdocdefinition{NatList.app}} (\coqref{LF.Lists.NatList.app}{\coqdocdefinition{NatList.app}} \coqdocvariable{l1} \coqdocvariable{l2}) \coqdocvariable{l3}) \coqdocvariable{l4})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.app assoc4}{\coqdocaxiom{NatList.app\_assoc4}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.nonzeros\_app".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.nonzeros app}{\coqdocaxiom{NatList.nonzeros\_app}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} \coqdocvar{l1} \coqdocvar{l2} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{NatList.natlist}},\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Lists.NatList.nonzeros}{\coqdocaxiom{NatList.nonzeros}} (\coqref{LF.Lists.NatList.app}{\coqdocdefinition{NatList.app}} \coqdocvariable{l1} \coqdocvariable{l2}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Lists.NatList.app}{\coqdocdefinition{NatList.app}} (\coqref{LF.Lists.NatList.nonzeros}{\coqdocaxiom{NatList.nonzeros}} \coqdocvariable{l1}) (\coqref{LF.Lists.NatList.nonzeros}{\coqdocaxiom{NatList.nonzeros}} \coqdocvariable{l2}))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.nonzeros app}{\coqdocaxiom{NatList.nonzeros\_app}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  eqblist  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.eqblist\_refl".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.eqblist refl}{\coqdocaxiom{NatList.eqblist\_refl}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{NatList.natlist}}, \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.eqblist}{\coqdocaxiom{NatList.eqblist}} \coqdocvariable{l} \coqdocvariable{l})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.eqblist refl}{\coqdocaxiom{NatList.eqblist\_refl}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  count\_member\_nonzero  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.count\_member\_nonzero".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.count member nonzero}{\coqdocaxiom{NatList.count\_member\_nonzero}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} \coqdocvar{s} : \coqref{LF.Lists.NatList.bag}{\coqdocdefinition{NatList.bag}}, \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}1 \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} \coqref{LF.Lists.NatList.count}{\coqdocaxiom{NatList.count}} 1 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{NatList.cons}} 1 \coqdocvariable{s})\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.count member nonzero}{\coqdocaxiom{NatList.count\_member\_nonzero}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  remove\_does\_not\_increase\_count  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.remove\_does\_not\_increase\_count".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.remove does not increase count}{\coqdocaxiom{NatList.remove\_does\_not\_increase\_count}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} \coqdocvar{s} : \coqref{LF.Lists.NatList.bag}{\coqdocdefinition{NatList.bag}},\coqdoceol
\coqdocindent{0.50em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Lists.NatList.count}{\coqdocaxiom{NatList.count}} 0 (\coqref{LF.Lists.NatList.remove one}{\coqdocaxiom{NatList.remove\_one}} 0 \coqdocvariable{s}) \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} \coqref{LF.Lists.NatList.count}{\coqdocaxiom{NatList.count}} 0 \coqdocvariable{s}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.remove does not increase count}{\coqdocaxiom{NatList.remove\_does\_not\_increase\_count}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  rev\_injective  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: NatList.rev\_injective".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 6".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Lists.NatList.manual grade for rev injective}{\coqdocdefinition{NatList.manual\_grade\_for\_rev\_injective}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  hd\_error  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> NatList.hd\_error".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.NatList.hd error}{\coqdocaxiom{NatList.hd\_error}} ((\coqref{LF.Lists.NatList.natlist}{\coqdocinductive{NatList.natlist}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Lists.NatList.natoption}{\coqdocinductive{NatList.natoption}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.hd error}{\coqdocaxiom{NatList.hd\_error}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  eqb\_id\_refl  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> eqb\_id\_refl".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.eqb id refl}{\coqdocaxiom{eqb\_id\_refl}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{x} : \coqref{LF.Lists.id}{\coqdocinductive{id}}, \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.eqb id}{\coqdocdefinition{eqb\_id}} \coqdocvariable{x} \coqdocvariable{x})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.eqb id refl}{\coqdocaxiom{eqb\_id\_refl}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  update\_eq  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> PartialMap.update\_eq".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.PartialMap.update eq}{\coqdocaxiom{PartialMap.update\_eq}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{d} : \coqref{LF.Lists.PartialMap.partial map}{\coqdocinductive{PartialMap.partial\_map}}) (\coqdocvar{x} : \coqref{LF.Lists.id}{\coqdocinductive{id}}) (\coqdocvar{v} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Lists.PartialMap.find}{\coqdocdefinition{PartialMap.find}} \coqdocvariable{x} (\coqref{LF.Lists.PartialMap.update}{\coqdocdefinition{PartialMap.update}} \coqdocvariable{d} \coqdocvariable{x} \coqdocvariable{v}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.Some}{\coqdocconstructor{NatList.Some}} \coqdocvariable{v})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.PartialMap.update eq}{\coqdocaxiom{PartialMap.update\_eq}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  update\_neq  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> PartialMap.update\_neq".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Lists.PartialMap.update neq}{\coqdocaxiom{PartialMap.update\_neq}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{d} : \coqref{LF.Lists.PartialMap.partial map}{\coqdocinductive{PartialMap.partial\_map}}) (\coqdocvar{x} \coqdocvar{y} : \coqref{LF.Lists.id}{\coqdocinductive{id}}) (\coqdocvar{o} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Lists.eqb id}{\coqdocdefinition{eqb\_id}} \coqdocvariable{x} \coqdocvariable{y} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{0.50em}
\coqref{LF.Lists.PartialMap.find}{\coqdocdefinition{PartialMap.find}} \coqdocvariable{x} (\coqref{LF.Lists.PartialMap.update}{\coqdocdefinition{PartialMap.update}} \coqdocvariable{d} \coqdocvariable{y} \coqdocvariable{o}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.PartialMap.find}{\coqdocdefinition{PartialMap.find}} \coqdocvariable{x} \coqdocvariable{d})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.PartialMap.update neq}{\coqdocaxiom{PartialMap.update\_neq}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.ListsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  baz\_num\_elts  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: baz\_num\_elts".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Lists.manual grade for baz num elts}{\coqdocdefinition{manual\_grade\_for\_baz\_num\_elts}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 21".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 33".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.snd\_fst\_is\_swap ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.snd fst is swap}{\coqdocaxiom{NatList.snd\_fst\_is\_swap}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.test\_nonzeros ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test nonzeros}{\coqdocaxiom{NatList.test\_nonzeros}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.test\_oddmembers ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test oddmembers}{\coqdocaxiom{NatList.test\_oddmembers}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.test\_countoddmembers2 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test countoddmembers2}{\coqdocaxiom{NatList.test\_countoddmembers2}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.test\_countoddmembers3 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test countoddmembers3}{\coqdocaxiom{NatList.test\_countoddmembers3}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.test\_count2 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test count2}{\coqdocaxiom{NatList.test\_count2}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.test\_sum1 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test sum1}{\coqdocaxiom{NatList.test\_sum1}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.test\_add1 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test add1}{\coqdocaxiom{NatList.test\_add1}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.test\_add2 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test add2}{\coqdocaxiom{NatList.test\_add2}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.test\_member1 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test member1}{\coqdocaxiom{NatList.test\_member1}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.test\_member2 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test member2}{\coqdocaxiom{NatList.test\_member2}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- bag\_theorem ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.app\_nil\_r ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.app nil r}{\coqdocaxiom{NatList.app\_nil\_r}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.rev\_app\_distr ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.rev app distr}{\coqdocaxiom{NatList.rev\_app\_distr}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.rev\_involutive ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.rev involutive}{\coqdocaxiom{NatList.rev\_involutive}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.app\_assoc4 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.app assoc4}{\coqdocaxiom{NatList.app\_assoc4}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.nonzeros\_app ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.nonzeros app}{\coqdocaxiom{NatList.nonzeros\_app}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.eqblist\_refl ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.eqblist refl}{\coqdocaxiom{NatList.eqblist\_refl}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.count\_member\_nonzero ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.count member nonzero}{\coqdocaxiom{NatList.count\_member\_nonzero}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.hd\_error ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.hd error}{\coqdocaxiom{NatList.hd\_error}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- eqb\_id\_refl ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.eqb id refl}{\coqdocaxiom{eqb\_id\_refl}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- PartialMap.update\_eq ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.PartialMap.update eq}{\coqdocaxiom{PartialMap.update\_eq}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- PartialMap.update\_neq ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.PartialMap.update neq}{\coqdocaxiom{PartialMap.update\_neq}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- baz\_num\_elts ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.test\_alternate1 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test alternate1}{\coqdocaxiom{NatList.test\_alternate1}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.test\_alternate2 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test alternate2}{\coqdocaxiom{NatList.test\_alternate2}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.test\_alternate4 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.test alternate4}{\coqdocaxiom{NatList.test\_alternate4}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- NatList.remove\_does\_not\_increase\_count ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Lists.NatList.remove does not increase count}{\coqdocaxiom{NatList.remove\_does\_not\_increase\_count}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- rev\_injective ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.InductionTest}{Library }{LF.InductionTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Induction}{\coqdoclibrary{Induction}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.InductionTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.InductionTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.InductionTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.InductionTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Induction}{\coqdoclibrary{Induction}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.InductionTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  basic\_induction  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> mult\_0\_r".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Induction.mult 0 r}{\coqdocaxiom{mult\_0\_r}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} 0 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0)).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Induction.mult 0 r}{\coqdocaxiom{mult\_0\_r}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.InductionTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> plus\_n\_Sm".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Induction.plus n Sm}{\coqdocaxiom{plus\_n\_Sm}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{m})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Induction.plus n Sm}{\coqdocaxiom{plus\_n\_Sm}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.InductionTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> plus\_comm".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Induction.plus comm}{\coqdocaxiom{plus\_comm}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Induction.plus comm}{\coqdocaxiom{plus\_comm}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.InductionTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> plus\_assoc".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Induction.plus assoc}{\coqdocaxiom{plus\_assoc}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Induction.plus assoc}{\coqdocaxiom{plus\_assoc}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.InductionTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  double\_plus  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> double\_plus".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Induction.double plus}{\coqdocaxiom{double\_plus}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Induction.double plus}{\coqdocaxiom{double\_plus}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.InductionTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  plus\_comm\_informal  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: plus\_comm\_informal".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Induction.manual grade for plus comm informal}{\coqdocdefinition{manual\_grade\_for\_plus\_comm\_informal}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  mult\_comm  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> mult\_comm".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Induction.mult comm}{\coqdocaxiom{mult\_comm}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{m} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{m})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Induction.mult comm}{\coqdocaxiom{mult\_comm}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.InductionTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  binary\_commute  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: binary\_commute".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 3".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Induction.manual grade for binary commute}{\coqdocdefinition{manual\_grade\_for\_binary\_commute}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  binary\_inverse  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: binary\_inverse\_a".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 4".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Induction.manual grade for binary inverse a}{\coqdocdefinition{manual\_grade\_for\_binary\_inverse\_a}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: binary\_inverse\_b".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Induction.manual grade for binary inverse b}{\coqdocdefinition{manual\_grade\_for\_binary\_inverse\_b}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: binary\_inverse\_c".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Advanced".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 4".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Induction.manual grade for binary inverse c}{\coqdocdefinition{manual\_grade\_for\_binary\_inverse\_c}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 10".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 22".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- mult\_0\_r ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Induction.mult 0 r}{\coqdocaxiom{mult\_0\_r}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- plus\_n\_Sm ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Induction.plus n Sm}{\coqdocaxiom{plus\_n\_Sm}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- plus\_comm ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Induction.plus comm}{\coqdocaxiom{plus\_comm}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- plus\_assoc ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Induction.plus assoc}{\coqdocaxiom{plus\_assoc}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- double\_plus ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Induction.double plus}{\coqdocaxiom{double\_plus}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- mult\_comm ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Induction.mult comm}{\coqdocaxiom{mult\_comm}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- binary\_commute ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- plus\_comm\_informal ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- binary\_inverse\_a ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- binary\_inverse\_b ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- binary\_inverse\_c ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.BasicsTest}{Library }{LF.BasicsTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Basics}{\coqdoclibrary{Basics}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.BasicsTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.BasicsTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.BasicsTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.BasicsTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Basics}{\coqdoclibrary{Basics}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BasicsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  nandb  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> test\_nandb4".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Basics.test nandb4}{\coqdocaxiom{test\_nandb4}} ((\coqref{LF.Basics.nandb}{\coqdocaxiom{nandb}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test nandb4}{\coqdocaxiom{test\_nandb4}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BasicsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  andb3  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> test\_andb34".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Basics.test andb34}{\coqdocaxiom{test\_andb34}} ((\coqref{LF.Basics.andb3}{\coqdocaxiom{andb3}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test andb34}{\coqdocaxiom{test\_andb34}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BasicsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  factorial  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> test\_factorial2".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Basics.test factorial2}{\coqdocaxiom{test\_factorial2}} ((\coqref{LF.Basics.factorial}{\coqdocaxiom{factorial}} 5 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 10 \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} 12)).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test factorial2}{\coqdocaxiom{test\_factorial2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BasicsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  ltb  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> test\_ltb3".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Basics.test ltb3}{\coqdocaxiom{test\_ltb3}} ((\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}4 \coqref{LF.Basics.::nat scope:x '<?' x}{\coqdocnotation{<?}} 2\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test ltb3}{\coqdocaxiom{test\_ltb3}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BasicsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  plus\_id\_exercise  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> plus\_id\_exercise".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Basics.plus id exercise}{\coqdocaxiom{plus\_id\_exercise}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{o} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{o})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.plus id exercise}{\coqdocaxiom{plus\_id\_exercise}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BasicsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  mult\_n\_1  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> mult\_n\_1".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Basics.mult n 1}{\coqdocaxiom{mult\_n\_1}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} 1 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.mult n 1}{\coqdocaxiom{mult\_n\_1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BasicsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  andb\_true\_elim2  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> andb\_true\_elim2".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 2".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Basics.andb true elim2}{\coqdocaxiom{andb\_true\_elim2}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}, \coqdocvariable{b} \coqref{LF.Basics.:::x 'x26x26' x}{\coqdocnotation{\&\&}} \coqdocvariable{c} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{c} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.andb true elim2}{\coqdocaxiom{andb\_true\_elim2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BasicsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  zero\_nbeq\_plus\_1  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> zero\_nbeq\_plus\_1".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Basics.zero nbeq plus 1}{\coqdocaxiom{zero\_nbeq\_plus\_1}} ((\coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}0 \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.zero nbeq plus 1}{\coqdocaxiom{zero\_nbeq\_plus\_1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BasicsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  identity\_fn\_applied\_twice  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> identity\_fn\_applied\_twice".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Basics.identity fn applied twice}{\coqdocaxiom{identity\_fn\_applied\_twice}} (\coqdoceol
\coqdocnoindent
(\coqdockw{\ensuremath{\forall}} \coqdocvar{f} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}},\coqdoceol
\coqdocindent{0.50em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}, \coqdocvariable{f} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{x}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{\ensuremath{\forall}} \coqdocvar{b} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}, \coqdocvariable{f} (\coqdocvariable{f} \coqdocvariable{b}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{b})).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.identity fn applied twice}{\coqdocaxiom{identity\_fn\_applied\_twice}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BasicsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  negation\_fn\_applied\_twice  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> Manually graded: negation\_fn\_applied\_twice".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 1".\coqdoceol
\coqdocnoindent
\coqdocvar{print\_manual\_grade} \coqref{LF.Basics.manual grade for negation fn applied twice}{\coqdocdefinition{manual\_grade\_for\_negation\_fn\_applied\_twice}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "-------------------  binary  --------------------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> test\_bin\_incr1".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Basics.test bin incr1}{\coqdocaxiom{test\_bin\_incr1}} ((\coqref{LF.Basics.incr}{\coqdocaxiom{incr}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.A}{\coqdocconstructor{A}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}}))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test bin incr1}{\coqdocaxiom{test\_bin\_incr1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BasicsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> test\_bin\_incr2".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Basics.test bin incr2}{\coqdocaxiom{test\_bin\_incr2}} ((\coqref{LF.Basics.incr}{\coqdocaxiom{incr}} (\coqref{LF.Basics.A}{\coqdocconstructor{A}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.B}{\coqdocconstructor{B}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}}))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test bin incr2}{\coqdocaxiom{test\_bin\_incr2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BasicsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> test\_bin\_incr3".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Basics.test bin incr3}{\coqdocaxiom{test\_bin\_incr3}} ((\coqref{LF.Basics.incr}{\coqdocaxiom{incr}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.A}{\coqdocconstructor{A}} (\coqref{LF.Basics.A}{\coqdocconstructor{A}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}})))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test bin incr3}{\coqdocaxiom{test\_bin\_incr3}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BasicsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> test\_bin\_incr4".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Basics.test bin incr4}{\coqdocaxiom{test\_bin\_incr4}} ((\coqref{LF.Basics.bin to nat}{\coqdocaxiom{bin\_to\_nat}} (\coqref{LF.Basics.A}{\coqdocconstructor{A}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 2)).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test bin incr4}{\coqdocaxiom{test\_bin\_incr4}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BasicsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> test\_bin\_incr5".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Basics.test bin incr5}{\coqdocaxiom{test\_bin\_incr5}} ((\coqref{LF.Basics.bin to nat}{\coqdocaxiom{bin\_to\_nat}} (\coqref{LF.Basics.incr}{\coqdocaxiom{incr}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 1 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqref{LF.Basics.bin to nat}{\coqdocaxiom{bin\_to\_nat}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}}))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test bin incr5}{\coqdocaxiom{test\_bin\_incr5}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BasicsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "\#> test\_bin\_incr6".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Possible points: 0.5".\coqdoceol
\coqdocnoindent
\coqdocvar{check\_type} @\coqref{LF.Basics.test bin incr6}{\coqdocaxiom{test\_bin\_incr6}} ((\coqref{LF.Basics.bin to nat}{\coqdocaxiom{bin\_to\_nat}} (\coqref{LF.Basics.incr}{\coqdocaxiom{incr}} (\coqref{LF.Basics.incr}{\coqdocaxiom{incr}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}}))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 2 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqref{LF.Basics.bin to nat}{\coqdocaxiom{bin\_to\_nat}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}}))).\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Assumptions:".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test bin incr6}{\coqdocaxiom{test\_bin\_incr6}}.\coqdoceol
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.BasicsTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 15".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 15".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- test\_nandb4 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test nandb4}{\coqdocaxiom{test\_nandb4}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- test\_andb34 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test andb34}{\coqdocaxiom{test\_andb34}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- test\_factorial2 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test factorial2}{\coqdocaxiom{test\_factorial2}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- test\_ltb3 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test ltb3}{\coqdocaxiom{test\_ltb3}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- plus\_id\_exercise ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.plus id exercise}{\coqdocaxiom{plus\_id\_exercise}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- mult\_n\_1 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.mult n 1}{\coqdocaxiom{mult\_n\_1}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- andb\_true\_elim2 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.andb true elim2}{\coqdocaxiom{andb\_true\_elim2}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- zero\_nbeq\_plus\_1 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.zero nbeq plus 1}{\coqdocaxiom{zero\_nbeq\_plus\_1}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- identity\_fn\_applied\_twice ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.identity fn applied twice}{\coqdocaxiom{identity\_fn\_applied\_twice}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- negation\_fn\_applied\_twice ---------".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "MANUAL".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- test\_bin\_incr1 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test bin incr1}{\coqdocaxiom{test\_bin\_incr1}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- test\_bin\_incr2 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test bin incr2}{\coqdocaxiom{test\_bin\_incr2}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- test\_bin\_incr3 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test bin incr3}{\coqdocaxiom{test\_bin\_incr3}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- test\_bin\_incr4 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test bin incr4}{\coqdocaxiom{test\_bin\_incr4}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- test\_bin\_incr5 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test bin incr5}{\coqdocaxiom{test\_bin\_incr5}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "---------- test\_bin\_incr6 ---------".\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Basics.test bin incr6}{\coqdocaxiom{test\_bin\_incr6}}.\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.PrefaceTest}{Library }{LF.PrefaceTest}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Preface}{\coqdoclibrary{Preface}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Parameter} \coqdef{LF.PrefaceTest.MISSING}{MISSING}{\coqdocaxiom{MISSING}}: \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.PrefaceTest.Check}{Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{check\_type} \coqdocvar{A} \coqdocvar{B} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdockw{type} \coqdockw{of} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdockw{context}[\coqref{LF.PrefaceTest.MISSING}{\coqdocaxiom{MISSING}}] \ensuremath{\Rightarrow} \coqdoctac{idtac} "Missing:" \coqdocvar{A}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} ?\coqdocvar{T} \ensuremath{\Rightarrow} \coqdoctac{first} [\coqdocvar{unify} \coqdocvar{T} \coqdocvar{B}; \coqdoctac{idtac} "Type: ok" \ensuremath{|} \coqdoctac{idtac} "Type: wrong - should be (" \coqdocvar{B} ")"]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{print\_manual\_grade} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{A} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{\_} ?\coqdocvar{S} ?\coqdocvar{C}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score:"  \coqdocvar{S};\coqdoceol
\coqdocindent{4.00em}
\coqdockw{match} \coqdoctac{eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{C} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} ""\%\coqdocvar{string} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{idtac} "Comment:" \coqdocvar{C}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Score: Ungraded";\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{idtac} "Comment: None"\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.PrefaceTest.Check}{\coqdocmodule{Check}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Preface}{\coqdoclibrary{Preface}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdockw{Check}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Goal} \coqdef{LF.PrefaceTest.Unnamed thm}{True}{\coqdocdefinition{True}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} " ".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdoctac{idtac} "Max points - standard: 0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Max points - advanced: 0".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Allowed Axioms:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "functional\_extensionality".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "FunctionalExtensionality.functional\_extensionality\_dep".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Summary **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "Below is a summary of the automatically graded exercises that are incomplete.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "The output for each exercise can be any of the following:".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'Closed under the global context', if it is complete".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - 'MANUAL', if it is manually graded".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "  - A list of pending axioms, containing unproven assumptions. In this case".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "    the exercise is considered complete, if the axioms are all allowed.".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Standard **********".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "".\coqdoceol
\coqdocnoindent
\coqdoctac{idtac} "********** Advanced **********".\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.Bib}{Library }{LF.Bib}

\begin{coqdoccode}
\end{coqdoccode}
\section{Bib: 参考文献}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{本卷中出现的引用}





\coqdocvar{Bertot} 2004 Interactive Theorem Proving and Program Development:
  Coq'Art: The Calculus of Inductive Constructions, by Yves Bertot and
  Pierre Casteran.  Springer-Verlag, 2004.
  https://tinyurl.com/z3o7nqu


\coqdocvar{Chlipala} 2013 Certified Programming with Dependent Types, by
  Adam Chlipala.  MIT Press.  2013.  https://tinyurl.com/zqdnyg2


\coqdocvar{Lipovaca} 2011 Learn You a Haskell for Great Good! A Beginner's
  Guide, by Miran Lipovaca, No Starch Press, April 2011.
  http://learnyouahaskell.com


\coqdocvar{O'Sullivan} 2008 Bryan O'Sullivan, John Goerzen, and Don Stewart:
  Real world Haskell - code you can believe in. O'Reilly
  2008. http://book.realworldhaskell.org


\coqdocvar{Pugh} 1991 Pugh, William. ``The Omega test: a fast and practical
  integer programming algorithm for dependence analysis.'' Proceedings
  of the 1991 ACM/IEEE conference on Supercomputing. ACM, 1991.
  https://dl.acm.org/citation.cfm?id=125848


\coqdocvar{Wadler} 2015 Philip Wadler. ``Propositions as types.''
  Communications of the ACM 58, no. 12 (2015): 75-84.
  https://dl.acm.org/citation.cfm?id=2699407


\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.Postscript}{Library }{LF.Postscript}

\begin{coqdoccode}
\end{coqdoccode}
\section{Postscript: 后记}



 恭喜，课程终于顺利结束了！ \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{回顾一下}



 到目前为止，我们已经学习了很多内容。我们来快速地回顾一下：



\begin{itemize}
\item  \textit{'函数式编程'}：

\begin{itemize}
\item  “声明式” 编程风格 (在不可变的数据构造上递归，而非在可变的数组或指针结构上循环）

\item  高阶函数

\item  多态 
\end{itemize}

\end{itemize}





\begin{itemize}
\item  \textit{'逻辑'}，软件工程的数学基础：


           逻辑                微积分

\begin{itemize}
\item --------   \~{}   ------------------
         软件工程          机械工程/土木工程



\begin{itemize}
\item  归纳定义的集合和关系

\item  归纳证明

\item  证明对象 
\end{itemize}

\end{itemize}

\end{itemize}





\begin{itemize}
\item  \textit{'Coq'}，一个强有力的证明辅助工具

\begin{itemize}
\item  函数式核心语言

\item  核心策略

\item  自动化

\end{itemize}

\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{继续前行}



 假如本书的内容引起了你的兴趣，你还可以阅读\textit{'软件基础'}系列的：



\begin{itemize}
\item  \textit{'编程语言基础'}（《软件基础》第二卷，与本书作者组类似）
             覆盖了了关于编程语言理论方面的研究生课程，包括霍尔逻辑
             （Hoare logic）、操作语义以及类型系统。



\item  \textit{'函数式算法验证'}（《软件基础》第三卷，Andrew Appel 著）
             在使用 Coq 进行程序验证和函数式编程的基础之上，
             讨论了一般数据结构课程中的一系列主题并着眼于其形式化验证。
\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{资源}



 进一步学习的资源……



\begin{itemize}
\item  本书包含了一些可选章节，其中讲述的内容或许会对你有用。你可以在
         目录 或
         章节依赖简图 中找到它们。



\item  有关 Coq 的问题，可以查看 Stack Overflow 上的 \#\coqdocvar{coq} 板块
         (https://stackoverflow.com/questions/tagged/coq)，
         它是个很棒的社区资源。



\item  更多与函数式编程相关的内容：

\begin{itemize}
\item  Learn You a Haskell for Great Good, by Miran Lipovaca
              \coqdocvar{Lipovaca} 2011 (in Bib.v).
              （《Haskell 趣学指南》https://learnyoua.haskell.sg/content/）

\item  Real World Haskell, by Bryan O'Sullivan, John Goerzen,
              and Don Stewart \coqdocvar{O'Sullivan} 2008 (in Bib.v).
              （《Real World Haskell 中文版》http://cnhaskell.com/）

\item  ……以及其它关于 Haskell、OCaml、 Scheme、Racket、Scala、F sharp
              等语言的优秀书籍。



\end{itemize}

\item  更多 Coq 相关的资源：

\begin{itemize}
\item  Certified Programming with Dependent Types, by Adam
             Chlipala \coqdocvar{Chlipala} 2013 (in Bib.v).

\item  Interactive Theorem Proving and Program Development:
             Coq'Art: The Calculus of Inductive Constructions, by Yves
             Bertot and Pierre Casteran \coqdocvar{Bertot} 2004 (in Bib.v).



\end{itemize}

\item  如果你有兴趣了解现实世界中形式化验证对关键软件的应用，
         可以参阅\textit{'《编程语言基础》'}的后记。



\item  关于使用 Coq 构建形式化验证的系统，可以参考 2017 年 DeepSpec
         夏令营的课程与相关资料。
         https://deepspec.org/event/dsss17/index.html

\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.AltAuto}{Library }{LF.AltAuto}

\begin{coqdoccode}
\end{coqdoccode}
\section{AltAuto: More Automation}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.omega.Omega}{\coqdoclibrary{omega.Omega}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.IndProp}{\coqdoclibrary{IndProp}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Up to now, we've used the more manual part of Coq's tactic
    facilities.  In this chapter, we'll learn more about some of Coq's
    powerful automation features.


    As a simple illustration of the benefits of automation, let's
    consider another problem on regular expressions, which we
    formalized in \coqdoclibrary{IndProp}.  A given set of strings can be
    denoted by many different regular expressions.  For example, \coqref{LF.IndProp.App}{\coqdocconstructor{App}}
    \coqexternalref{EmptyString}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocconstructor{EmptyString}} \coqdocvariable{re} matches exactly the same strings as \coqdocvariable{re}.  We can
    write a function that ``optimizes'' any regular expression into a
    potentially simpler one by applying this fact throughout the
    r.e.  (Note that, for simplicity, the function does not optimize
    expressions that arise as the result of other optimizations.) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.AltAuto.re opt e}{re\_opt\_e}{\coqdocdefinition{re\_opt\_e}} \{\coqdocvar{T}:\coqdockw{Type}\} (\coqdocvar{re}: \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{re} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.App}{\coqdocconstructor{App}} \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}} \coqdocvar{re2} \ensuremath{\Rightarrow} \coqref{LF.AltAuto.re opt e}{\coqdocdefinition{re\_opt\_e}} \coqdocvar{re2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.App}{\coqdocconstructor{App}} \coqdocvar{re1} \coqdocvar{re2} \ensuremath{\Rightarrow} \coqref{LF.IndProp.App}{\coqdocconstructor{App}} (\coqref{LF.AltAuto.re opt e}{\coqdocdefinition{re\_opt\_e}} \coqdocvar{re1}) (\coqref{LF.AltAuto.re opt e}{\coqdocdefinition{re\_opt\_e}} \coqdocvar{re2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} \coqdocvar{re1} \coqdocvar{re2} \ensuremath{\Rightarrow} \coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} (\coqref{LF.AltAuto.re opt e}{\coqdocdefinition{re\_opt\_e}} \coqdocvar{re1}) (\coqref{LF.AltAuto.re opt e}{\coqdocdefinition{re\_opt\_e}} \coqdocvar{re2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvar{re} \ensuremath{\Rightarrow} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} (\coqref{LF.AltAuto.re opt e}{\coqdocdefinition{re\_opt\_e}} \coqdocvariable{re})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdocvariable{re}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We would like to show the equivalence of re's with their ``optimized'' form.
One direction of this equivalence looks like this (the other is similar).
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.AltAuto.re opt e match}{re\_opt\_e\_match}{\coqdoclemma{re\_opt\_e\_match}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{re}: \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) \coqdocvar{s},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.AltAuto.re opt e}{\coqdocdefinition{re\_opt\_e}} \coqdocvariable{re}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{T} \coqdocvar{re} \coqdocvar{s} \coqdocvar{M}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{M}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{as} [| \coqdocvar{x'}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{s1} \coqdocvar{re1} \coqdocvar{s2} \coqdocvar{re2} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{s1} \coqdocvar{re1} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH} \ensuremath{|} \coqdocvar{re1} \coqdocvar{s2} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{re} \ensuremath{|} \coqdocvar{s1} \coqdocvar{s2} \coqdocvar{re} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2}].\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}. \coqdoctac{apply} \coqref{LF.IndProp.MEmpty}{\coqdocconstructor{MEmpty}}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}. \coqdoctac{apply} \coqref{LF.IndProp.MChar}{\coqdocconstructor{MChar}}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{re1}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{Hmatch1}. \coqdoctac{simpl}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}. \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}. \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}. \coqdoctac{apply} \coqref{LF.IndProp.MStar0}{\coqdocconstructor{MStar0}}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}. \coqdoctac{apply} \coqref{LF.IndProp.MStarApp}{\coqdocconstructor{MStarApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Coq Automation}



 The amount of repetition in this last proof is rather
    annoying.  And if we wanted to extend the optimization function to
    handle other, similar, rewriting opportunities,
    it would start to be a real problem.


    So far, we've been doing all our proofs using just a small handful
    of Coq's tactics and completely ignoring its powerful facilities
    for constructing parts of proofs automatically.  This section
    introduces some of these facilities, and we will see more over the
    next several chapters.  Getting used to them will take some
    energy -- Coq's automation is a power tool -- but it will allow us
    to scale up our efforts to more complex definitions and more
    interesting properties without becoming overwhelmed by boring,
    repetitive, low-level details. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Tacticals}



 \textit{Tacticals} is Coq's term for tactics that take other tactics as
    arguments -- ``higher-order tactics,'' if you will.  \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsubsection{The \texorpdfstring{\protect\coqdoctac{try}}{try} Tactical}



 If \coqdocvariable{T} is a tactic, then \coqdoctac{try} \coqdocvariable{T} is a tactic that is just like \coqdocvariable{T}
    except that, if \coqdocvariable{T} fails, \coqdoctac{try} \coqdocvariable{T} \textit{successfully} does nothing at
    all (instead of failing). \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.AltAuto.silly1}{silly1}{\coqdoclemma{silly1}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},  1 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{try} \coqdoctac{reflexivity}.  \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.AltAuto.silly2}{silly2}{\coqdoclemma{silly2}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{P} : \coqdockw{Prop}), \coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{HP}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{try} \coqdoctac{reflexivity}. \coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{HP}. \coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
There is no real reason to use \coqdoctac{try} in completely manual
    proofs like these, but it is very useful for doing automated
    proofs in conjunction with the ; tactical, which we show
    next. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsubsection{The ; Tactical (Simple Form)}



 In its most common form, the ; tactical takes two tactics as
    arguments.  The compound tactic \coqdocvariable{T};\coqdocvar{T'} first performs \coqdocvariable{T} and then
    performs \coqdocvar{T'} on \textit{each subgoal} generated by \coqdocvariable{T}. 

 For example, consider the following trivial lemma: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.AltAuto.foo}{foo}{\coqdoclemma{foo}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, 0 \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{n} \coqdocvar{eqn}:\coqdocvar{E}.\coqdoceol
\coqdocindent{2.00em}
-  \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
-  \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We can simplify this proof using the ; tactical: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.AltAuto.foo'}{foo'}{\coqdoclemma{foo'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, 0 \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{n};\coqdoceol
\coqdocindent{1.00em}
\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl};\coqdoceol
\coqdocindent{1.00em}
\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Using \coqdoctac{try} and ; together, we can get rid of the repetition in
    the proof that was bothering us a little while ago. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.AltAuto.re opt e match'}{re\_opt\_e\_match'}{\coqdoclemma{re\_opt\_e\_match'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{re}: \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) \coqdocvar{s},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.AltAuto.re opt e}{\coqdocdefinition{re\_opt\_e}} \coqdocvariable{re}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{T} \coqdocvar{re} \coqdocvar{s} \coqdocvar{M}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{M}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{as} [| \coqdocvar{x'}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{s1} \coqdocvar{re1} \coqdocvar{s2} \coqdocvar{re2} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{s1} \coqdocvar{re1} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH} \ensuremath{|} \coqdocvar{re1} \coqdocvar{s2} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{re} \ensuremath{|} \coqdocvar{s1} \coqdocvar{s2} \coqdocvar{re} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2}];\coqdoceol
\coqdocindent{2.00em}
\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{apply} \coqref{LF.IndProp.MEmpty}{\coqdocconstructor{MEmpty}}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{apply} \coqref{LF.IndProp.MChar}{\coqdocconstructor{MChar}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{re1};\coqdoceol
\coqdocindent{2.00em}
\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{try} (\coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}; \coqdoctac{try} \coqdoctac{apply} \coqdocvar{IH1}; \coqdoctac{apply} \coqdocvar{IH2}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{inversion} \coqdocvar{Hmatch1}. \coqdoctac{simpl}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{apply} \coqref{LF.IndProp.MStar0}{\coqdocconstructor{MStar0}}.\coqdoceol
\coqdocindent{1.00em}
-   \coqdoctac{apply} \coqref{LF.IndProp.MStarApp}{\coqdocconstructor{MStarApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{The ; Tactical (General Form)}



 The ; tactical also has a more general form than the simple
    \coqdocvariable{T};\coqdocvar{T'} we've seen above.  If \coqdocvariable{T}, \coqdocvar{T1}, ..., \coqdocvar{Tn} are tactics,
    then


      T; \coqdocvar{T1} \ensuremath{|} \coqdocvar{T2} \ensuremath{|} ... \ensuremath{|} \coqdocvar{Tn}


    is a tactic that first performs \coqdocvariable{T} and then performs \coqdocvar{T1} on the
    first subgoal generated by \coqdocvariable{T}, performs \coqdocvar{T2} on the second
    subgoal, etc.


    So \coqdocvariable{T};\coqdocvar{T'} is just special notation for the case when all of the
    \coqdocvar{Ti}'s are the same tactic; i.e., \coqdocvariable{T};\coqdocvar{T'} is shorthand for:


      T; \coqdocvar{T'} \ensuremath{|} \coqdocvar{T'} \ensuremath{|} ... \ensuremath{|} \coqdocvar{T'}


\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.AltAuto.re opt e match''}{re\_opt\_e\_match'{}'}{\coqdoclemma{re\_opt\_e\_match'{}'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{re}: \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) \coqdocvar{s},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.AltAuto.re opt e}{\coqdocdefinition{re\_opt\_e}} \coqdocvariable{re}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{T} \coqdocvar{re} \coqdocvar{s} \coqdocvar{M}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{M}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{as} [| \coqdocvar{x'}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{s1} \coqdocvar{re1} \coqdocvar{s2} \coqdocvar{re2} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{s1} \coqdocvar{re1} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH} \ensuremath{|} \coqdocvar{re1} \coqdocvar{s2} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{re} \ensuremath{|} \coqdocvar{s1} \coqdocvar{s2} \coqdocvar{re} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2}];\coqdoceol
\coqdocindent{2.00em}
\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{apply} \coqref{LF.IndProp.MEmpty}{\coqdocconstructor{MEmpty}}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{apply} \coqref{LF.IndProp.MChar}{\coqdocconstructor{MChar}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{re1};\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{try} (\coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}; [\coqdoctac{apply} \coqdocvar{IH1} \ensuremath{|} \coqdoctac{apply} \coqdocvar{IH2}]). \coqdocindent{2.00em}
\coqdoctac{inversion} \coqdocvar{Hmatch1}. \coqdoctac{simpl}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{apply} \coqref{LF.IndProp.MStar0}{\coqdocconstructor{MStar0}}.\coqdoceol
\coqdocindent{1.00em}
-   \coqdoctac{apply} \coqref{LF.IndProp.MStarApp}{\coqdocconstructor{MStarApp}}; [\coqdoctac{apply} \coqdocvar{IH1} \ensuremath{|}  \coqdoctac{apply} \coqdocvar{IH2}]. \coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{The \texorpdfstring{\protect\coqdoctac{repeat}}{repeat} Tactical}



 The \coqdoctac{repeat} tactical takes another tactic and keeps applying this
    tactic until it fails. Here is an example showing that 10 is in
    a long list using repeat. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.AltAuto.In10}{In10}{\coqdoclemma{In10}} : \coqref{LF.Logic.In}{\coqdocdefinition{In}} 10 \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}7\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}8\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}9\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}10\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} (\coqdoctac{try} (\coqdoctac{left}; \coqdoctac{reflexivity}); \coqdoctac{right}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The tactic \coqdoctac{repeat} \coqdocvariable{T} never fails: if the tactic \coqdocvariable{T} doesn't apply
    to the original goal, then repeat still succeeds without changing
    the original goal (i.e., it repeats zero times). \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.AltAuto.In10'}{In10'}{\coqdoclemma{In10'}} : \coqref{LF.Logic.In}{\coqdocdefinition{In}} 10 \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}7\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}8\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}9\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}10\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} (\coqdoctac{left}; \coqdoctac{reflexivity}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} (\coqdoctac{right}; \coqdoctac{try} (\coqdoctac{left}; \coqdoctac{reflexivity})).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The tactic \coqdoctac{repeat} \coqdocvariable{T} also does not have any upper bound on the
    number of times it applies \coqdocvariable{T}.  If \coqdocvariable{T} is a tactic that always
    succeeds, then repeat \coqdocvariable{T} will loop forever (e.g., \coqdoctac{repeat} \coqdoctac{simpl}
    loops, since \coqdoctac{simpl} always succeeds).  While evaluation in Coq's
    term language, Gallina, is guaranteed to terminate, tactic
    evaluation is not!  This does not affect Coq's logical
    consistency, however, since the job of \coqdoctac{repeat} and other tactics
    is to guide Coq in constructing proofs; if the construction
    process diverges, this simply means that we have failed to
    construct a proof, not that we have constructed a wrong one. 

\paragraph{练习：3 星, standard (re\_opt)}



 Consider this more powerful version of the regular expression optimizer. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.AltAuto.re opt}{re\_opt}{\coqdocdefinition{re\_opt}} \{\coqdocvar{T}:\coqdockw{Type}\} (\coqdocvar{re}: \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{re} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.App}{\coqdocconstructor{App}} \coqdocvar{re1} \coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}} \ensuremath{\Rightarrow} \coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.App}{\coqdocconstructor{App}} \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}} \coqdocvar{re2} \ensuremath{\Rightarrow} \coqref{LF.AltAuto.re opt}{\coqdocdefinition{re\_opt}} \coqdocvar{re2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.App}{\coqdocconstructor{App}} \coqdocvar{re1} \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}} \ensuremath{\Rightarrow} \coqref{LF.AltAuto.re opt}{\coqdocdefinition{re\_opt}} \coqdocvar{re1}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.App}{\coqdocconstructor{App}} \coqdocvar{re1} \coqdocvar{re2} \ensuremath{\Rightarrow} \coqref{LF.IndProp.App}{\coqdocconstructor{App}} (\coqref{LF.AltAuto.re opt}{\coqdocdefinition{re\_opt}} \coqdocvar{re1}) (\coqref{LF.AltAuto.re opt}{\coqdocdefinition{re\_opt}} \coqdocvar{re2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} \coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}} \coqdocvar{re2} \ensuremath{\Rightarrow} \coqref{LF.AltAuto.re opt}{\coqdocdefinition{re\_opt}} \coqdocvar{re2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} \coqdocvar{re1} \coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}} \ensuremath{\Rightarrow} \coqref{LF.AltAuto.re opt}{\coqdocdefinition{re\_opt}} \coqdocvar{re1}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} \coqdocvar{re1} \coqdocvar{re2} \ensuremath{\Rightarrow} \coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} (\coqref{LF.AltAuto.re opt}{\coqdocdefinition{re\_opt}} \coqdocvar{re1}) (\coqref{LF.AltAuto.re opt}{\coqdocdefinition{re\_opt}} \coqdocvar{re2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}} \ensuremath{\Rightarrow} \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}} \ensuremath{\Rightarrow} \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvar{re} \ensuremath{\Rightarrow} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} (\coqref{LF.AltAuto.re opt}{\coqdocdefinition{re\_opt}} \coqdocvariable{re})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}} \ensuremath{\Rightarrow} \coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}} \ensuremath{\Rightarrow} \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqdocvar{x} \ensuremath{\Rightarrow} \coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqdocvar{x}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.AltAuto.re opt match}{re\_opt\_match}{\coqdoclemma{re\_opt\_match}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{re}: \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) \coqdocvar{s},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.AltAuto.re opt}{\coqdocdefinition{re\_opt}} \coqdocvariable{re}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{T} \coqdocvar{re} \coqdocvar{s} \coqdocvar{M}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{M}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{as} [| \coqdocvar{x'}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{s1} \coqdocvar{re1} \coqdocvar{s2} \coqdocvar{re2} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{s1} \coqdocvar{re1} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH} \ensuremath{|} \coqdocvar{re1} \coqdocvar{s2} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{re} \ensuremath{|} \coqdocvar{s1} \coqdocvar{s2} \coqdocvar{re} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{apply} \coqref{LF.IndProp.MEmpty}{\coqdocconstructor{MEmpty}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{apply} \coqref{LF.IndProp.MChar}{\coqdocconstructor{MChar}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{re1}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{IH1}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{IH1}. \coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{re2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{re2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{IH2}. \coqdoctac{rewrite} \coqref{LF.Poly.app nil r}{\coqdocaxiom{app\_nil\_r}}. \coqdoctac{apply} \coqdocvar{IH1}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{re2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{IH2}. \coqdoctac{rewrite} \coqref{LF.Poly.app nil r}{\coqdocaxiom{app\_nil\_r}}. \coqdoctac{apply} \coqdocvar{IH1}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{re2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{IH2}. \coqdoctac{rewrite} \coqref{LF.Poly.app nil r}{\coqdocaxiom{app\_nil\_r}}. \coqdoctac{apply} \coqdocvar{IH1}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{re2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{IH2}. \coqdoctac{rewrite} \coqref{LF.Poly.app nil r}{\coqdocaxiom{app\_nil\_r}}. \coqdoctac{apply} \coqdocvar{IH1}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}. \coqdoctac{apply} \coqdocvar{IH1}. \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{re1}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{IH}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{re2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{re2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{re2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{re2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{re2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{re1}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{re2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{re2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{re2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{re2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{destruct} \coqdocvar{re2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{inversion} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocindent{0.50em}
- \coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{re}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{LF.IndProp.MEmpty}{\coqdocconstructor{MEmpty}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{LF.IndProp.MEmpty}{\coqdocconstructor{MEmpty}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{LF.IndProp.MStar0}{\coqdocconstructor{MStar0}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{LF.IndProp.MStar0}{\coqdocconstructor{MStar0}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{LF.IndProp.MStar0}{\coqdocconstructor{MStar0}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} \coqdocvar{re}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MStar0}{\coqdocconstructor{MStar0}}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MStar0}{\coqdocconstructor{MStar0}}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MStar0}{\coqdocconstructor{MStar0}}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MStar0}{\coqdocconstructor{MStar0}}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MStar0}{\coqdocconstructor{MStar0}}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MStar0}{\coqdocconstructor{MStar0}}.\coqdoceol
\coqdocindent{0.50em}
- \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{destruct} \coqdocvar{re}.\coqdoceol
\coqdocindent{1.50em}
+ \coqdoctac{inversion} \coqdocvar{IH1}.\coqdoceol
\coqdocindent{1.50em}
+ \coqdoctac{inversion} \coqdocvar{IH1}. \coqdoctac{inversion} \coqdocvar{IH2}. \coqdoctac{apply} \coqref{LF.IndProp.MEmpty}{\coqdocconstructor{MEmpty}}.\coqdoceol
\coqdocindent{1.50em}
+ \coqdoctac{apply} \coqref{LF.IndProp.star app}{\coqdoclemma{star\_app}}.\coqdoceol
\coqdocindent{2.50em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MStar1}{\coqdoclemma{MStar1}}. \coqdoctac{apply} \coqdocvar{IH1}.\coqdoceol
\coqdocindent{2.50em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{1.50em}
+ \coqdoctac{apply} \coqref{LF.IndProp.star app}{\coqdoclemma{star\_app}}.\coqdoceol
\coqdocindent{2.50em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MStar1}{\coqdoclemma{MStar1}}. \coqdoctac{apply} \coqdocvar{IH1}.\coqdoceol
\coqdocindent{2.50em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{1.50em}
+ \coqdoctac{apply} \coqref{LF.IndProp.star app}{\coqdoclemma{star\_app}}.\coqdoceol
\coqdocindent{2.50em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MStar1}{\coqdoclemma{MStar1}}. \coqdoctac{apply} \coqdocvar{IH1}.\coqdoceol
\coqdocindent{2.50em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{1.50em}
+ \coqdoctac{apply} \coqref{LF.IndProp.star app}{\coqdoclemma{star\_app}}.\coqdoceol
\coqdocindent{2.50em}
\ensuremath{\times} \coqdoctac{apply} \coqref{LF.IndProp.MStar1}{\coqdoclemma{MStar1}}. \coqdoctac{apply} \coqdocvar{IH1}.\coqdoceol
\coqdocindent{2.50em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.AltAuto.re opt match'}{re\_opt\_match'}{\coqdoclemma{re\_opt\_match'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{re}: \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) \coqdocvar{s},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.AltAuto.re opt}{\coqdocdefinition{re\_opt}} \coqdocvariable{re}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.AltAuto.manual grade for re opt}{manual\_grade\_for\_re\_opt}{\coqdocdefinition{manual\_grade\_for\_re\_opt}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqref{LF.IndProp.string}{\coqdocdefinition{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{A Few More Handy Tactics}



 By the way, here are some miscellaneous tactics that you may find
    convenient as we continue.



\begin{itemize}
\item  \coqdoctac{clear} \coqdocvariable{H}: Delete hypothesis \coqdocvariable{H} from the context.



\item  \coqdoctac{rename}... \coqdocvar{into}...: Change the name of a hypothesis in the
       proof context.  For example, if the context includes a variable
       named \coqdocvariable{x}, then \coqdoctac{rename} \coqdocvariable{x} \coqdocvar{into} \coqdocvariable{y} will change all occurrences
       of \coqdocvariable{x} to \coqdocvariable{y}.



\item  \coqdoctac{subst} \coqdocvariable{x}: Find an assumption \coqdocvariable{x} = \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} or \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} = \coqdocvariable{x} in the
       context, replace \coqdocvariable{x} with \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} throughout the context and
       current goal, and clear the assumption.



\item  \coqdoctac{subst}: Substitute away \textit{all} assumptions of the form \coqdocvariable{x} = \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}}
       or \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} = \coqdocvariable{x}.

\end{itemize}




    We'll see examples as we go along. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Defining New Tactics}



 Coq also provides several ways of ``programming'' tactic
scripts.



\begin{itemize}
\item  Coq has a built-in language called \coqdockw{Ltac} with primitives that
      can examine and modify the proof state.  The full details are a
      bit too complicated to get into here (and it is generally agreed
      that \coqdockw{Ltac} is not the most beautiful part of Coq's design!),
      but they can be found in the reference manual and other books on
      Coq. Simple use cases are not too difficult.



\item  There is also an OCaml API, which can be used to build tactics
      that access Coq's internal structures at a lower level, but this
      is seldom worth the trouble for ordinary Coq users.

\end{itemize}


    Here is a simple \coqdockw{Ltac} example: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{impl\_and\_try} \coqdocvar{c} := \coqdoctac{simpl}; \coqdoctac{try} \coqdocvar{c}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This defines a new tactical called \coqdocvar{simpl\_and\_try} that takes one
    tactic \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} as an argument and is defined to be equivalent to the
    tactic \coqdoctac{simpl}; \coqdoctac{try} \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}}.  Now writing ``\coqdocvar{simpl\_and\_try} \coqdoctac{reflexivity}.''
    in a proof will be the same as writing ``\coqdoctac{simpl}; \coqdoctac{try}
    \coqdoctac{reflexivity}.'' \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Decision Procedures}



 So far, the automation we have considered has primarily been
    useful for removing repetition. Another important category of
    automation consists of built-in decision procedures for specific
    kinds of problems.  There are several of these, but the \coqdoctac{omega}
    tactic is the most important to start with. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{The Omega Tactic}



 The \coqdoctac{omega} tactic implements a decision procedure for a subset of
    first-order logic called \textit{Presburger arithmetic}.  It is based on
    the Omega algorithm invented by William Pugh \coqdocvar{Pugh} 1991 (in Bib.v).


    If the goal is a universally quantified formula made out of



\begin{itemize}
\item  numeric constants, addition (+ and \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}}), subtraction (-
        and \coqref{LF.Basics.NatPlayground.pred}{\coqdocdefinition{pred}}), and multiplication by constants (this is what
        makes it Presburger arithmetic),



\item  equality (= and \ensuremath{\not=}) and ordering (\ensuremath{\le}), and



\item  the logical connectives \ensuremath{\land}, \ensuremath{\lor}, \ensuremath{\lnot}, and \ensuremath{\rightarrow},

\end{itemize}


    then invoking \coqdoctac{omega} will either solve the goal or fail, meaning
    that the goal is actually false.  (If the goal is \textit{not} of this
    form, \coqdoctac{omega} will also fail.) 

 Note that we needed the import \coqdockw{Require} \coqdockw{Import} \coqdoclibrary{Omega} at the top of this file. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.AltAuto.silly presburger example}{silly\_presburger\_example}{\coqdocdefinition{silly\_presburger\_example}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{o} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{o} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 3 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{p} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 3 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{m} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{omega}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Search Tactics}



 Another very important category of automation tactics
    helps us construct proofs by \textit{searching} for relevant facts
    These tactics include the \coqdoctac{auto} tactic for backwards reasoning,
    automated forward reasoning via the \coqdockw{Ltac} hypothesis matching
    machinery, and deferred instantiation of existential variables
    using \coqdoctac{eapply} and \coqdoctac{eauto}.  Using these features together with
    Ltac's scripting facilities will enable us to make our proofs
    startlingly short!  Used properly, they can also make proofs more
    maintainable and robust to changes in underlying definitions.  A
    deeper treatment of \coqdoctac{auto} and \coqdoctac{eauto} can be found in the
    \coqdocvar{UseAuto} chapter in \textit{Programming Language Foundations}. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{The \texorpdfstring{\protect\coqdoctac{constructor}}{constructor} tactic.}



 A simple first example of a search tactic is \coqdoctac{constructor},
    which tries to find a constructor \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} (from some
    \coqdockw{Inductive} definition in the current environment) that can be
    applied to solve the current goal.  If one is found, behave
    like \coqdoctac{apply} \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.AltAuto.constructor example}{constructor\_example}{\coqdocdefinition{constructor\_example}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqdocvariable{n}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}}\coqdocvariable{n}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{n}; \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{constructor}. \coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqref{LF.Induction.plus comm}{\coqdocaxiom{plus\_comm}}. \coqdoctac{simpl}. \coqdoctac{constructor}.  \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This saves us from needing to remember the names of our constructors.
    Warning: if more than one constructor can apply, \coqdoctac{constructor} picks
    the first one (in the order in which they were defined in the \coqdockw{Inductive})
    which is not necessarily the one we want! \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{The \texorpdfstring{\protect\coqdoctac{auto}}{auto} Tactic}



 Thus far, our proof scripts mostly apply relevant hypotheses or
    lemmas by name, and one at a time. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.AltAuto.auto example 1}{auto\_example\_1}{\coqdocdefinition{auto\_example\_1}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{P} \coqdocvar{Q} \coqdocvar{R}: \coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} \coqdocvar{H1} \coqdocvar{H2} \coqdocvar{H3}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H2}. \coqdoctac{apply} \coqdocvar{H1}. \coqdoctac{assumption}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqdoctac{auto} tactic frees us from this drudgery by \textit{searching} for a
    sequence of applications that will prove the goal: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.AltAuto.auto example 1'}{auto\_example\_1'}{\coqdocdefinition{auto\_example\_1'}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{P} \coqdocvar{Q} \coqdocvar{R}: \coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqdoctac{auto} tactic solves goals that are solvable by any combination of

\begin{itemize}
\item  \coqdoctac{intros} and

\item  \coqdoctac{apply} (of hypotheses from the local context, by default). 
\end{itemize}


 Using \coqdoctac{auto} is always ``safe'' in the sense that it will never fail
    and will never change the proof state: either it completely solves
    the current goal, or it does nothing. 

 Here is a more interesting example showing \coqdoctac{auto}'s power: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.AltAuto.auto example 2}{auto\_example\_2}{\coqdocdefinition{auto\_example\_2}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} \coqdocvar{S} \coqdocvar{T} \coqdocvar{U} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{S} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{U}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{((}}\coqdocvariable{P}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdocvariable{S}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{))}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{U}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{auto}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Proof search could, in principle, take an arbitrarily long time,
    so there are limits to how far \coqdoctac{auto} will search by default. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.AltAuto.auto example 3}{auto\_example\_3}{\coqdocdefinition{auto\_example\_3}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} \coqdocvar{S} \coqdocvar{T} \coqdocvar{U}: \coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{R} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{S}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{S} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{T}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{U}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{U}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto} 6.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
When searching for potential proofs of the current goal,
    \coqdoctac{auto} considers the hypotheses in the current context together
    with a \textit{hint database} of other lemmas and constructors.  Some
    common lemmas about equality and logical operators are installed
    in this hint database by default. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.AltAuto.auto example 4}{auto\_example\_4}{\coqdocdefinition{auto\_example\_4}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Q} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{R}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{auto}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
If we want to see which facts \coqdoctac{auto} is using, we can use
    \coqdoctac{info\_auto} instead. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.AltAuto.auto example 5}{auto\_example\_5}{\coqdocdefinition{auto\_example\_5}}: 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 2.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{info\_auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We can extend the hint database just for the purposes of one
    application of \coqdoctac{auto} by writing ``\coqdoctac{auto} \coqdockw{using} ...''. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.AltAuto.le antisym}{le\_antisym}{\coqdoclemma{le\_antisym}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m}: \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{m} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{n}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{intros}. \coqdoctac{omega}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.AltAuto.auto example 6}{auto\_example\_6}{\coqdocdefinition{auto\_example\_6}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{m} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{n}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{))}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto} \coqdockw{using} \coqref{LF.AltAuto.le antisym}{\coqdoclemma{le\_antisym}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Of course, in any given development there will probably be
    some specific constructors and lemmas that are used very often in
    proofs.  We can add these to the global hint database by writing


      Hint Resolve T.


    at the top level, where \coqdocvariable{T} is a top-level theorem or a
    constructor of an inductively defined proposition (i.e., anything
    whose type is an implication).  As a shorthand, we can write


      Hint Constructors c.


    to tell Coq to do a \coqdockw{Hint} \coqdockw{Resolve} for \textit{all} of the constructors
    from the inductive definition of \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}}.


    It is also sometimes necessary to add


      Hint Unfold d.


    where \coqref{LF.Poly.MumbleGrumble.d}{\coqdocconstructor{d}} is a defined symbol, so that \coqdoctac{auto} knows to expand uses
    of \coqref{LF.Poly.MumbleGrumble.d}{\coqdocconstructor{d}}, thus enabling further possibilities for applying lemmas that
    it knows about. 

 It is also possible to define specialized hint databases that can
    be activated only when needed.  See the Coq reference manual for
    more. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{le\_antisym}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.AltAuto.auto example 6'}{auto\_example\_6'}{\coqdocdefinition{auto\_example\_6'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n}\coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{m} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{n}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{))}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}. \coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.AltAuto.is fortytwo}{is\_fortytwo}{\coqdocdefinition{is\_fortytwo}} \coqdocvar{x} := (\coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 42).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.AltAuto.auto example 7}{auto\_example\_7}{\coqdocdefinition{auto\_example\_7}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} 42 \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} 42 \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{x}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.AltAuto.is fortytwo}{\coqdocdefinition{is\_fortytwo}} \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}. \coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Unfold} \coqref{LF.AltAuto.is fortytwo}{\coqdocdefinition{is\_fortytwo}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.AltAuto.auto example 7'}{auto\_example\_7'}{\coqdocdefinition{auto\_example\_7'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} 42 \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} 42 \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{x}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.AltAuto.is fortytwo}{\coqdocdefinition{is\_fortytwo}} \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{info\_auto}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：3 星, advanced (pumping\_redux)}




    Use \coqdoctac{auto}, \coqdoctac{omega}, and any other useful tactics from this chapter to
    shorten your proof (or the ``official'' solution proof) of the weak Pumping
    Lemma exercise from \coqdoclibrary{IndProp}. \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Import} \coqdocvar{Pumping}.\coqdoceol
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.AltAuto.weak pumping}{weak\_pumping}{\coqdoclemma{weak\_pumping}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.Pumping.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvariable{re} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{s1} \coqdocvar{s2} \coqdocvar{s3}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{s1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s2} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s3} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s2} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqdocvariable{s1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.IndProp.Pumping.napp}{\coqdocdefinition{napp}} \coqdocvariable{m} \coqdocvariable{s2} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s3} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.AltAuto.manual grade for pumping redux}{manual\_grade\_for\_pumping\_redux}{\coqdocdefinition{manual\_grade\_for\_pumping\_redux}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqref{LF.IndProp.string}{\coqdocdefinition{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, advanced, optional (pumping\_redux\_strong)}




    Use \coqdoctac{auto}, \coqdoctac{omega}, and any other useful tactics from this chapter to
    shorten your proof (or the ``official'' solution proof) of the stronger
    Pumping Lemma exercise from \coqdoclibrary{IndProp}. \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Import} \coqdocvar{Pumping}.\coqdoceol
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.AltAuto.pumping}{pumping}{\coqdoclemma{pumping}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.Pumping.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvariable{re} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{s1} \coqdocvar{s2} \coqdocvar{s3}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{s1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s2} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s3} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s2} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{s1} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{s2} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqref{LF.IndProp.Pumping.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvariable{re} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqdocvariable{s1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.IndProp.Pumping.napp}{\coqdocdefinition{napp}} \coqdocvariable{m} \coqdocvariable{s2} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s3} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.AltAuto.manual grade for pumping redux strong}{manual\_grade\_for\_pumping\_redux\_strong}{\coqdocdefinition{manual\_grade\_for\_pumping\_redux\_strong}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqref{LF.IndProp.string}{\coqdocdefinition{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{The \texorpdfstring{\protect\coqdoctac{eapply}}{eapply} and \texorpdfstring{\protect\coqdoctac{eauto}}{eauto} variants}



 To close the chapter, we'll introduce one more convenient feature
    of Coq: its ability to delay instantiation of quantifiers. To motivate
    this feature, consider again this simple example: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.AltAuto.trans example1}{trans\_example1}{\coqdocdefinition{trans\_example1}}:  \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{a} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{b} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{b}\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}}\coqdocvariable{c}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}1\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}}\coqdocvariable{c}\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)*}}\coqdocvariable{b} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{d} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{a} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{d}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d} \coqdocvar{H1} \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.IndProp.le trans}{\coqdocaxiom{le\_trans}} \coqdockw{with} (\coqdocvar{b}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvar{b}\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}}\coqdocvar{c}). \coqdocindent{1.00em}
+ \coqdoctac{apply} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
+ \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{rewrite} \coqref{LF.Induction.mult comm}{\coqdocaxiom{mult\_comm}}. \coqdoctac{apply} \coqdocvar{H2}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In the first step of the proof, we had to explicitly provide a
    longish expression to help Coq instantiate a ``hidden'' argument to
    the \coqref{LF.IndProp.le trans}{\coqdoclemma{le\_trans}} constructor. This was needed because the definition
    of \coqref{LF.IndProp.le trans}{\coqdoclemma{le\_trans}}...


    le\_trans : forall m n o : nat, m <= n -> n <= o -> m <= o


   is quantified over a variable, \coqdocvariable{n}, that does not appear in its
   conclusion, so unifying its conclusion with the goal state doesn't
   help Coq find a suitable value for this variable.  If we leave
   out the \coqdockw{with}, this step fails (``Error: Unable to find an
   instance for the variable \coqdocvariable{n}'').


   We already know one way to avoid an explicit \coqdockw{with} clause, namely
   to provide \coqdocvar{H1} as the (first) explicit argument to \coqref{LF.IndProp.le trans}{\coqdoclemma{le\_trans}}.
   But here's another way, using the \coqdoctac{eapply} \coqdocvar{tactic}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.AltAuto.trans example1'}{trans\_example1'}{\coqdocdefinition{trans\_example1'}}:  \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{a} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{b} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{b}\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}}\coqdocvariable{c}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}1\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}}\coqdocvariable{c}\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)*}}\coqdocvariable{b} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{d} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{a} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{d}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d} \coqdocvar{H1} \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{eapply} \coqref{LF.IndProp.le trans}{\coqdocaxiom{le\_trans}}. \coqdocindent{1.00em}
+ \coqdoctac{apply} \coqdocvar{H1}. \coqdocindent{1.00em}
+ \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{rewrite} \coqref{LF.Induction.mult comm}{\coqdocaxiom{mult\_comm}}. \coqdoctac{apply} \coqdocvar{H2}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqdoctac{eapply} \coqdocvariable{H} tactic behaves just like \coqdoctac{apply} \coqdocvariable{H} except
    that, after it finishes unifying the goal state with the
    conclusion of \coqdocvariable{H}, it does not bother to check whether all the
    variables that were introduced in the process have been given
    concrete values during unification.


    If you step through the proof above, you'll see that the goal
    state at position 1 mentions the \textit{existential variable} ?\coqdocvariable{n}
    in both of the generated subgoals.  The next step (which gets us
    to position 2) replaces ?\coqdocvariable{n} with a concrete value.  When we
    start working on the second subgoal (position 3), we observe
    that the occurrence of ?\coqdocvariable{n} in this subgoal has been replaced
    by the value that it was given during the first subgoal. 

 Several of the tactics that we've seen so far, including \coqdoctac{\ensuremath{\exists}},
    \coqdoctac{constructor}, and \coqdoctac{auto}, have \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}}... variants.  For example,
    here's a proof using \coqdoctac{eauto}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.AltAuto.trans example2}{trans\_example2}{\coqdocdefinition{trans\_example2}}:  \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{a} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{b} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{b}\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}}\coqdocvariable{c}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{b} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{b}\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}}\coqdocvariable{c} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{d} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{a} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{d}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d} \coqdocvar{H1} \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{info\_eauto} \coqdockw{using} \coqref{LF.IndProp.le trans}{\coqdocaxiom{le\_trans}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqdoctac{eauto} tactic works just like \coqdoctac{auto}, except that it uses
    \coqdoctac{eapply} instead of \coqdoctac{apply}.


    Pro tip: One might think that, since \coqdoctac{eapply} and \coqdoctac{eauto} are more
    powerful than \coqdoctac{apply} and \coqdoctac{auto}, it would be a good idea to use
    them all the time.  Unfortunately, they are also significantly
    slower -- especially \coqdoctac{eauto}.  Coq experts tend to use \coqdoctac{apply} and
    \coqdoctac{auto} most of the time, only switching to the \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} variants when
    the ordinary variants don't do the job. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.Auto}{Library }{LF.Auto}

\begin{coqdoccode}
\end{coqdoccode}
\section{Auto: 更多的自动化}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.omega.Omega}{\coqdoclibrary{omega.Omega}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Maps}{\coqdoclibrary{Maps}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Imp}{\coqdoclibrary{Imp}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
到目前为止，我们大多使用的都是 Coq 策略系统中手动的部分。
    在本章中，我们会学习更多 Coq 强大的自动化特性：通过 \coqdoctac{auto}
    策略进行证明搜索，通过 \coqdockw{Ltac} 前提搜索器进行自动正向推理，以及通过
    \coqdoctac{eapply} 和 \coqdoctac{eauto} 推迟存在性变量的实例化。这些特性配合 Ltac
    的脚本功能可以极大地缩短证明！如果使用得当，它们还会提高证明的可维护性，
    在以后修改证明的底层定义时也会更加健壮。对 \coqdoctac{auto} 和 \coqdoctac{eauto}
    更加深入的探讨可参阅\textit{'《编程语言基础》'}的 \coqdocvar{UseAuto} 一章。


    还有另一大类自动化方式我们所言不多，即内建的对特定种类问题的决策算法：
    \coqdoctac{omega} 就是这样的例子，不过还有其它的。这一主题我们会以后再谈。


    我们从以下证明开始，加上一些 \coqdoclibrary{Imp} 中的小改动。
    我们将分几个阶段来简化此证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Auto.ceval deterministic}{ceval\_deterministic}{\coqdoclemma{ceval\_deterministic}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st1}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{st2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2} \coqdocvar{E1} \coqdocvar{E2};\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{st2};\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{E1}; \coqdoctac{intros} \coqdocvar{st2} \coqdocvar{E2}; \coqdoctac{inversion} \coqdocvar{E2}; \coqdoctac{subst}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{st'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{st'0}) \coqdockw{as} \coqdocvar{EQ1}.\coqdoceol
\coqdocindent{2.00em}
\{  \coqdoctac{apply} \coqdocvar{IHE1\_1}; \coqdoctac{apply} \coqdocvar{H1}. \}\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{subst} \coqdocvar{st'0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{IHE1\_2}. \coqdoctac{assumption}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{IHE1}. \coqdoctac{assumption}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H5}. \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H5}. \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{IHE1}. \coqdoctac{assumption}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H4}. \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{st'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{st'0}) \coqdockw{as} \coqdocvar{EQ1}.\coqdoceol
\coqdocindent{2.00em}
\{  \coqdoctac{apply} \coqdocvar{IHE1\_1}; \coqdoctac{assumption}. \}\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{subst} \coqdocvar{st'0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{IHE1\_2}. \coqdoctac{assumption}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{\texorpdfstring{\protect\coqdoctac{auto}}{auto} 策略}



 迄今为止，我们的证明脚本大多是按名称来应用相关的前提或引理的，一次一个。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Auto.auto example 1}{auto\_example\_1}{\coqdocdefinition{auto\_example\_1}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{P} \coqdocvar{Q} \coqdocvar{R}: \coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} \coqdocvar{H1} \coqdocvar{H2} \coqdocvar{H3}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H2}. \coqdoctac{apply} \coqdocvar{H1}. \coqdoctac{assumption}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdoctac{auto} 策略可以\textit{'搜索'}一系列能够证明待证目标的应用来免除这些苦役：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Auto.auto example 1'}{auto\_example\_1'}{\coqdocdefinition{auto\_example\_1'}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{P} \coqdocvar{Q} \coqdocvar{R}: \coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
任何能够被以下策略的组合解决的待证目标，都能用 \coqdoctac{auto} 来解决：

\begin{itemize}
\item  \coqdoctac{intros}

\item  \coqdoctac{apply}（默认使用局部上下文中的前提）。 
\end{itemize}


 使用 \coqdoctac{auto} 一定是“安全”的，它不会失败，也不会改变当前证明的状态：
    \coqdoctac{auto} 要么完全解决它，要么什么也不做。 

 下面是个更大的例子，它展示了 \coqdoctac{auto} 的强大： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Auto.auto example 2}{auto\_example\_2}{\coqdocdefinition{auto\_example\_2}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} \coqdocvar{S} \coqdocvar{T} \coqdocvar{U} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{S} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{U}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{((}}\coqdocvariable{P}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdocvariable{S}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{))}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{U}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{auto}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
理论上来说，搜索可能需要任意长的时间，此时可通过参数来控制
    \coqdoctac{auto} 默认的搜索深度。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Auto.auto example 3}{auto\_example\_3}{\coqdocdefinition{auto\_example\_3}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} \coqdocvar{S} \coqdocvar{T} \coqdocvar{U}: \coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{R} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{S}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{S} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{T}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{U}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{U}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto} 6.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在搜索当前目标的潜在证明时， \coqdoctac{auto} 会同时考虑当前上下文中的前提，
    以及一个包含其它引理或构造子的\textit{'提示数据库'}。
    某些关于相等关系和逻辑运算符的事实默认已经安装到提示数据库中了。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Auto.auto example 4}{auto\_example\_4}{\coqdocdefinition{auto\_example\_4}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Q} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{R}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{auto}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
如果我们想看 \coqdoctac{auto} 用到了什么，可以使用 \coqdoctac{info\_auto} 。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Auto.auto example 5}{auto\_example\_5}{\coqdocdefinition{auto\_example\_5}}: 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 2.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{info\_auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们可以为某次 \coqdoctac{auto} 的调用扩展提示数据库，只需使用“\coqdoctac{auto} \coqdockw{using} ...”。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Auto.le antisym}{le\_antisym}{\coqdoclemma{le\_antisym}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m}: \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{m} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{n}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{intros}. \coqdoctac{omega}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Auto.auto example 6}{auto\_example\_6}{\coqdocdefinition{auto\_example\_6}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{m} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{n}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{))}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto} \coqdockw{using} \coqref{LF.Auto.le antisym}{\coqdoclemma{le\_antisym}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
当然, 在证明过程中经常会用到一些特定的构造子和引理，
    我们可以将它们加入全局提示数据库中，方法是在顶层使用：


      Hint Resolve T.


    其中 \coqdocvariable{T} 是某个顶层的定理，或者是某个归纳定义的命题
    （即所有类型都是一个蕴含式）的构造子。我们也可以使用简写


      Hint Constructors c.


    来告诉 Coq 对归纳定义 \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 的\textit{'所有'}构造子都执行 \coqdockw{Hint} \coqdockw{Resolve}。


    有时我们还需要


      Hint Unfold d.


    其中 \coqref{LF.Poly.MumbleGrumble.d}{\coqdocconstructor{d}} 是个已定义的符号，这样 \coqdoctac{auto} 就知道要展开使用 \coqref{LF.Poly.MumbleGrumble.d}{\coqdocconstructor{d}}，
    以此来获得更多使用已知的引理的机会。 

 我们也可以定义特殊化的提示数据库，让它只在需要时激活。详情见 Coq 参考手册。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Resolve} \coqdocvar{le\_antisym}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Auto.auto example 6'}{auto\_example\_6'}{\coqdocdefinition{auto\_example\_6'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n}\coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{m} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{n}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{))}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}. \coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Auto.is fortytwo}{is\_fortytwo}{\coqdocdefinition{is\_fortytwo}} \coqdocvar{x} := (\coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 42).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Auto.auto example 7}{auto\_example\_7}{\coqdocdefinition{auto\_example\_7}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} 42 \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} 42 \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{x}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Auto.is fortytwo}{\coqdocdefinition{is\_fortytwo}} \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}. \coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Unfold} \coqref{LF.Auto.is fortytwo}{\coqdocdefinition{is\_fortytwo}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Auto.auto example 7'}{auto\_example\_7'}{\coqdocdefinition{auto\_example\_7'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} 42 \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} 42 \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{x}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Auto.is fortytwo}{\coqdocdefinition{is\_fortytwo}} \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}. \coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们来初次尝试简化 \coqref{LF.Imp.BreakImp.ceval deterministic}{\coqdoclemma{ceval\_deterministic}} 的证明脚本。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Auto.ceval deterministic'}{ceval\_deterministic'}{\coqdoclemma{ceval\_deterministic'}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st1}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{st2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2} \coqdocvar{E1} \coqdocvar{E2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{st2};\coqdoceol
\coqdocindent{3.50em}
\coqdoctac{induction} \coqdocvar{E1}; \coqdoctac{intros} \coqdocvar{st2} \coqdocvar{E2}; \coqdoctac{inversion} \coqdocvar{E2}; \coqdoctac{subst}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{st'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{st'0}) \coqdockw{as} \coqdocvar{EQ1} \coqdoctac{by} \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{subst} \coqdocvar{st'0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H5}. \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H5}. \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H4}. \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{st'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{st'0}) \coqdockw{as} \coqdocvar{EQ1} \coqdoctac{by} \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{subst} \coqdocvar{st'0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
如果在证明中我们会反复用到某个策略，呢么可以使用一个 \coqdockw{Proof}
    指令的变体将它作为证明中的默认策略。例如 \coqdockw{Proof} \coqdockw{with} \coqdocvariable{t}（其中 \coqdocvariable{t}
    为任意一个策略）能够让我们在证明中将 \coqdocvar{t1}... 用作 \coqdocvar{t1};\coqdocvariable{t} 的简写。
    作为示范，下面是以上证明的另一个版本，它用到了 \coqdockw{Proof} \coqdockw{with} \coqdoctac{auto}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Auto.ceval deterministic' alt}{ceval\_deterministic'\_alt}{\coqdoclemma{ceval\_deterministic'\_alt}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{st2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof} \coqdockw{with} \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2} \coqdocvar{E1} \coqdocvar{E2};\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{st2};\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{E1};\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{intros} \coqdocvar{st2} \coqdocvar{E2}; \coqdoctac{inversion} \coqdocvar{E2}; \coqdoctac{subst}...\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{st'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{st'0}) \coqdockw{as} \coqdocvar{EQ1}...\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{subst} \coqdocvar{st'0}...\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H5}. \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H5}. \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H4}. \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{st'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{st'0}) \coqdockw{as} \coqdocvar{EQ1}...\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{subst} \coqdocvar{st'0}...\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{搜索前提}



 证明变得更简单了，但还是有些烦人的重复。我们先从矛盾的情况着手。
    这些矛盾都是因为我们同时有


      H1: beval st b = false


    和


      H2: beval st b = true


    这两个前提。矛盾很显然，但证明却有点麻烦：我们必须找到 \coqdocvar{H1} 和 \coqdocvar{H2}
    这两个前提，用一次 \coqdoctac{rewrite} 后再用一次 \coqdoctac{discriminate}。我们希望自动化此过程。


    （实际上，Coq 有个内建的 \coqdoctac{congruence} 策略来处理这种情况。
    不过我们暂时先忽略它的存在，为的是示范如何自己构建正向推理的策略。）


    第一步，我们可以通过在 Ltac 中编写一个小函数来抽象出有问题的脚本。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{rwd} \coqdocvar{H1} \coqdocvar{H2} := \coqdoctac{rewrite} \coqdocvar{H1} \coqdoctac{in} \coqdocvar{H2}; \coqdoctac{discriminate}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Auto.ceval deterministic''}{ceval\_deterministic'{}'}{\coqdoclemma{ceval\_deterministic'{}'}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st1}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{st2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2} \coqdocvar{E1} \coqdocvar{E2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{st2};\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{E1}; \coqdoctac{intros} \coqdocvar{st2} \coqdocvar{E2}; \coqdoctac{inversion} \coqdocvar{E2}; \coqdoctac{subst}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{st'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{st'0}) \coqdockw{as} \coqdocvar{EQ1} \coqdoctac{by} \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{subst} \coqdocvar{st'0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdocvar{rwd} \coqdocvar{H} \coqdocvar{H5}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdocvar{rwd} \coqdocvar{H} \coqdocvar{H5}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdocvar{rwd} \coqdocvar{H} \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdocvar{rwd} \coqdocvar{H} \coqdocvar{H4}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{st'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{st'0}) \coqdockw{as} \coqdocvar{EQ1} \coqdoctac{by} \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{subst} \coqdocvar{st'0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{auto}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
此例相比之前略有改进，但我们更希望 Coq 能替我们找到相关的假设。
    Ltac 中的 \coqdockw{match} \coqdockw{goal} 功能可达成此目的。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{find\_rwd} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdockw{goal} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{H1}: ?\coqdocvar{E} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}},\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{H2}: ?\coqdocvar{E} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{\vdash} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdocvar{rwd} \coqdocvar{H1} \coqdocvar{H2}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdockw{match} \coqdockw{goal} 会查找两个不同的，形如等式的前提，
    其左式为两个相同的任意表达式 \coqdocvar{E}，而右式为两个互相矛盾的布尔值。
    如果找到了这样的前提，就把 \coqdocvar{H1} 和 \coqdocvar{H2} 绑定为它们的名字，
    并将 \coqdocvar{rwd} 策略应用到 \coqdocvar{H1} 和 \coqdocvar{H2} 上。


    把此策略添加到每一个归纳证明的情况中，就能把所有的矛盾情况都解决了。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Auto.ceval deterministic'''}{ceval\_deterministic'{}'{}'}{\coqdoclemma{ceval\_deterministic'{}'{}'}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st1}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{st2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2} \coqdocvar{E1} \coqdocvar{E2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{st2};\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{E1}; \coqdoctac{intros} \coqdocvar{st2} \coqdocvar{E2}; \coqdoctac{inversion} \coqdocvar{E2}; \coqdoctac{subst}; \coqdoctac{try} \coqdocvar{find\_rwd}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{st'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{st'0}) \coqdockw{as} \coqdocvar{EQ1} \coqdoctac{by} \coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{subst} \coqdocvar{st'0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{assert} (\coqdocvar{st'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{st'0}) \coqdockw{as} \coqdocvar{EQ1} \coqdoctac{by} \coqdoctac{auto}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{subst} \coqdocvar{st'0}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{auto}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在我们来看看剩下的情况。每种情况都应用了带条件的前提以得到一个等式。
    目前我们把这些等式重述为断言，因此我们必须猜出需要的等式是什么
    （虽然可以用 \coqdoctac{auto} 证明它们）。另一种方式是找出用到的有关前提，
    然后用它们进行 \coqdoctac{rewrite} 改写，类似于这样： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Auto.ceval deterministic''''}{ceval\_deterministic'{}'{}'{}'}{\coqdoclemma{ceval\_deterministic'{}'{}'{}'}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st1}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{st2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2} \coqdocvar{E1} \coqdocvar{E2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{st2};\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{E1}; \coqdoctac{intros} \coqdocvar{st2} \coqdocvar{E2}; \coqdoctac{inversion} \coqdocvar{E2}; \coqdoctac{subst}; \coqdoctac{try} \coqdocvar{find\_rwd}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} (\coqdocvar{IHE1\_1} \coqdocvar{st'0} \coqdocvar{H1}) \coqdoctac{in} *. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} (\coqdocvar{IHE1\_1} \coqdocvar{st'0} \coqdocvar{H3}) \coqdoctac{in} *. \coqdoctac{auto}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在用于改写的相关前提可以自动查找了。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{find\_eqn} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdockw{goal} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{H1}: \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, ?\coqdocvar{P} \coqdocvariable{x} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} ?\coqdocvar{L} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} ?\coqdocvar{R},\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{H2}: ?\coqdocvar{P} ?\coqdocvar{X}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{\vdash} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{rewrite} (\coqdocvar{H1} \coqdocvar{X} \coqdocvar{H2}) \coqdoctac{in} *\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
模式 \coqdockw{\ensuremath{\forall}} \coqdocvariable{x}, ?\coqdocvariable{P} \coqdocvariable{x} \ensuremath{\rightarrow} ?\coqdocvar{L} = ?\coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 会匹配任何任何形如
    “对于所有的 \coqdocvariable{x}，\textit{'\coqdocvariable{x} 的某些性质'}蕴含\textit{'某些等式'}”的前提。
    \coqdocvariable{x} 的性质被绑定为模式变量 \coqdocvariable{P}，而该等式的左式和右式会分别绑定为
    \coqdocvar{L} 和 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}}。此前提的名字会被绑定为 \coqdocvar{H1}。之后模式 ?\coqdocvariable{P} ?\coqref{LF.Imp.X}{\coqdocdefinition{X}}
    会匹配任何提供了“\coqdocvariable{P} 对于某个具体的 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 成立的证据”的前提。
    如果两个模式均成功，我们会在所有的前提和目标中应用 \coqdoctac{rewrite} 策略改写
    （即，用 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 来实例化量化的 \coqdocvariable{x} 并将 \coqdocvar{H2} 作为 \coqdocvariable{P} \coqref{LF.Imp.X}{\coqdocdefinition{X}} 所需的证据提供）。


    还剩一个问题：通常，可能有好几对前提都具有这种一般形式，
    而挑出我们真正需要的好像比较困难。不过关键在于我们要认识到其实可以
    \textit{'全试一遍'}！以下是具体方法：



\begin{itemize}
\item  每一个 \coqdockw{match} \coqdockw{goal} 在执行时都会不停地查找可行的一对前提，
      直到右式 RHS 匹配成功；如果没有这样的一对前提则会失败。

\item  \coqdoctac{rewrite} 在得到一个形如 \coqref{LF.Imp.X}{\coqdocdefinition{X}} = \coqref{LF.Imp.X}{\coqdocdefinition{X}} 的平凡等式时会失败。

\item  我们可以把整体策略包装在 \coqdoctac{repeat} 中，这样就可以一直进行有用的改写，
      直到只剩下平凡的了。 
\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Auto.ceval deterministic'''''}{ceval\_deterministic'{}'{}'{}'{}'}{\coqdoclemma{ceval\_deterministic'{}'{}'{}'{}'}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st1}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{st2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2} \coqdocvar{E1} \coqdocvar{E2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{st2};\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{E1}; \coqdoctac{intros} \coqdocvar{st2} \coqdocvar{E2}; \coqdoctac{inversion} \coqdocvar{E2}; \coqdoctac{subst}; \coqdoctac{try} \coqdocvar{find\_rwd};\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{repeat} \coqdocvar{find\_eqn}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这种方法的巨大回报是，面对我们语言的适度变化时，我们的证明脚本会更加健壮。
    比如，我们可以为该语言增加一个 \coqdocvar{REPEAT} 指令。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Auto.Repeat}{Repeat}{\coqdocmodule{Repeat}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Auto.Repeat.com}{com}{\coqdocinductive{com}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Auto.Repeat.CSkip}{CSkip}{\coqdocconstructor{CSkip}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Auto.Repeat.CAss}{CAss}{\coqdocconstructor{CAss}} (\coqdocvar{x} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) (\coqdocvar{a} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Auto.Repeat.CSeq}{CSeq}{\coqdocconstructor{CSeq}} (\coqdocvar{c1} \coqdocvar{c2} : \coqref{LF.Auto.com}{\coqdocinductive{com}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Auto.Repeat.CIf}{CIf}{\coqdocconstructor{CIf}} (\coqdocvar{b} : \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}}) (\coqdocvar{c1} \coqdocvar{c2} : \coqref{LF.Auto.com}{\coqdocinductive{com}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Auto.Repeat.CWhile}{CWhile}{\coqdocconstructor{CWhile}} (\coqdocvar{b} : \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}}) (\coqdocvar{c} : \coqref{LF.Auto.com}{\coqdocinductive{com}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Auto.Repeat.CRepeat}{CRepeat}{\coqdocconstructor{CRepeat}} (\coqdocvar{c} : \coqref{LF.Auto.com}{\coqdocinductive{com}}) (\coqdocvar{b} : \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdocvar{REPEAT} 的行为和 \coqdocvar{WHILE} 类似，只是循环条件会在每次循环体执行完
    \textit{'之后'} 执行，且只在循环条件为\textit{'false'}时重复执行。
    因此，循环体至少会被执行一次。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Auto.Repeat.:::'SKIP'}{"}{"}'SKIP'" :=\coqdoceol
\coqdocindent{1.50em}
\coqref{LF.Auto.Repeat.CSkip}{\coqdocconstructor{CSkip}}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Auto.Repeat.:::x '::=' x}{"}{"}x '::=' a" :=\coqdoceol
\coqdocindent{1.00em}
(\coqref{LF.Auto.Repeat.CAss}{\coqdocconstructor{CAss}} \coqdocvar{x} \coqdocvar{a}) (\coqdoctac{at} \coqdockw{level} 60).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Auto.Repeat.:::x ';;' x}{"}{"}c1 ;; c2" :=\coqdoceol
\coqdocindent{1.00em}
(\coqref{LF.Auto.Repeat.CSeq}{\coqdocconstructor{CSeq}} \coqdocvar{c1} \coqdocvar{c2}) (\coqdoctac{at} \coqdockw{level} 80, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Auto.Repeat.:::'WHILE' x 'DO' x 'END'}{"}{"}'WHILE' b 'DO' c 'END'" :=\coqdoceol
\coqdocindent{1.00em}
(\coqref{LF.Auto.Repeat.CWhile}{\coqdocconstructor{CWhile}} \coqdocvar{b} \coqdocvar{c}) (\coqdoctac{at} \coqdockw{level} 80, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Auto.Repeat.:::'TEST' x 'THEN' x 'ELSE' x 'FI'}{"}{"}'TEST' c1 'THEN' c2 'ELSE' c3 'FI'" :=\coqdoceol
\coqdocindent{1.00em}
(\coqref{LF.Auto.Repeat.CIf}{\coqdocconstructor{CIf}} \coqdocvar{c1} \coqdocvar{c2} \coqdocvar{c3}) (\coqdoctac{at} \coqdockw{level} 80, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Auto.Repeat.:::'REPEAT' x 'UNTIL' x 'END'}{"}{"}'REPEAT' c 'UNTIL' b 'END'" :=\coqdoceol
\coqdocindent{1.00em}
(\coqref{LF.Auto.Repeat.CRepeat}{\coqdocconstructor{CRepeat}} \coqdocvar{c} \coqdocvar{b}) (\coqdoctac{at} \coqdockw{level} 80, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Reserved Notation} "st '=[' c ']=>' st'"\coqdoceol
\coqdocindent{9.00em}
(\coqdoctac{at} \coqdockw{level} 40).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Auto.Repeat.ceval}{ceval}{\coqdocinductive{ceval}} : \coqref{LF.Auto.Repeat.com}{\coqdocinductive{com}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.state}{\coqdocdefinition{state}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.state}{\coqdocdefinition{state}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Auto.Repeat.E Skip}{E\_Skip}{\coqdocconstructor{E\_Skip}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{st},\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Auto.Repeat.:::'SKIP'}{\coqdocnotation{SKIP}} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Auto.Repeat.E Ass}{E\_Ass}{\coqdocconstructor{E\_Ass}}  : \coqdockw{\ensuremath{\forall}} \coqdocvar{st} \coqdocvar{a1} \coqdocvar{n} \coqdocvar{x},\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvariable{a1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{x} \coqref{LF.Auto.Repeat.:::x '::=' x}{\coqdocnotation{::=}} \coqdocvariable{a1} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{n} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{st}\coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Auto.Repeat.E Seq}{E\_Seq}{\coqdocconstructor{E\_Seq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{c1} \coqdocvar{c2} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{st'{}'},\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st}  \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c1} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st'} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c2} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'{}'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st}  \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c1} \coqref{LF.Auto.Repeat.:::x ';;' x}{\coqdocnotation{;;}} \coqdocvariable{c2} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'{}'}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Auto.Repeat.E IfTrue}{E\_IfTrue}{\coqdocconstructor{E\_IfTrue}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{b} \coqdocvar{c1} \coqdocvar{c2},\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c1} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Auto.Repeat.:::'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} \coqdocvariable{b} \coqref{LF.Auto.Repeat.:::'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}} \coqdocvariable{c1} \coqref{LF.Auto.Repeat.:::'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}} \coqdocvariable{c2} \coqref{LF.Auto.Repeat.:::'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Auto.Repeat.E IfFalse}{E\_IfFalse}{\coqdocconstructor{E\_IfFalse}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{b} \coqdocvar{c1} \coqdocvar{c2},\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c2} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Auto.Repeat.:::'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} \coqdocvariable{b} \coqref{LF.Auto.Repeat.:::'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}} \coqdocvariable{c1} \coqref{LF.Auto.Repeat.:::'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}} \coqdocvariable{c2} \coqref{LF.Auto.Repeat.:::'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Auto.Repeat.E WhileFalse}{E\_WhileFalse}{\coqdocconstructor{E\_WhileFalse}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{st} \coqdocvar{c},\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Auto.Repeat.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqdocvariable{b} \coqref{LF.Auto.Repeat.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqdocvariable{c} \coqref{LF.Auto.Repeat.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Auto.Repeat.E WhileTrue}{E\_WhileTrue}{\coqdocconstructor{E\_WhileTrue}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{st'{}'} \coqdocvar{b} \coqdocvar{c},\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st}  \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st'} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Auto.Repeat.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqdocvariable{b} \coqref{LF.Auto.Repeat.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqdocvariable{c} \coqref{LF.Auto.Repeat.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'{}'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st}  \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Auto.Repeat.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqdocvariable{b} \coqref{LF.Auto.Repeat.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqdocvariable{c} \coqref{LF.Auto.Repeat.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'{}'}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Auto.Repeat.E RepeatEnd}{E\_RepeatEnd}{\coqdocconstructor{E\_RepeatEnd}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{b} \coqdocvar{c},\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st}  \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st'} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st}  \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Auto.Repeat.:::'REPEAT' x 'UNTIL' x 'END'}{\coqdocnotation{REPEAT}} \coqdocvariable{c} \coqref{LF.Auto.Repeat.:::'REPEAT' x 'UNTIL' x 'END'}{\coqdocnotation{UNTIL}} \coqdocvariable{b} \coqref{LF.Auto.Repeat.:::'REPEAT' x 'UNTIL' x 'END'}{\coqdocnotation{END}} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Auto.Repeat.E RepeatLoop}{E\_RepeatLoop}{\coqdocconstructor{E\_RepeatLoop}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{st'{}'} \coqdocvar{b} \coqdocvar{c},\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st}  \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st'} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st'} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Auto.Repeat.:::'REPEAT' x 'UNTIL' x 'END'}{\coqdocnotation{REPEAT}} \coqdocvariable{c} \coqref{LF.Auto.Repeat.:::'REPEAT' x 'UNTIL' x 'END'}{\coqdocnotation{UNTIL}} \coqdocvariable{b} \coqref{LF.Auto.Repeat.:::'REPEAT' x 'UNTIL' x 'END'}{\coqdocnotation{END}} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'{}'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st}  \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Auto.Repeat.:::'REPEAT' x 'UNTIL' x 'END'}{\coqdocnotation{REPEAT}} \coqdocvariable{c} \coqref{LF.Auto.Repeat.:::'REPEAT' x 'UNTIL' x 'END'}{\coqdocnotation{UNTIL}} \coqdocvariable{b} \coqref{LF.Auto.Repeat.:::'REPEAT' x 'UNTIL' x 'END'}{\coqdocnotation{END}} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'{}'}\coqdoceol
\coqdocnoindent
\coqdoceol
\coqdocindent{1.00em}
\coqdockw{where} \coqdef{LF.Auto.Repeat.:::x '=[' x ']=>' x}{"}{"}st =[ c ]=> st'" := (\coqref{LF.Auto.ceval}{\coqdocinductive{ceval}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st'}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们对确定性证明的第一次尝试并不成功：\coqref{LF.Auto.Repeat.E RepeatEnd}{\coqdocconstructor{E\_RepeatEnd}} 和 \coqref{LF.Auto.Repeat.E RepeatLoop}{\coqdocconstructor{E\_RepeatLoop}}
    这两种情况并没有被之前的自动化处理。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Auto.Repeat.ceval deterministic}{ceval\_deterministic}{\coqdoclemma{ceval\_deterministic}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st1}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{st2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2} \coqdocvar{E1} \coqdocvar{E2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{st2};\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{E1};\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{st2} \coqdocvar{E2}; \coqdoctac{inversion} \coqdocvar{E2}; \coqdoctac{subst}; \coqdoctac{try} \coqdocvar{find\_rwd}; \coqdoctac{repeat} \coqdocvar{find\_eqn}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.50em}
\coqdocvar{find\_rwd}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.50em}
+ \coqdoceol
\coqdocindent{4.00em}
\coqdocvar{find\_rwd}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
幸运的是，我们只需交换 \coqdocvar{find\_eqn} 和 \coqdocvar{find\_rwd}
    的调用顺序就能修复这一点。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Auto.Repeat.ceval deterministic'}{ceval\_deterministic'}{\coqdoclemma{ceval\_deterministic'}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st1}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Auto.Repeat.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{st1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{st2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2} \coqdocvar{E1} \coqdocvar{E2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{st2};\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{E1};\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{st2} \coqdocvar{E2}; \coqdoctac{inversion} \coqdocvar{E2}; \coqdoctac{subst}; \coqdoctac{repeat} \coqdocvar{find\_eqn}; \coqdoctac{try} \coqdocvar{find\_rwd}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.Auto.Repeat}{\coqdocmodule{Repeat}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这些例子为了让大家看看 Coq 中的“超级自动化”可以做到什么。
    \coqdockw{match} \coqdockw{goal} 在使用时的的细节十分复杂，调试也很不方便。
    但至少在证明时值得加入它来简化证明，避免繁琐的工作，
    并为未来的修改做好准备。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{变体 \texorpdfstring{\protect\coqdoctac{eapply}}{eapply} 和 \texorpdfstring{\protect\coqdoctac{eauto}}{eauto}}



 作为本章的结尾，我们来介绍一种更加方便的特性：
    它能够推迟量词的实例化。为了引出此特性，我们来回忆一下 \coqdoclibrary{Imp}
    中的这个例子： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Auto.ceval example1}{ceval\_example1}{\coqdocdefinition{ceval\_example1}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.empty st}{\coqdocdefinition{empty\_st}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} 2\coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '<=' x}{\coqdocnotation{\ensuremath{\le}}} 1\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} 3\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}} \coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} 4\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{(}}\coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} 4 \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.:::x '!->' x}{\coqdocnotation{!->}} 2\coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.Imp.E Seq}{\coqdocconstructor{E\_Seq}} \coqdockw{with} (\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.:::x '!->' x}{\coqdocnotation{!->}} 2).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{LF.Imp.E Ass}{\coqdocconstructor{E\_Ass}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{LF.Imp.E IfFalse}{\coqdocconstructor{E\_IfFalse}}. \coqdoctac{reflexivity}. \coqdoctac{apply} \coqref{LF.Imp.E Ass}{\coqdocconstructor{E\_Ass}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在证明的第一步，我们显式地提供了一个略长的表达式来帮助 Coq
    为 \coqref{LF.Imp.E Seq}{\coqdocconstructor{E\_Seq}} 构造子实例化一个“隐藏”的参数。需要它的原因在于
    \coqref{LF.Imp.E Seq}{\coqdocconstructor{E\_Seq}} 的定义...


          E\_Seq : forall c1 c2 st st' st'',
            st  = \coqref{LF.IndProp.R.c1}{\coqdocconstructor{c1}} => st'  ->
            st' = \coqref{LF.IndProp.R.c2}{\coqdocconstructor{c2}} => st'' ->
            st  = \coqref{LF.IndProp.R.c1}{\coqdocconstructor{c1}} ;; \coqref{LF.IndProp.R.c2}{\coqdocconstructor{c2}} => st''


   它是对 \coqdocvariable{st'} 的量化，而且并没有出现在结论中，因此将其结论与目标状态统一
   并不能帮助 Coq 为此变量找到合适的值。如果我们忽略 \coqdockw{with}，这一步就会失败
   （``Error: Unable to find an instance for the variable \coqdocvariable{st'}''）。


   该错误的愚蠢指出在于适合 \coqdocvariable{st'} 的值其实在后面的步骤中会相当明显，
   就在我们应用 \coqref{LF.Imp.E Ass}{\coqdocconstructor{E\_Ass}} 的地方。如果 Coq 能够等到这一步，就没必要显式地给出该值了。
   这正是 \coqdoctac{eapply} 策略所能做到的： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Auto.ceval' example1}{ceval'\_example1}{\coqdocdefinition{ceval'\_example1}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.empty st}{\coqdocdefinition{empty\_st}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} 2\coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '<=' x}{\coqdocnotation{\ensuremath{\le}}} 1\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} 3\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}} \coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} 4\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{(}}\coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} 4 \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.:::x '!->' x}{\coqdocnotation{!->}} 2\coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{eapply} \coqref{LF.Imp.E Seq}{\coqdocconstructor{E\_Seq}}. \coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{LF.Imp.E Ass}{\coqdocconstructor{E\_Ass}}. \coqdocindent{2.00em}
\coqdoctac{reflexivity}. \coqdocindent{1.00em}
-  \coqdoctac{apply} \coqref{LF.Imp.E IfFalse}{\coqdocconstructor{E\_IfFalse}}. \coqdoctac{reflexivity}. \coqdoctac{apply} \coqref{LF.Imp.E Ass}{\coqdocconstructor{E\_Ass}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdoctac{eapply} \coqdocvariable{H} 的行为和 \coqdoctac{apply} \coqdocvariable{H} 一样，只是在它统一完目标状态和
    \coqdocvariable{H} 的结论之后，它并不会在引入所有变量的过程中，
    麻烦你去检查它们在统一时是否被赋予了具体的值。


    如果你循着上面的证明步骤，就会看到 1 处的目标状态在生成的两个子目标中，
    都提到了\textit{'存在性变量'} ?\coqdocvariable{st'}。下一步，即把我们待带到 2 处的一步，
    会把 ?\coqdocvariable{st'} 替换成一个具体的值。这个新值包含一个新的存在性变量 ?\coqdocvariable{n}，
    它会被后面 3 处的 \coqdoctac{reflexivity} 步骤依次实例化。当我们开始着手第二个子目标时
    （4 处），我们观察到此子目标中出现的 ?\coqdocvariable{st'} 已经被替换成了在第一个子目标中给出的值。 

 我们目前学过的几个策略，包括 \coqdoctac{\ensuremath{\exists}}、\coqdoctac{constructor} 和 \coqdoctac{auto} 都有类似的变体。
    例如，下面是一个使用了 \coqdoctac{eauto} 的证明： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Constructors} \coqref{LF.Auto.ceval}{\coqdocinductive{ceval}}.\coqdoceol
\coqdocnoindent
\coqdockw{Hint Transparent} \coqref{LF.Imp.state}{\coqdocdefinition{state}}.\coqdoceol
\coqdocnoindent
\coqdockw{Hint Transparent} \coqref{LF.Maps.total map}{\coqdocdefinition{total\_map}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Auto.st12}{st12}{\coqdocdefinition{st12}} := (\coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} 2 \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.:::x '!->' x}{\coqdocnotation{!->}} 1).\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Auto.st21}{st21}{\coqdocdefinition{st21}} := (\coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} 1 \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.:::x '!->' x}{\coqdocnotation{!->}} 2).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Auto.eauto example}{eauto\_example}{\coqdocdefinition{eauto\_example}} : \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{s'}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Auto.st21}{\coqdocdefinition{st21}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '<=' x}{\coqdocnotation{\ensuremath{\le}}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}} \coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqref{LF.Imp.::imp scope:x '-' x}{\coqdocnotation{-}} \coqref{LF.Imp.X}{\coqdocdefinition{X}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '+' x}{\coqdocnotation{+}} \coqref{LF.Imp.Z}{\coqdocdefinition{Z}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{s'}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{info\_eauto}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdoctac{eauto} 的策略和 \coqdoctac{auto} 一样，除了它会使用 \coqdoctac{eapply} 而非 \coqdoctac{apply}；
    \coqdoctac{info\_eauto} 会显示 \coqdoctac{auto} 使用了哪个事实。 

 专业提示：有人可能会想，既然 \coqdoctac{eapply} 和 \coqdoctac{eauto} 比 \coqdoctac{apply} 和 \coqdoctac{auto}
    更强大，那么总是用它们不就好了。不幸的是，它们明显更慢，特别是 \coqdoctac{eauto}。
    Coq 专家倾向于主要使用 \coqdoctac{apply} 和 \coqdoctac{auto}，只在普通的版本无法做这些工作时才使用
    \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} 开头的变体。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.Extraction}{Library }{LF.Extraction}

\begin{coqdoccode}
\end{coqdoccode}
\section{Extraction: 从 Coq 中提取 ML}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{基本的提取方式}



 对于用 Coq 编写的代码而言，从中提取高效程序的最简方式是十分直白的。


    首先我们需要指定提取的目标语言。可选的语言有三种：提取机制最为成熟的
    OCaml，提取结果大都可以直接使用的 Haskell，以及提取机制有些过时的 Scheme。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.extraction.Extraction}{\coqdoclibrary{Coq.extraction.Extraction}}.\coqdoceol
\coqdocnoindent
\coqdockw{Extraction} \coqdocvar{Language} \coqdocvar{OCaml}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在我们将待提取的定义加载到 Coq 环境中。你可以直接写出定义，
    也可以从其它模块中加载。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.Arith}{\coqdoclibrary{Arith.Arith}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdoclibrary{Init.Nat}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.EqNat}{\coqdoclibrary{Arith.EqNat}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.ImpCEvalFun}{\coqdoclibrary{ImpCEvalFun}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
最后，我们来指定需要提取的定义，以及用于保存提取结果的文件名。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Extraction} "imp1.ml" \coqdocvar{ceval\_step}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Coq 在处理此指令时会生成一个名为 \coqdocvar{imp1.ml} 的文件，其中包含了提取后的
    \coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} 以及所有递归依赖的文件。编译本章对应的 .\coqdocvariable{v}
    文件，然后看看生成的 \coqdocvar{imp1.ml} 吧！ \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{控制提取特定的类型}



 我们可以让 Coq 将具体的 \coqdockw{Inductive} 定义提取为特定的 OCaml 类型。
    对于每一个定义，我们都要指明：

\begin{itemize}
\item  该 Coq 类型应当如何用 OCaml 来表示，以及

\item  该类型的构造子应如何转换为目标语言中对应的标识符。 
\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Extract} \coqdockw{Inductive} \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} \ensuremath{\Rightarrow} "bool" [ "true" "false" ].\coqdoceol
\coqdocemptyline
\end{coqdoccode}
对于非枚举类型（即构造器接受参数的类型），我们需要给出一个 OCaml
    表达式来作为该类型元素上的“递归器”。（想想丘奇数。）


    （译注：在这一部分，读者可以在为 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 指定对应的类型后使用
    \coqdockw{Extraction} \coqref{LF.Basics.NatPlayground2.plus}{\coqdocdefinition{plus}} 来得到自然数加法的提取结果，以此加深对“递归器”的理解。）\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Extract} \coqdockw{Inductive} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \ensuremath{\Rightarrow} "int"\coqdoceol
\coqdocindent{1.00em}
[ "0" "(fun x -> x + 1)" ]\coqdoceol
\coqdocindent{1.00em}
"(fun zero succ n ->
      if n=0 then zero () else succ (n-1))".\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们也可以将定义的常量提取为具体的 OCaml 项或者操作符。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Extract} \coqdocvar{Constant} \coqdocvar{plus} \ensuremath{\Rightarrow} "( + )".\coqdoceol
\coqdocnoindent
\coqdockw{Extract} \coqdocvar{Constant} \coqdocvar{mult} \ensuremath{\Rightarrow} "( * )".\coqdoceol
\coqdocnoindent
\coqdockw{Extract} \coqdocvar{Constant} \coqdocvar{eqb} \ensuremath{\Rightarrow} "( = )".\coqdoceol
\coqdocemptyline
\end{coqdoccode}
注意：保证提取结果的合理性是\textit{'你的责任'}。例如，以下指定可能十分自然：


      Extract Constant minus => ``( - )''.


    但是这样做会引起严重的混乱。（思考一下。为什么会这样呢？）
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Extraction} "imp2.ml" \coqdocvar{ceval\_step}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
检查一下生成的 \coqdocvar{imp2.ml} 文件，留意一下此次的提取结果与 \coqdocvar{imp1.ml}
    有何不同。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{一个完整的示例}



 为了使用提取的求值器运行 Imp 程序，我们还需要一个小巧的驱动程序
    来调用求值器并输出求值结果。


    为简单起见，我们只取最终状态下前四个存储空间中的内容作为程序的结果。
    （译注：这里的存储空间指作为状态的 \coqref{LF.Poly.map}{\coqdocdefinition{map}}。）


    为了更方便地输入例子，我们将会从 \coqdoclibrary{ImpParser} 模块中提取出语法解析器。
    首先需要正确建立 Coq 中的字符串与 OCaml 中字符列表的对应关系。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.extraction.ExtrOcamlBasic}{\coqdoclibrary{ExtrOcamlBasic}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.extraction.ExtrOcamlString}{\coqdoclibrary{ExtrOcamlString}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们还需要翻译另一种布尔值： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Extract} \coqdockw{Inductive} \coqexternalref{sumbool}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif}{\coqdocinductive{sumbool}} \ensuremath{\Rightarrow} "bool" ["true" "false"].\coqdoceol
\coqdocemptyline
\end{coqdoccode}
提取指令是相同的。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Imp}{\coqdoclibrary{Imp}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.ImpParser}{\coqdoclibrary{ImpParser}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Maps}{\coqdoclibrary{Maps}}.\coqdoceol
\coqdocnoindent
\coqdockw{Extraction} "imp.ml" \coqdocvar{empty\_st} \coqdocvar{ceval\_step} \coqdocvar{parse}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在我们来运行一下生成的 Imp 求值器。首先你应该阅览一下
    \coqdocvar{impdriver.ml}（这并非从某个 Coq 源码提取而来，它是手写的。）


    然后用下面的指令将求值器与驱动程序一同编译成可执行文件：


        ocamlc -w -20 -w -26 -o impdriver imp.mli imp.ml impdriver.ml
        ./impdriver


    （编译时所使用的 -\coqdocvar{w} 开关只是为了避免输出一些误报的警告信息。） \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{讨论}



 由于我们证明了 \coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} 函数的行为在适当的意义上与 \coqref{LF.Imp.BreakImp.ceval}{\coqdocinductive{ceval}}
    关系一致，因此提取出的程序可视作\textit{'已验证的'} Imp 解释器。
    当然，我们使用的语法分析器并未经过验证，因为我们并未对它进行任何证明！ \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{更进一步}



 有关提取的更多详情见\textit{'软件基础'}第三卷\textit{'已验证的函数式算法'}中的
    Extract 一章。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.ImpCEvalFun}{Library }{LF.ImpCEvalFun}

\begin{coqdoccode}
\end{coqdoccode}
\section{ImpCEvalFun: Imp 的求值函数}



 在\coqdoclibrary{Imp}一章中我们已经见到了直接为 \coqdoclibrary{Imp} 定义求值函数时会遇到的困难。
    当时为了规避这些困难，我们选择了定义求值关系而不是函数。
    而在这一可选的章节中，我们会再次讨论能够实现 \coqdoclibrary{Imp} 求值函数的方法。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{一个无法完成的求值器}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.omega.Omega}{\coqdoclibrary{omega.Omega}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.Arith}{\coqdoclibrary{Arith.Arith}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Imp}{\coqdoclibrary{Imp}} \coqref{LF.Maps}{\coqdoclibrary{Maps}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在初次为指令编写求值函数时，我们写出了如下忽略了 \coqdocvar{WHILE} 的代码： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Open} \coqdockw{Scope} \coqdocvar{imp\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.ImpCEvalFun.ceval step1}{ceval\_step1}{\coqdocdefinition{ceval\_step1}} (\coqdocvar{st} : \coqref{LF.Imp.state}{\coqdocdefinition{state}}) (\coqdocvar{c} : \coqref{LF.Imp.com}{\coqdocinductive{com}}) : \coqref{LF.Imp.state}{\coqdocdefinition{state}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{c} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'SKIP'}{\coqdocnotation{SKIP}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdocvariable{st}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{l} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqdocvar{a1} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
(\coqdocvar{l} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvar{a1} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{st})\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{c1} \coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}} \coqdocvar{c2} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{let} \coqdocvar{st'} := \coqref{LF.ImpCEvalFun.ceval step1}{\coqdocdefinition{ceval\_step1}} \coqdocvariable{st} \coqdocvar{c1} \coqdoctac{in}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.ImpCEvalFun.ceval step1}{\coqdocdefinition{ceval\_step1}} \coqdocvariable{st'} \coqdocvar{c2}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} \coqdocvar{b} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}} \coqdocvar{c1} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}} \coqdocvar{c2} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{if} (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvar{b})\coqdoceol
\coqdocindent{5.00em}
\coqdockw{then} \coqref{LF.ImpCEvalFun.ceval step1}{\coqdocdefinition{ceval\_step1}} \coqdocvariable{st} \coqdocvar{c1}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{else} \coqref{LF.ImpCEvalFun.ceval step1}{\coqdocdefinition{ceval\_step1}} \coqdocvariable{st} \coqdocvar{c2}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqdocvar{b1} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqdocvar{c1} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdocvariable{st}  \coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocnoindent
\coqdockw{Close} \coqdockw{Scope} \coqdocvar{imp\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
如\coqdoclibrary{Imp}一章中所言，在 ML 或 Haskell 这类传统的函数式语言中，
  我们可以这样处理 \coqdocvar{WHILE} 指令：


    | WHILE b1 DO c1 END =>
        if (beval st b1) then
          ceval\_step1 st (c1;; WHILE b1 DO c1 END)
        else st


    Coq 不会接受此定义（它会提示出现错误 \coqdocvar{Error}: \coqdocvar{Cannot} \coqdocvar{guess}
    \coqdocvar{decreasing} \coqdocvar{argument} \coqdockw{of} \coqdockw{fix}），因为我们想要定义的函数无需保证一定停机。
    确实，修改后的 \coqref{LF.ImpCEvalFun.ceval step1}{\coqdocdefinition{ceval\_step1}} 应用到 \coqdocvar{Imp.v} 中的 \coqref{LF.Imp.loop}{\coqdocdefinition{loop}} 程序时永远不会停机。
    因为 Coq 不仅是一个函数式编程语言，还拥有逻辑一致性，
    因此任何有可能不会停机的函数都会被拒绝。下面是一段无效的(!) Coq
    程序，它展示了假如 Coq 允许不停机的递归函数时会产生什么错误：


     Fixpoint loop\_false (n : nat) : False := loop\_false n.


    也就是说，像 \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}} 这样的命题会变成可证的（例如 \coqdocvar{loop\_false} 0
    就是个对 \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}} 的证明），这对 Coq 的逻辑一致性来说是一场灾难。


    由于它不会对所有的输入停机，因此至少在不借助附加技巧的情况下，
    \coqref{LF.ImpCEvalFun.ceval step1}{\coqdocdefinition{ceval\_step1}} 的完整版本无法用 Coq 写出... \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{一个计步的求值器}



 我们需要的技巧是将一个\textit{'附加'}的参数传入求值函数中来告诉它需要运行多久。
    非正式地说，我们会在求值器的“油箱”中加一定数量的“汽油”，
    然后允许它运行到按一般的方式终止\textit{'或者'}耗尽汽油，
    此时我们会停止求值并说最终结果为空内存（empty memory）。
    （我们也可以说当前的状态为求值器耗尽了汽油 -- 这无关紧要，
    因为无论在哪种情况下结果都是错误的！） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Open} \coqdockw{Scope} \coqdocvar{imp\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.ImpCEvalFun.ceval step2}{ceval\_step2}{\coqdocdefinition{ceval\_step2}} (\coqdocvar{st} : \coqref{LF.Imp.state}{\coqdocdefinition{state}}) (\coqdocvar{c} : \coqref{LF.Imp.com}{\coqdocinductive{com}}) (\coqdocvar{i} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.Imp.state}{\coqdocdefinition{state}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{i} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqref{LF.Imp.empty st}{\coqdocdefinition{empty\_st}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{i'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvariable{c} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'SKIP'}{\coqdocnotation{SKIP}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqdocvariable{st}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqdocvar{l} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqdocvar{a1} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
(\coqdocvar{l} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvar{a1} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{st})\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqdocvar{c1} \coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}} \coqdocvar{c2} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{let} \coqdocvar{st'} := \coqref{LF.ImpCEvalFun.ceval step2}{\coqdocdefinition{ceval\_step2}} \coqdocvariable{st} \coqdocvar{c1} \coqdocvar{i'} \coqdoctac{in}\coqdoceol
\coqdocindent{5.00em}
\coqref{LF.ImpCEvalFun.ceval step2}{\coqdocdefinition{ceval\_step2}} \coqdocvariable{st'} \coqdocvar{c2} \coqdocvar{i'}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} \coqdocvar{b} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}} \coqdocvar{c1} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}} \coqdocvar{c2} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{if} (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvar{b})\coqdoceol
\coqdocindent{6.00em}
\coqdockw{then} \coqref{LF.ImpCEvalFun.ceval step2}{\coqdocdefinition{ceval\_step2}} \coqdocvariable{st} \coqdocvar{c1} \coqdocvar{i'}\coqdoceol
\coqdocindent{6.00em}
\coqdockw{else} \coqref{LF.ImpCEvalFun.ceval step2}{\coqdocdefinition{ceval\_step2}} \coqdocvariable{st} \coqdocvar{c2} \coqdocvar{i'}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqdocvar{b1} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqdocvar{c1} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{if} (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvar{b1})\coqdoceol
\coqdocindent{5.00em}
\coqdockw{then} \coqdockw{let} \coqdocvar{st'} := \coqref{LF.ImpCEvalFun.ceval step2}{\coqdocdefinition{ceval\_step2}} \coqdocvariable{st} \coqdocvar{c1} \coqdocvar{i'} \coqdoctac{in}\coqdoceol
\coqdocindent{7.50em}
\coqref{LF.ImpCEvalFun.ceval step2}{\coqdocdefinition{ceval\_step2}} \coqdocvariable{st'} \coqdocvariable{c} \coqdocvar{i'}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{else} \coqdocvariable{st}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocnoindent
\coqdockw{Close} \coqdockw{Scope} \coqdocvar{imp\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\textit{'注意'}：很容易想到这里的索引 \coqdocvariable{i} 是用来计算“求值的步数”的。
    然而我们仔细研究就会发现实际并非如此。例如，在串连的规则中，同一个
    \coqdocvariable{i} 被传入了两个递归调用中。正确地理解 \coqdocvariable{i} 对于 \coqref{LF.ImpCEvalFun.ceval  ceval step}{\coqdoclemma{ceval\_\_ceval\_step}}
    的正式名分重要，它会在下面的练习中给出。


    此求值器不太好的一点就是我们无法根据其结果说它是否停止，
    因为程序可能是正常停机，也可能是耗尽了汽油。我们的下下一个版本会返回一个
    \coqref{LF.Poly.OptionPlayground.option}{\coqdocinductive{option}} \coqref{LF.Imp.state}{\coqdocdefinition{state}} 而非只是一个 \coqref{LF.Imp.state}{\coqdocdefinition{state}}，这样我们就能区分正常和异常的停机了。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Open} \coqdockw{Scope} \coqdocvar{imp\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.ImpCEvalFun.ceval step3}{ceval\_step3}{\coqdocdefinition{ceval\_step3}} (\coqdocvar{st} : \coqref{LF.Imp.state}{\coqdocdefinition{state}}) (\coqdocvar{c} : \coqref{LF.Imp.com}{\coqdocinductive{com}}) (\coqdocvar{i} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{10.00em}
: \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqref{LF.Imp.state}{\coqdocdefinition{state}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{i} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{i'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvariable{c} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'SKIP'}{\coqdocnotation{SKIP}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{st}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqdocvar{l} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqdocvar{a1} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{l} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvar{a1} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{st})\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqdocvar{c1} \coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}} \coqdocvar{c2} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{match} (\coqref{LF.ImpCEvalFun.ceval step3}{\coqdocdefinition{ceval\_step3}} \coqdocvariable{st} \coqdocvar{c1} \coqdocvar{i'}) \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvar{st'} \ensuremath{\Rightarrow} \coqref{LF.ImpCEvalFun.ceval step3}{\coqdocdefinition{ceval\_step3}} \coqdocvar{st'} \coqdocvar{c2} \coqdocvar{i'}\coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} \coqdocvar{b} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}} \coqdocvar{c1} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}} \coqdocvar{c2} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{if} (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvar{b})\coqdoceol
\coqdocindent{6.00em}
\coqdockw{then} \coqref{LF.ImpCEvalFun.ceval step3}{\coqdocdefinition{ceval\_step3}} \coqdocvariable{st} \coqdocvar{c1} \coqdocvar{i'}\coqdoceol
\coqdocindent{6.00em}
\coqdockw{else} \coqref{LF.ImpCEvalFun.ceval step3}{\coqdocdefinition{ceval\_step3}} \coqdocvariable{st} \coqdocvar{c2} \coqdocvar{i'}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqdocvar{b1} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqdocvar{c1} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{if} (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvar{b1})\coqdoceol
\coqdocindent{5.00em}
\coqdockw{then} \coqdockw{match} (\coqref{LF.ImpCEvalFun.ceval step3}{\coqdocdefinition{ceval\_step3}} \coqdocvariable{st} \coqdocvar{c1} \coqdocvar{i'}) \coqdockw{with}\coqdoceol
\coqdocindent{7.50em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvar{st'} \ensuremath{\Rightarrow} \coqref{LF.ImpCEvalFun.ceval step3}{\coqdocdefinition{ceval\_step3}} \coqdocvar{st'} \coqdocvariable{c} \coqdocvar{i'}\coqdoceol
\coqdocindent{7.50em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{7.50em}
\coqdockw{end}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{else} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{st}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocnoindent
\coqdockw{Close} \coqdockw{Scope} \coqdocvar{imp\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们可以引入一些辅助记法来隐藏对可选状态进行重复匹配的复杂工作，
    从而提高此版本的可读性。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.ImpCEvalFun.:::'LETOPT' x '<==' x 'IN' x}{"}{"}'LETOPT' x <== e1 'IN' e2"\coqdoceol
\coqdocindent{1.50em}
:= (\coqdockw{match} \coqdocvar{e1} \coqdockw{with}\coqdoceol
\coqdocindent{4.50em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{e2}\coqdoceol
\coqdocindent{4.50em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{3.50em}
\coqdockw{end})\coqdoceol
\coqdocindent{1.50em}
(\coqdoctac{right} \coqdockw{associativity}, \coqdoctac{at} \coqdockw{level} 60).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Open} \coqdockw{Scope} \coqdocvar{imp\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.ImpCEvalFun.ceval step}{ceval\_step}{\coqdocdefinition{ceval\_step}} (\coqdocvar{st} : \coqref{LF.Imp.state}{\coqdocdefinition{state}}) (\coqdocvar{c} : \coqref{LF.Imp.com}{\coqdocinductive{com}}) (\coqdocvar{i} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{10.00em}
: \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqref{LF.Imp.state}{\coqdocdefinition{state}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{i} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{i'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvariable{c} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'SKIP'}{\coqdocnotation{SKIP}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{st}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqdocvar{l} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqdocvar{a1} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvar{l} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvar{a1} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{st})\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqdocvar{c1} \coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}} \coqdocvar{c2} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqref{LF.ImpCEvalFun.:::'LETOPT' x '<==' x 'IN' x}{\coqdocnotation{LETOPT}} \coqdocvar{st'} \coqref{LF.ImpCEvalFun.:::'LETOPT' x '<==' x 'IN' x}{\coqdocnotation{<==}} \coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvariable{st} \coqdocvar{c1} \coqdocvar{i'} \coqref{LF.ImpCEvalFun.:::'LETOPT' x '<==' x 'IN' x}{\coqdocnotation{IN}}\coqdoceol
\coqdocindent{5.00em}
\coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvariable{st'} \coqdocvar{c2} \coqdocvar{i'}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} \coqdocvar{b} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}} \coqdocvar{c1} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}} \coqdocvar{c2} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{if} (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvar{b})\coqdoceol
\coqdocindent{6.00em}
\coqdockw{then} \coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvariable{st} \coqdocvar{c1} \coqdocvar{i'}\coqdoceol
\coqdocindent{6.00em}
\coqdockw{else} \coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvariable{st} \coqdocvar{c2} \coqdocvar{i'}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqdocvar{b1} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqdocvar{c1} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{if} (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvar{b1})\coqdoceol
\coqdocindent{5.00em}
\coqdockw{then} \coqref{LF.ImpCEvalFun.:::'LETOPT' x '<==' x 'IN' x}{\coqdocnotation{LETOPT}} \coqdocvar{st'} \coqref{LF.ImpCEvalFun.:::'LETOPT' x '<==' x 'IN' x}{\coqdocnotation{<==}} \coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvariable{st} \coqdocvar{c1} \coqdocvar{i'} \coqref{LF.ImpCEvalFun.:::'LETOPT' x '<==' x 'IN' x}{\coqdocnotation{IN}}\coqdoceol
\coqdocindent{7.50em}
\coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvariable{st'} \coqdocvariable{c} \coqdocvar{i'}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{else} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{st}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocnoindent
\coqdockw{Close} \coqdockw{Scope} \coqdocvar{imp\_scope}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpCEvalFun.test ceval}{test\_ceval}{\coqdocdefinition{test\_ceval}} (\coqdocvar{st}:\coqref{LF.Imp.state}{\coqdocdefinition{state}}) (\coqdocvar{c}:\coqref{LF.Imp.com}{\coqdocinductive{com}}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvariable{st} \coqdocvariable{c} 500 \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}    \ensuremath{\Rightarrow} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvar{st} \ensuremath{\Rightarrow} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{st} \coqref{LF.Imp.X}{\coqdocdefinition{X}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{st} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{st} \coqref{LF.Imp.Z}{\coqdocdefinition{Z}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard, recommended (pup\_to\_n)}




    编写一个 Imp 程序对 1 到 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 求和（即 1 + 2 + ... + \coqref{LF.Imp.X}{\coqdocdefinition{X}}）并赋值给 \coqref{LF.Imp.Y}{\coqdocdefinition{Y}}。
    确保你的解答能满足之后的测试。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpCEvalFun.pup to n}{pup\_to\_n}{\coqdocdefinition{pup\_to\_n}} : \coqref{LF.Imp.com}{\coqdocinductive{com}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, optional (peven)}




    编写一个 \coqdoclibrary{Imp} 程序：该程序在 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 为偶数时将 \coqref{LF.Basics.Z}{\coqdocconstructor{Z}} 置为 0，
    否则将 \coqref{LF.Basics.Z}{\coqdocconstructor{Z}} 置为 1。使用 \coqref{LF.ImpCEvalFun.test ceval}{\coqdocdefinition{test\_ceval}} 测试你的程序。 \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\section{关系求值 vs. 计步求值}



 对于算术表达式和布尔表达式，我们希望两种求值的定义最终都能产生同样的结果。
    本节将对此说明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.ImpCEvalFun.ceval step  ceval}{ceval\_step\_\_ceval}{\coqdoclemma{ceval\_step\_\_ceval}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st'},\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{i}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvariable{st} \coqdocvariable{c} \coqdocvariable{i} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{st'}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{inversion} \coqdocvar{H} \coqdockw{as} [\coqdocvar{i} \coqdocvar{E}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{clear} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{st'}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{st}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{c}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{i} \coqdockw{as} [| \coqdocvar{i'} ].\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{H}. \coqdoctac{discriminate} \coqdocvar{H}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{c};\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}; \coqdoctac{inversion} \coqdocvar{H}; \coqdoctac{subst}; \coqdoctac{clear} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
+  \coqdoctac{apply} \coqref{LF.Imp.E Skip}{\coqdocconstructor{E\_Skip}}.\coqdoceol
\coqdocindent{3.00em}
+  \coqdoctac{apply} \coqref{LF.Imp.E Ass}{\coqdocconstructor{E\_Ass}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocemptyline
\coqdocindent{3.00em}
+ \coqdoceol
\coqdocindent{4.00em}
\coqdoctac{destruct} (\coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvar{st} \coqdocvar{c1} \coqdocvar{i'}) \coqdocvar{eqn}:\coqdocvar{Heqr1}.\coqdoceol
\coqdocindent{4.00em}
\ensuremath{\times} \coqdoceol
\coqdocindent{5.00em}
\coqdoctac{apply} \coqref{LF.Imp.E Seq}{\coqdocconstructor{E\_Seq}} \coqdockw{with} \coqdocvar{s}.\coqdoceol
\coqdocindent{6.00em}
\coqdoctac{apply} \coqdocvar{IHi'}. \coqdoctac{rewrite} \coqdocvar{Heqr1}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{6.00em}
\coqdoctac{apply} \coqdocvar{IHi'}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{assumption}.\coqdoceol
\coqdocindent{4.00em}
\ensuremath{\times} \coqdoceol
\coqdocindent{5.00em}
\coqdoctac{discriminate} \coqdocvar{H1}.\coqdoceol
\coqdocemptyline
\coqdocindent{3.00em}
+ \coqdoceol
\coqdocindent{4.00em}
\coqdoctac{destruct} (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvar{st} \coqdocvar{b}) \coqdocvar{eqn}:\coqdocvar{Heqr}.\coqdoceol
\coqdocindent{4.00em}
\ensuremath{\times} \coqdoceol
\coqdocindent{5.00em}
\coqdoctac{apply} \coqref{LF.Imp.E IfTrue}{\coqdocconstructor{E\_IfTrue}}. \coqdoctac{rewrite} \coqdocvar{Heqr}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{5.00em}
\coqdoctac{apply} \coqdocvar{IHi'}. \coqdoctac{assumption}.\coqdoceol
\coqdocindent{4.00em}
\ensuremath{\times} \coqdoceol
\coqdocindent{5.00em}
\coqdoctac{apply} \coqref{LF.Imp.E IfFalse}{\coqdocconstructor{E\_IfFalse}}. \coqdoctac{rewrite} \coqdocvar{Heqr}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{5.00em}
\coqdoctac{apply} \coqdocvar{IHi'}. \coqdoctac{assumption}.\coqdoceol
\coqdocemptyline
\coqdocindent{3.00em}
+  \coqdoctac{destruct} (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvar{st} \coqdocvar{b}) \coqdocvar{eqn} :\coqdocvar{Heqr}.\coqdoceol
\coqdocindent{4.00em}
\ensuremath{\times} \coqdoceol
\coqdocindent{4.50em}
\coqdoctac{destruct} (\coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvar{st} \coqdocvar{c} \coqdocvar{i'}) \coqdocvar{eqn}:\coqdocvar{Heqr1}.\coqdoceol
\coqdocindent{4.50em}
\{ \coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqref{LF.Imp.E WhileTrue}{\coqdocconstructor{E\_WhileTrue}} \coqdockw{with} \coqdocvar{s}. \coqdoctac{rewrite} \coqdocvar{Heqr}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqdocvar{IHi'}. \coqdoctac{rewrite} \coqdocvar{Heqr1}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{apply} \coqdocvar{IHi'}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H1}. \coqdoctac{assumption}. \}\coqdoceol
\coqdocindent{4.50em}
\{  \coqdoctac{discriminate} \coqdocvar{H1}. \}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{\times} \coqdoceol
\coqdocindent{5.00em}
\coqdoctac{injection} \coqdocvar{H1} \coqdockw{as} \coqdocvar{H2}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H2}.\coqdoceol
\coqdocindent{5.00em}
\coqdoctac{apply} \coqref{LF.Imp.E WhileFalse}{\coqdocconstructor{E\_WhileFalse}}. \coqdoctac{apply} \coqdocvar{Heqr}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：4 星, standard (ceval\_step\_\_ceval\_inf)}




    按照通常的模版写出 \coqref{LF.ImpCEvalFun.ceval step  ceval}{\coqdoclemma{ceval\_step\_\_ceval}} 的非形式化证明，
    （对归纳定义的值进行分类讨论的模版，除了没有归纳假设外，
    应当看起来与归纳证明相同。）不要简单地翻译形式化证明的步骤，
    请让你的证明能够将主要想法传达给读者。 \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpCEvalFun.manual grade for ceval step  ceval inf}{manual\_grade\_for\_ceval\_step\_\_ceval\_inf}{\coqdocdefinition{manual\_grade\_for\_ceval\_step\_\_ceval\_inf}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.ImpCEvalFun.ceval step more}{ceval\_step\_more}{\coqdoclemma{ceval\_step\_more}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{i1} \coqdocvar{i2} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{c},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{i1} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{i2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvariable{st} \coqdocvariable{c} \coqdocvariable{i1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{st'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvariable{st} \coqdocvariable{c} \coqdocvariable{i2} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{st'}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdoctac{induction} \coqdocvar{i1} \coqdockw{as} [|\coqdocvar{i1'}]; \coqdoctac{intros} \coqdocvar{i2} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{c} \coqdocvar{Hle} \coqdocvar{Hceval}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hceval}. \coqdoctac{discriminate} \coqdocvar{Hceval}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{i2} \coqdockw{as} [|\coqdocvar{i2'}]. \coqdoctac{inversion} \coqdocvar{Hle}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{Hle'}: \coqdocvar{i1'} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvar{i2'}) \coqdoctac{by} \coqdoctac{omega}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{c}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hceval}. \coqdoctac{inversion} \coqdocvar{Hceval}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hceval}. \coqdoctac{inversion} \coqdocvar{Hceval}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hceval}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} (\coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvar{st} \coqdocvar{c1} \coqdocvar{i1'}) \coqdocvar{eqn}:\coqdocvar{Heqst1'o}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} (\coqdocvar{IHi1'} \coqdocvar{i2'}) \coqdoctac{in} \coqdocvar{Heqst1'o}; \coqdoctac{try} \coqdoctac{assumption}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \coqdocvar{Heqst1'o}. \coqdoctac{simpl}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hceval}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} (\coqdocvar{IHi1'} \coqdocvar{i2'}) \coqdoctac{in} \coqdocvar{Hceval}; \coqdoctac{try} \coqdoctac{assumption}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoceol
\coqdocindent{4.00em}
\coqdoctac{discriminate} \coqdocvar{Hceval}.\coqdoceol
\coqdocemptyline
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hceval}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvar{st} \coqdocvar{b}); \coqdoctac{apply} (\coqdocvar{IHi1'} \coqdocvar{i2'}) \coqdoctac{in} \coqdocvar{Hceval};\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocemptyline
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hceval}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvar{st} \coqdocvar{b}); \coqdoctac{try} \coqdoctac{assumption}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} (\coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvar{st} \coqdocvar{c} \coqdocvar{i1'}) \coqdocvar{eqn}: \coqdocvar{Heqst1'o}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} (\coqdocvar{IHi1'} \coqdocvar{i2'}) \coqdoctac{in} \coqdocvar{Heqst1'o}; \coqdoctac{try} \coqdoctac{assumption}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{Heqst1'o}. \coqdoctac{simpl}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hceval}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} (\coqdocvar{IHi1'} \coqdocvar{i2'}) \coqdoctac{in} \coqdocvar{Hceval}; \coqdoctac{try} \coqdoctac{assumption}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoceol
\coqdocindent{4.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hceval}. \coqdoctac{discriminate} \coqdocvar{Hceval}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：3 星, standard, recommended (ceval\_\_ceval\_step)}




    请完成以下证明。你会在某些地方用到 \coqref{LF.ImpCEvalFun.ceval step more}{\coqdoclemma{ceval\_step\_more}} 以及一些关于
    \ensuremath{\le} 和 \coqref{LF.Basics.NatPlayground2.plus}{\coqdocdefinition{plus}} 的基本事实。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.ImpCEvalFun.ceval  ceval step}{ceval\_\_ceval\_step}{\coqdoclemma{ceval\_\_ceval\_step}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st'},\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{i}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvariable{st} \coqdocvariable{c} \coqdocvariable{i} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{st'}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{Hce}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{Hce}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.ImpCEvalFun.ceval and ceval step coincide}{ceval\_and\_ceval\_step\_coincide}{\coqdoclemma{ceval\_and\_ceval\_step\_coincide}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st'},\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{i}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{LF.ImpCEvalFun.ceval step}{\coqdocdefinition{ceval\_step}} \coqdocvariable{st} \coqdocvariable{c} \coqdocvariable{i} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{st'}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st'}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}. \coqdoctac{apply} \coqref{LF.ImpCEvalFun.ceval  ceval step}{\coqdocaxiom{ceval\_\_ceval\_step}}. \coqdoctac{apply} \coqref{LF.ImpCEvalFun.ceval step  ceval}{\coqdoclemma{ceval\_step\_\_ceval}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{再论求值的确定性}



 根据关系求值和计步求值的定义等价这一事实，
    我们可以给出一种取巧的方式来证明求值\textit{'关系'}是确定性的。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.ImpCEvalFun.ceval deterministic'}{ceval\_deterministic'}{\coqdoclemma{ceval\_deterministic'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2},\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{st1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{st2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2} \coqdocvar{He1} \coqdocvar{He2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.ImpCEvalFun.ceval  ceval step}{\coqdocaxiom{ceval\_\_ceval\_step}} \coqdoctac{in} \coqdocvar{He1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.ImpCEvalFun.ceval  ceval step}{\coqdocaxiom{ceval\_\_ceval\_step}} \coqdoctac{in} \coqdocvar{He2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{inversion} \coqdocvar{He1} \coqdockw{as} [\coqdocvar{i1} \coqdocvar{E1}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{inversion} \coqdocvar{He2} \coqdockw{as} [\coqdocvar{i2} \coqdocvar{E2}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.ImpCEvalFun.ceval step more}{\coqdoclemma{ceval\_step\_more}} \coqdockw{with} (\coqdocvar{i2} := \coqdocvar{i1} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvar{i2}) \coqdoctac{in} \coqdocvar{E1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.ImpCEvalFun.ceval step more}{\coqdoclemma{ceval\_step\_more}} \coqdockw{with} (\coqdocvar{i2} := \coqdocvar{i1} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvar{i2}) \coqdoctac{in} \coqdocvar{E2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{E1} \coqdoctac{in} \coqdocvar{E2}. \coqdoctac{inversion} \coqdocvar{E2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{omega}. \coqdoctac{omega}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.ImpParser}{Library }{LF.ImpParser}

\begin{coqdoccode}
\end{coqdoccode}
\section{ImpParser: 用 Coq 实现词法分析和语法分析}



 在 \coqdocvar{Imp.v} 中，我们在设计 Imp 语言时完全忽略了具体的语法问题 ——
    我们仍需将程序员写下的 ASCII 字符串翻译成一棵由 \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}}、\coqref{LF.Imp.bexp}{\coqdocinductive{bexp}} 和
    \coqref{LF.Imp.BreakImp.com}{\coqdocinductive{com}} 所定义成的抽象语法树。在本章中，我们将会说明如何用 Coq
    的函数式编程特性来构造简单的词法分析器和语法分析器以填补这一空白。 

 你无需对本章中代码的所有细节了如指掌，文中对代码的解释十分简短，
    而且本章不包含任何练习：这一章的目的只是为了证明这是办得到的。
    你可以阅读这些代码，它们并不是特别复杂，只是语法分析器的代码使用了一些
    “单子式（Monadic）”的编程习语，可能会稍微有些难以理解；
    但是大部分的读者大概只会粗略看一眼，然后跳到末尾的“例子”一节。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{Strings.String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdoclibrary{Strings.Ascii}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.Arith}{\coqdoclibrary{Arith.Arith}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdoclibrary{Init.Nat}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.EqNat}{\coqdoclibrary{Arith.EqNat}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdoclibrary{Lists.List}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{ListNotations}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Maps}{\coqdoclibrary{Maps}} \coqref{LF.Imp}{\coqdoclibrary{Imp}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{内部结构}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{词法分析}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.isWhite}{isWhite}{\coqdocdefinition{isWhite}} (\coqdocvar{c} : \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{let} \coqdocvar{n} := \coqexternalref{nat of ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocdefinition{nat\_of\_ascii}} \coqdocvariable{c} \coqdoctac{in}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{orb}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{orb}} (\coqexternalref{orb}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{orb}} (\coqdocvariable{n} \coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{=?}} 32)   \coqdoceol
\coqdocindent{5.50em}
(\coqdocvariable{n} \coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{=?}} 9))   \coqdoceol
\coqdocindent{3.00em}
(\coqexternalref{orb}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{orb}} (\coqdocvariable{n} \coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{=?}} 10)   \coqdoceol
\coqdocindent{5.50em}
(\coqdocvariable{n} \coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{=?}} 13)). \coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.ImpParser.::nat scope:x '<=?' x}{"}{"}x '<=?' y" := (\coqdocvar{x} \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{<=?}} \coqdocvar{y})\coqdoceol
\coqdocindent{1.00em}
(\coqdoctac{at} \coqdockw{level} 70, \coqdockw{no} \coqdockw{associativity}) : \coqdocvar{nat\_scope}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.isLowerAlpha}{isLowerAlpha}{\coqdocdefinition{isLowerAlpha}} (\coqdocvar{c} : \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{let} \coqdocvar{n} := \coqexternalref{nat of ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocdefinition{nat\_of\_ascii}} \coqdocvariable{c} \coqdoctac{in}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{andb}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{andb}} (97 \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{<=?}} \coqdocvariable{n}) (\coqdocvariable{n} \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{<=?}} 122).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.isAlpha}{isAlpha}{\coqdocdefinition{isAlpha}} (\coqdocvar{c} : \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{let} \coqdocvar{n} := \coqexternalref{nat of ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocdefinition{nat\_of\_ascii}} \coqdocvariable{c} \coqdoctac{in}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{orb}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{orb}} (\coqexternalref{andb}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{andb}} (65 \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{<=?}} \coqdocvariable{n}) (\coqdocvariable{n} \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{<=?}} 90))\coqdoceol
\coqdocindent{4.00em}
(\coqexternalref{andb}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{andb}} (97 \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{<=?}} \coqdocvariable{n}) (\coqdocvariable{n} \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{<=?}} 122)).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.isDigit}{isDigit}{\coqdocdefinition{isDigit}} (\coqdocvar{c} : \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{let} \coqdocvar{n} := \coqexternalref{nat of ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocdefinition{nat\_of\_ascii}} \coqdocvariable{c} \coqdoctac{in}\coqdoceol
\coqdocindent{2.50em}
\coqexternalref{andb}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{andb}} (48 \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{<=?}} \coqdocvariable{n}) (\coqdocvariable{n} \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.PeanoNat}{\coqdocnotation{<=?}} 57).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.ImpParser.chartype}{chartype}{\coqdocinductive{chartype}} := \coqdef{LF.ImpParser.white}{white}{\coqdocconstructor{white}} \ensuremath{|} \coqdef{LF.ImpParser.alpha}{alpha}{\coqdocconstructor{alpha}} \ensuremath{|} \coqdef{LF.ImpParser.digit}{digit}{\coqdocconstructor{digit}} \ensuremath{|} \coqdef{LF.ImpParser.other}{other}{\coqdocconstructor{other}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.classifyChar}{classifyChar}{\coqdocdefinition{classifyChar}} (\coqdocvar{c} : \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) : \coqref{LF.ImpParser.chartype}{\coqdocinductive{chartype}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{if} \coqref{LF.ImpParser.isWhite}{\coqdocdefinition{isWhite}} \coqdocvariable{c} \coqdockw{then}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.white}{\coqdocconstructor{white}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{else} \coqdockw{if} \coqref{LF.ImpParser.isAlpha}{\coqdocdefinition{isAlpha}} \coqdocvariable{c} \coqdockw{then}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.alpha}{\coqdocconstructor{alpha}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{else} \coqdockw{if} \coqref{LF.ImpParser.isDigit}{\coqdocdefinition{isDigit}} \coqdocvariable{c} \coqdockw{then}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.digit}{\coqdocconstructor{digit}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{else}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.other}{\coqdocconstructor{other}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.ImpParser.list of string}{list\_of\_string}{\coqdocdefinition{list\_of\_string}} (\coqdocvar{s} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{s} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{EmptyString}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocconstructor{EmptyString}} \ensuremath{\Rightarrow} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{String}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocconstructor{String}} \coqdocvar{c} \coqdocvar{s} \ensuremath{\Rightarrow} \coqdocvar{c} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{LF.ImpParser.list of string}{\coqdocdefinition{list\_of\_string}} \coqdocvariable{s}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.ImpParser.string of list}{string\_of\_list}{\coqdocdefinition{string\_of\_list}} (\coqdocvar{xs} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{fold right}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocdefinition{fold\_right}} \coqexternalref{String}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocconstructor{String}} \coqexternalref{EmptyString}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocconstructor{EmptyString}} \coqdocvariable{xs}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.token}{token}{\coqdocdefinition{token}} := \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.ImpParser.tokenize helper}{tokenize\_helper}{\coqdocdefinition{tokenize\_helper}} (\coqdocvar{cls} : \coqref{LF.ImpParser.chartype}{\coqdocinductive{chartype}}) (\coqdocvar{acc} \coqdocvar{xs} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}})\coqdoceol
\coqdocindent{11.50em}
: \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} (\coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{let} \coqdocvar{tk} := \coqdockw{match} \coqdocvariable{acc} \coqdockw{with} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{|} \coqdocvar{\_}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{\_} \ensuremath{\Rightarrow} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqexternalref{rev}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocdefinition{rev}} \coqdocvariable{acc}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqdockw{end} \coqdoctac{in}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{xs} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqdocvariable{tk}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} (\coqdocvar{x}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{xs'}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvariable{cls}, \coqref{LF.ImpParser.classifyChar}{\coqdocdefinition{classifyChar}} \coqdocvar{x}, \coqdocvar{x} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{\_}, \coqdocvar{\_}, "("      \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{tk} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[}}"("\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{]}}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::(}}\coqref{LF.ImpParser.tokenize helper}{\coqdocdefinition{tokenize\_helper}} \coqref{LF.ImpParser.other}{\coqdocconstructor{other}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqdocvar{xs'}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{\_}, \coqdocvar{\_}, ")"      \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{tk} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[}}")"\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{]}}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::(}}\coqref{LF.ImpParser.tokenize helper}{\coqdocdefinition{tokenize\_helper}} \coqref{LF.ImpParser.other}{\coqdocconstructor{other}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqdocvar{xs'}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{\_}, \coqref{LF.ImpParser.white}{\coqdocconstructor{white}}, \coqdocvar{\_}    \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{tk} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{LF.ImpParser.tokenize helper}{\coqdocdefinition{tokenize\_helper}} \coqref{LF.ImpParser.white}{\coqdocconstructor{white}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqdocvar{xs'}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqref{LF.ImpParser.alpha}{\coqdocconstructor{alpha}},\coqref{LF.ImpParser.alpha}{\coqdocconstructor{alpha}},\coqdocvar{x}  \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.tokenize helper}{\coqdocdefinition{tokenize\_helper}} \coqref{LF.ImpParser.alpha}{\coqdocconstructor{alpha}} (\coqdocvar{x}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvariable{acc}) \coqdocvar{xs'}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqref{LF.ImpParser.digit}{\coqdocconstructor{digit}},\coqref{LF.ImpParser.digit}{\coqdocconstructor{digit}},\coqdocvar{x}  \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.tokenize helper}{\coqdocdefinition{tokenize\_helper}} \coqref{LF.ImpParser.digit}{\coqdocconstructor{digit}} (\coqdocvar{x}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvariable{acc}) \coqdocvar{xs'}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqref{LF.ImpParser.other}{\coqdocconstructor{other}},\coqref{LF.ImpParser.other}{\coqdocconstructor{other}},\coqdocvar{x}  \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.tokenize helper}{\coqdocdefinition{tokenize\_helper}} \coqref{LF.ImpParser.other}{\coqdocconstructor{other}} (\coqdocvar{x}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvariable{acc}) \coqdocvar{xs'}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{\_},\coqdocvar{tp},\coqdocvar{x}         \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{tk} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{++}} \coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{LF.ImpParser.tokenize helper}{\coqdocdefinition{tokenize\_helper}} \coqdocvar{tp} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqdocvar{x}\coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{]}} \coqdocvar{xs'}\coqexternalref{::list scope:x '++' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end} \%\coqdocvar{char}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.tokenize}{tokenize}{\coqdocdefinition{tokenize}} (\coqdocvar{s} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{map}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocdefinition{map}} \coqref{LF.ImpParser.string of list}{\coqdocdefinition{string\_of\_list}} (\coqref{LF.ImpParser.tokenize helper}{\coqdocdefinition{tokenize\_helper}} \coqref{LF.ImpParser.white}{\coqdocconstructor{white}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} (\coqref{LF.ImpParser.list of string}{\coqdocdefinition{list\_of\_string}} \coqdocvariable{s})).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.ImpParser.tokenize ex1}{tokenize\_ex1}{\coqdocdefinition{tokenize\_ex1}} :\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.tokenize}{\coqdocdefinition{tokenize}} "abc12=3  223*(3+(a+c))" \%\coqdocvar{string}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[}}"abc"\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} "12"\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} "="\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} "3"\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} "223"\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}\coqdoceol
\coqdocindent{3.50em}
"*"\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} "("\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} "3"\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} "+"\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} "("\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}\coqdoceol
\coqdocindent{3.50em}
"a"\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} "+"\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} "c"\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} ")"\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} ")"\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{]}}\%\coqdocvar{string}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{语法分析}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsubsection{带错误的可选值}



 一个附带出错信息的 \coqref{LF.Poly.OptionPlayground.option}{\coqdocinductive{option}} 类型: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.ImpParser.optionE}{optionE}{\coqdocinductive{optionE}} (\coqdocvar{X}:\coqdockw{Type}) : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.ImpParser.SomeE}{SomeE}{\coqdocconstructor{SomeE}} (\coqdocvar{x} : \coqdocvariable{X})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.ImpParser.NoneE}{NoneE}{\coqdocconstructor{NoneE}} (\coqdocvar{s} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Arguments} \coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \{\coqdocvar{X}\}.\coqdoceol
\coqdocnoindent
\coqdocvar{Arguments} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} \{\coqdocvar{X}\}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
加一些语法糖以便于编写嵌套的对 \coqref{LF.ImpParser.optionE}{\coqdocinductive{optionE}} 的匹配表达式。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.ImpParser.:::'''' x '<-' x ';;' x}{"}{"}' p <- e1 ;; e2"\coqdoceol
\coqdocindent{1.50em}
:= (\coqdockw{match} \coqdocvar{e1} \coqdockw{with}\coqdoceol
\coqdocindent{3.50em}
\ensuremath{|} \coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqdocvar{p} \ensuremath{\Rightarrow} \coqdocvar{e2}\coqdoceol
\coqdocindent{3.50em}
\ensuremath{|} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} \coqdocvar{err} \ensuremath{\Rightarrow} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} \coqdocvar{err}\coqdoceol
\coqdocindent{3.50em}
\coqdockw{end})\coqdoceol
\coqdocindent{1.50em}
(\coqdoctac{right} \coqdockw{associativity}, \coqdocvar{p} \coqdoctac{pattern}, \coqdoctac{at} \coqdockw{level} 60, \coqdocvar{e1} \coqdoctac{at} \coqdocvar{next} \coqdockw{level}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{"}{"}'TRY' ' p <- e1 ;; e2 'OR' e3"\coqdoceol
\coqdocindent{1.50em}
:= (\coqdockw{match} \coqdocvar{e1} \coqdockw{with}\coqdoceol
\coqdocindent{3.50em}
\ensuremath{|} \coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqdocvar{p} \ensuremath{\Rightarrow} \coqdocvar{e2}\coqdoceol
\coqdocindent{3.50em}
\ensuremath{|} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdocvar{e3}\coqdoceol
\coqdocindent{3.50em}
\coqdockw{end})\coqdoceol
\coqdocindent{1.50em}
(\coqdoctac{right} \coqdockw{associativity}, \coqdocvar{p} \coqdoctac{pattern},\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{at} \coqdockw{level} 60, \coqdocvar{e1} \coqdoctac{at} \coqdocvar{next} \coqdockw{level}, \coqdocvar{e2} \coqdoctac{at} \coqdocvar{next} \coqdockw{level}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{用于构建语法分析器的通用组合子}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Open} \coqdockw{Scope} \coqdocvar{string\_scope}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.parser}{parser}{\coqdocdefinition{parser}} (\coqdocvar{T} : \coqdockw{Type}) :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.ImpParser.token}{\coqdocdefinition{token}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.ImpParser.optionE}{\coqdocinductive{optionE}} (\coqdocvariable{T} \coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}} \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.ImpParser.token}{\coqdocdefinition{token}}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.ImpParser.many helper}{many\_helper}{\coqdocdefinition{many\_helper}} \{\coqdocvar{T}\} (\coqdocvar{p} : \coqref{LF.ImpParser.parser}{\coqdocdefinition{parser}} \coqdocvariable{T}) \coqdocvar{acc} \coqdocvar{steps} \coqdocvar{xs} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{steps}, \coqdocvariable{p} \coqdocvariable{xs} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} 0, \coqdocvar{\_} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} "Too many recursive calls"\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{\_}, \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} \coqdocvar{\_} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{((}}\coqexternalref{rev}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocdefinition{rev}} \coqdocvariable{acc}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{),}} \coqdocvariable{xs}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{steps'}, \coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{t}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{xs'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.many helper}{\coqdocdefinition{many\_helper}} \coqdocvariable{p} (\coqdocvar{t} \coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}} \coqdocvariable{acc}) \coqdocvar{steps'} \coqdocvar{xs'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
一个要求符合 \coqdocvariable{p} 零到多次的、指定步数的词法分析器： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.ImpParser.many}{many}{\coqdocdefinition{many}} \{\coqdocvar{T}\} (\coqdocvar{p} : \coqref{LF.ImpParser.parser}{\coqdocdefinition{parser}} \coqdocvariable{T}) (\coqdocvar{steps} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.ImpParser.parser}{\coqdocdefinition{parser}} (\coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqdocvariable{T}) :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.ImpParser.many helper}{\coqdocdefinition{many\_helper}} \coqdocvariable{p} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \coqdocvariable{steps}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
该词法分析器要求一个给定的词法标记（token），并用 \coqdocvariable{p} 对其进行处理： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.firstExpect}{firstExpect}{\coqdocdefinition{firstExpect}} \{\coqdocvar{T}\} (\coqdocvar{t} : \coqref{LF.ImpParser.token}{\coqdocdefinition{token}}) (\coqdocvar{p} : \coqref{LF.ImpParser.parser}{\coqdocdefinition{parser}} \coqdocvariable{T})\coqdoceol
\coqdocindent{10.50em}
: \coqref{LF.ImpParser.parser}{\coqdocdefinition{parser}} \coqdocvariable{T} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} \coqdocvar{xs} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvariable{xs} \coqdockw{with}\coqdoceol
\coqdocindent{6.00em}
\ensuremath{|} \coqdocvar{x}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{xs'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{7.00em}
\coqdockw{if} \coqexternalref{string dec}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocdefinition{string\_dec}} \coqdocvar{x} \coqdocvariable{t}\coqdoceol
\coqdocindent{7.00em}
\coqdockw{then} \coqdocvariable{p} \coqdocvar{xs'}\coqdoceol
\coqdocindent{7.00em}
\coqdockw{else} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} ("expected '" \coqexternalref{::string scope:x '++' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocnotation{++}} \coqdocvariable{t} \coqexternalref{::string scope:x '++' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocnotation{++}} "'.")\coqdoceol
\coqdocindent{6.00em}
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{7.00em}
\coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} ("expected '" \coqexternalref{::string scope:x '++' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocnotation{++}} \coqdocvariable{t} \coqexternalref{::string scope:x '++' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocnotation{++}} "'.")\coqdoceol
\coqdocindent{6.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
一个要求某个特定词法标记的语法分析器： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.expect}{expect}{\coqdocdefinition{expect}} (\coqdocvar{t} : \coqref{LF.ImpParser.token}{\coqdocdefinition{token}}) : \coqref{LF.ImpParser.parser}{\coqdocdefinition{parser}} \coqexternalref{unit}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{unit}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} \coqdocvariable{t} (\coqdockw{fun} \coqdocvar{xs} \ensuremath{\Rightarrow} \coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqexternalref{tt}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{tt}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{xs}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{一个 Imp 的递归下降语法分析器}



 标识符： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.parseIdentifier}{parseIdentifier}{\coqdocdefinition{parseIdentifier}} (\coqdocvar{xs} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.ImpParser.token}{\coqdocdefinition{token}})\coqdoceol
\coqdocindent{12.50em}
: \coqref{LF.ImpParser.optionE}{\coqdocinductive{optionE}} (\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}} \coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}} \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.ImpParser.token}{\coqdocdefinition{token}}) :=\coqdoceol
\coqdocnoindent
\coqdockw{match} \coqdocvariable{xs} \coqdockw{with}\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} "Expected identifier"\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdocvar{x}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{xs'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{if} \coqexternalref{forallb}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocdefinition{forallb}} \coqref{LF.ImpParser.isLowerAlpha}{\coqdocdefinition{isLowerAlpha}} (\coqref{LF.ImpParser.list of string}{\coqdocdefinition{list\_of\_string}} \coqdocvar{x}) \coqdockw{then}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{x}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{xs'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{else}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} ("Illegal identifier:'" \coqexternalref{::string scope:x '++' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocnotation{++}} \coqdocvar{x} \coqexternalref{::string scope:x '++' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocnotation{++}} "'")\coqdoceol
\coqdocnoindent
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
数字： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.parseNumber}{parseNumber}{\coqdocdefinition{parseNumber}} (\coqdocvar{xs} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.ImpParser.token}{\coqdocdefinition{token}})\coqdoceol
\coqdocindent{10.50em}
: \coqref{LF.ImpParser.optionE}{\coqdocinductive{optionE}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}} \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.ImpParser.token}{\coqdocdefinition{token}}) :=\coqdoceol
\coqdocnoindent
\coqdockw{match} \coqdocvariable{xs} \coqdockw{with}\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} "Expected number"\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdocvar{x}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{xs'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{if} \coqexternalref{forallb}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocdefinition{forallb}} \coqref{LF.ImpParser.isDigit}{\coqdocdefinition{isDigit}} (\coqref{LF.ImpParser.list of string}{\coqdocdefinition{list\_of\_string}} \coqdocvar{x}) \coqdockw{then}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqexternalref{fold left}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocdefinition{fold\_left}}\coqdoceol
\coqdocindent{7.50em}
(\coqdockw{fun} \coqdocvar{n} \coqdocvar{d} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{9.00em}
10 \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqexternalref{nat of ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocdefinition{nat\_of\_ascii}} \coqdocvariable{d} \coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{-}}\coqdoceol
\coqdocindent{14.00em}
\coqexternalref{nat of ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocdefinition{nat\_of\_ascii}} "0"\%\coqdocvar{char}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}})\coqdoceol
\coqdocindent{7.50em}
(\coqref{LF.ImpParser.list of string}{\coqdocdefinition{list\_of\_string}} \coqdocvar{x})\coqdoceol
\coqdocindent{7.50em}
0\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdoceol
\coqdocindent{6.50em}
\coqdocvar{xs'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{else}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} "Expected number"\coqdoceol
\coqdocnoindent
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
解析算术表达式： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.ImpParser.parsePrimaryExp}{parsePrimaryExp}{\coqdocdefinition{parsePrimaryExp}} (\coqdocvar{steps}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{12.50em}
(\coqdocvar{xs} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.ImpParser.token}{\coqdocdefinition{token}})\coqdoceol
\coqdocindent{11.50em}
: \coqref{LF.ImpParser.optionE}{\coqdocinductive{optionE}} (\coqref{LF.Imp.aexp}{\coqdocinductive{aexp}} \coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}} \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.ImpParser.token}{\coqdocdefinition{token}}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{steps} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} 0 \ensuremath{\Rightarrow} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} "Too many recursive calls"\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{steps'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{TRY}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{i}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.parseIdentifier}{\coqdocdefinition{parseIdentifier}} \coqdocvariable{xs} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{5.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{LF.Imp.AId}{\coqdocconstructor{AId}} \coqdocvariable{i}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{OR}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{TRY}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{n}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.parseNumber}{\coqdocdefinition{parseNumber}} \coqdocvariable{xs} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{5.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{LF.Imp.ANum}{\coqdocconstructor{ANum}} \coqdocvariable{n}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{OR}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} "(" (\coqref{LF.ImpParser.parseSumExp}{\coqdocdefinition{parseSumExp}} \coqdocvar{steps'}) \coqdocvariable{xs} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{u}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.expect}{\coqdocdefinition{expect}} ")" \coqdocvariable{rest} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvariable{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}\coqdoceol
\coqdocnoindent
\coqdoceol
\coqdocnoindent
\coqdockw{with} \coqdef{LF.ImpParser.parseProductExp}{parseProductExp}{\coqdocdefinition{parseProductExp}} (\coqdocvar{steps}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{10.50em}
(\coqdocvar{xs} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.ImpParser.token}{\coqdocdefinition{token}}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{steps} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} 0 \ensuremath{\Rightarrow} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} "Too many recursive calls"\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{steps'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.parsePrimaryExp}{\coqdocdefinition{parsePrimaryExp}} \coqdocvar{steps'} \coqdocvariable{xs} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{es}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.many}{\coqdocdefinition{many}} (\coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} "*" (\coqref{LF.ImpParser.parsePrimaryExp}{\coqdocdefinition{parsePrimaryExp}} \coqdocvar{steps'}))\coqdoceol
\coqdocindent{13.00em}
\coqdocvar{steps'} \coqdocvariable{rest} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqexternalref{fold left}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocdefinition{fold\_left}} \coqref{LF.Imp.AMult}{\coqdocconstructor{AMult}} \coqdocvariable{es} \coqdocvariable{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}\coqdoceol
\coqdocnoindent
\coqdoceol
\coqdocnoindent
\coqdockw{with} \coqdef{LF.ImpParser.parseSumExp}{parseSumExp}{\coqdocdefinition{parseSumExp}} (\coqdocvar{steps}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{xs} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.ImpParser.token}{\coqdocdefinition{token}})  :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{steps} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} 0 \ensuremath{\Rightarrow} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} "Too many recursive calls"\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{steps'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.parseProductExp}{\coqdocdefinition{parseProductExp}} \coqdocvar{steps'} \coqdocvariable{xs} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{es}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.ImpParser.many}{\coqdocdefinition{many}} (\coqdockw{fun} \coqdocvar{xs} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{8.00em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{TRY}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvar{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{\ensuremath{\leftarrow}}}\coqdoceol
\coqdocindent{10.00em}
\coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} "+"\coqdoceol
\coqdocindent{16.00em}
(\coqref{LF.ImpParser.parseProductExp}{\coqdocdefinition{parseProductExp}} \coqdocvar{steps'}) \coqdocvariable{xs} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{10.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{),}} \coqdocvariable{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{8.00em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{OR}}\coqdoceol
\coqdocindent{8.00em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}}\coqdoceol
\coqdocindent{10.00em}
\coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} "-"\coqdoceol
\coqdocindent{16.00em}
(\coqref{LF.ImpParser.parseProductExp}{\coqdocdefinition{parseProductExp}} \coqdocvar{steps'}) \coqdocvariable{xs} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{8.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{),}} \coqdocvariable{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}})\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{steps'} \coqdocvariable{rest} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqexternalref{fold left}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocdefinition{fold\_left}} (\coqdockw{fun} \coqdocvar{e0} \coqdocvar{term} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{13.00em}
\coqdockw{match} \coqdocvariable{term} \coqdockw{with}\coqdoceol
\coqdocindent{13.00em}
\ensuremath{|} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}  \coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \ensuremath{\Rightarrow} \coqref{LF.Imp.APlus}{\coqdocconstructor{APlus}} \coqdocvariable{e0} \coqdocvariable{e}\coqdoceol
\coqdocindent{13.00em}
\ensuremath{|} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \ensuremath{\Rightarrow} \coqref{LF.Imp.AMinus}{\coqdocconstructor{AMinus}} \coqdocvariable{e0} \coqdocvariable{e}\coqdoceol
\coqdocindent{13.00em}
\coqdockw{end})\coqdoceol
\coqdocindent{11.50em}
\coqdocvariable{es} \coqdocvariable{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdoceol
\coqdocindent{6.50em}
\coqdocvariable{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.parseAExp}{parseAExp}{\coqdocdefinition{parseAExp}} := \coqref{LF.ImpParser.parseSumExp}{\coqdocdefinition{parseSumExp}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
解析布尔表达式： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.ImpParser.parseAtomicExp}{parseAtomicExp}{\coqdocdefinition{parseAtomicExp}} (\coqdocvar{steps}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{12.00em}
(\coqdocvar{xs} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.ImpParser.token}{\coqdocdefinition{token}})  :=\coqdoceol
\coqdocnoindent
\coqdockw{match} \coqdocvariable{steps} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} 0 \ensuremath{\Rightarrow} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} "Too many recursive calls"\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{steps'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{TRY}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{u}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvar{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.expect}{\coqdocdefinition{expect}} "true" \coqdocvariable{xs} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.50em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{LF.Imp.BTrue}{\coqdocconstructor{BTrue}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvariable{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{OR}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{TRY}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{u}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvar{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.expect}{\coqdocdefinition{expect}} "false" \coqdocvariable{xs} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.50em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{LF.Imp.BFalse}{\coqdocconstructor{BFalse}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvariable{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{OR}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{TRY}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvar{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} "\~{}"\coqdoceol
\coqdocindent{17.50em}
(\coqref{LF.ImpParser.parseAtomicExp}{\coqdocdefinition{parseAtomicExp}} \coqdocvar{steps'})\coqdoceol
\coqdocindent{17.50em}
\coqdocvariable{xs} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.50em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{LF.Imp.BNot}{\coqdocconstructor{BNot}} \coqdocvariable{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{OR}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{TRY}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvar{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} "("\coqdoceol
\coqdocindent{17.50em}
(\coqref{LF.ImpParser.parseConjunctionExp}{\coqdocdefinition{parseConjunctionExp}} \coqdocvar{steps'})\coqdoceol
\coqdocindent{17.50em}
\coqdocvariable{xs} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.50em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{u}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvar{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.expect}{\coqdocdefinition{expect}} ")" \coqdocvariable{rest} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.50em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{OR}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.parseProductExp}{\coqdocdefinition{parseProductExp}} \coqdocvar{steps'} \coqdocvariable{xs} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{TRY}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{e'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} "="\coqdoceol
\coqdocindent{17.00em}
(\coqref{LF.ImpParser.parseAExp}{\coqdocdefinition{parseAExp}} \coqdocvar{steps'}) \coqdocvariable{rest} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.50em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{LF.Imp.BEq}{\coqdocconstructor{BEq}} \coqdocvariable{e} \coqdocvariable{e'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{OR}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{TRY}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{e'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} "<="\coqdoceol
\coqdocindent{19.00em}
(\coqref{LF.ImpParser.parseAExp}{\coqdocdefinition{parseAExp}} \coqdocvar{steps'}) \coqdocvariable{rest} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.50em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{LF.Imp.BLe}{\coqdocconstructor{BLe}} \coqdocvariable{e} \coqdocvariable{e'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{OR}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} "Expected '=' or '<=' after arithmetic expression"\coqdoceol
\coqdocnoindent
\coqdockw{end}\coqdoceol
\coqdocnoindent
\coqdoceol
\coqdocnoindent
\coqdockw{with} \coqdef{LF.ImpParser.parseConjunctionExp}{parseConjunctionExp}{\coqdocdefinition{parseConjunctionExp}} (\coqdocvar{steps}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{12.50em}
(\coqdocvar{xs} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.ImpParser.token}{\coqdocdefinition{token}}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{steps} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} 0 \ensuremath{\Rightarrow} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} "Too many recursive calls"\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{steps'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.parseAtomicExp}{\coqdocdefinition{parseAtomicExp}} \coqdocvar{steps'} \coqdocvariable{xs} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{es}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.many}{\coqdocdefinition{many}} (\coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} "\&\&"\coqdoceol
\coqdocindent{7.50em}
(\coqref{LF.ImpParser.parseAtomicExp}{\coqdocdefinition{parseAtomicExp}} \coqdocvar{steps'}))\coqdoceol
\coqdocindent{6.00em}
\coqdocvar{steps'} \coqdocvariable{rest} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqexternalref{fold left}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocdefinition{fold\_left}} \coqref{LF.Imp.BAnd}{\coqdocconstructor{BAnd}} \coqdocvariable{es} \coqdocvariable{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.parseBExp}{parseBExp}{\coqdocdefinition{parseBExp}} := \coqref{LF.ImpParser.parseConjunctionExp}{\coqdocdefinition{parseConjunctionExp}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.ImpParser.parseConjunctionExp}{\coqdocdefinition{parseConjunctionExp}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.testParsing}{testParsing}{\coqdocdefinition{testParsing}} \{\coqdocvar{X} : \coqdockw{Type}\}\coqdoceol
\coqdocindent{5.50em}
(\coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{8.00em}
\coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.ImpParser.token}{\coqdocdefinition{token}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{8.00em}
\coqref{LF.ImpParser.optionE}{\coqdocinductive{optionE}} (\coqdocvariable{X} \coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}} \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.ImpParser.token}{\coqdocdefinition{token}}))\coqdoceol
\coqdocindent{5.50em}
(\coqdocvar{s} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{let} \coqdocvar{t} := \coqref{LF.ImpParser.tokenize}{\coqdocdefinition{tokenize}} \coqdocvariable{s} \coqdoctac{in}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{p} 100 \coqdocvariable{t}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
解析指令： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.ImpParser.parseSimpleCommand}{parseSimpleCommand}{\coqdocdefinition{parseSimpleCommand}} (\coqdocvar{steps}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{14.00em}
(\coqdocvar{xs} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.ImpParser.token}{\coqdocdefinition{token}}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{steps} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} 0 \ensuremath{\Rightarrow} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} "Too many recursive calls"\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{steps'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{TRY}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{u}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.expect}{\coqdocdefinition{expect}} "SKIP" \coqdocvariable{xs} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{LF.Imp.::imp scope:'SKIP'}{\coqdocnotation{SKIP}}\%\coqdocvar{imp}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{OR}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{TRY}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvar{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{\ensuremath{\leftarrow}}}\coqdoceol
\coqdocindent{6.00em}
\coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} "TEST"\coqdoceol
\coqdocindent{12.00em}
(\coqref{LF.ImpParser.parseBExp}{\coqdocdefinition{parseBExp}} \coqdocvar{steps'}) \coqdocvariable{xs} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{c}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvar{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}}\coqdoceol
\coqdocindent{6.00em}
\coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} "THEN"\coqdoceol
\coqdocindent{12.00em}
(\coqref{LF.ImpParser.parseSequencedCommand}{\coqdocdefinition{parseSequencedCommand}} \coqdocvar{steps'}) \coqdocvariable{rest} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{c'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvar{rest'{}'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}}\coqdoceol
\coqdocindent{6.00em}
\coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} "ELSE"\coqdoceol
\coqdocindent{12.00em}
(\coqref{LF.ImpParser.parseSequencedCommand}{\coqdocdefinition{parseSequencedCommand}} \coqdocvar{steps'}) \coqdocvariable{rest'} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqexternalref{tt}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{tt}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvar{rest'{}'{}'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}}\coqdoceol
\coqdocindent{6.00em}
\coqref{LF.ImpParser.expect}{\coqdocdefinition{expect}} "END" \coqdocvariable{rest'{}'} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{3.50em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} \coqdocvariable{e} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}} \coqdocvariable{c} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}} \coqdocvariable{c'} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}}\%\coqdocvar{imp}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{rest'{}'{}'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{OR}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{TRY}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvar{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{\ensuremath{\leftarrow}}}\coqdoceol
\coqdocindent{6.00em}
\coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} "WHILE"\coqdoceol
\coqdocindent{12.00em}
(\coqref{LF.ImpParser.parseBExp}{\coqdocdefinition{parseBExp}} \coqdocvar{steps'}) \coqdocvariable{xs} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{c}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvar{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}}\coqdoceol
\coqdocindent{6.00em}
\coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} "DO"\coqdoceol
\coqdocindent{12.00em}
(\coqref{LF.ImpParser.parseSequencedCommand}{\coqdocdefinition{parseSequencedCommand}} \coqdocvar{steps'}) \coqdocvariable{rest} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{u}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvar{rest'{}'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}}\coqdoceol
\coqdocindent{6.00em}
\coqref{LF.ImpParser.expect}{\coqdocdefinition{expect}} "END" \coqdocvariable{rest'} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqdocvariable{e} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqdocvariable{c} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}}\%\coqdocvar{imp}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{rest'{}'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{OR}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{TRY}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{i}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.parseIdentifier}{\coqdocdefinition{parseIdentifier}} \coqdocvariable{xs} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{e}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} "::=" (\coqref{LF.ImpParser.parseAExp}{\coqdocdefinition{parseAExp}} \coqdocvar{steps'}) \coqdocvariable{rest} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}(\coqdocvariable{i} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqdocvariable{e})\%\coqdocvar{imp}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{OR}}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} "Expecting a command"\coqdoceol
\coqdocnoindent
\coqdockw{end}\coqdoceol
\coqdocnoindent
\coqdoceol
\coqdocnoindent
\coqdockw{with} \coqdef{LF.ImpParser.parseSequencedCommand}{parseSequencedCommand}{\coqdocdefinition{parseSequencedCommand}} (\coqdocvar{steps}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{13.50em}
(\coqdocvar{xs} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.ImpParser.token}{\coqdocdefinition{token}}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{steps} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} 0 \ensuremath{\Rightarrow} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} "Too many recursive calls"\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{steps'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{c}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{\ensuremath{\leftarrow}}} \coqref{LF.ImpParser.parseSimpleCommand}{\coqdocdefinition{parseSimpleCommand}} \coqdocvar{steps'} \coqdocvariable{xs} \coqref{LF.ImpParser.:::'''' x '<-' x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{TRY}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{'}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{c'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{\ensuremath{\leftarrow}}}\coqdoceol
\coqdocindent{6.00em}
\coqref{LF.ImpParser.firstExpect}{\coqdocdefinition{firstExpect}} ";;"\coqdoceol
\coqdocindent{12.00em}
(\coqref{LF.ImpParser.parseSequencedCommand}{\coqdocdefinition{parseSequencedCommand}} \coqdocvar{steps'}) \coqdocvariable{rest} \coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}(\coqdocvariable{c} \coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}} \coqdocvariable{c'})\%\coqdocvar{imp}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{rest'}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.:::'TRY' '''' x '<-' x ';;' x 'OR' x}{\coqdocnotation{OR}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvariable{c}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvariable{rest}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.bignumber}{bignumber}{\coqdocdefinition{bignumber}} := 1000.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ImpParser.parse}{parse}{\coqdocdefinition{parse}} (\coqdocvar{str} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) : \coqref{LF.ImpParser.optionE}{\coqdocinductive{optionE}} \coqref{LF.Imp.com}{\coqdocinductive{com}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{let} \coqdocvar{tokens} := \coqref{LF.ImpParser.tokenize}{\coqdocdefinition{tokenize}} \coqdocvariable{str} \coqdoctac{in}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqref{LF.ImpParser.parseSequencedCommand}{\coqdocdefinition{parseSequencedCommand}} \coqref{LF.ImpParser.bignumber}{\coqdocdefinition{bignumber}} \coqdocvariable{tokens} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{c}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \ensuremath{\Rightarrow} \coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqdocvar{c}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} \coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{\_}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{t}\coqexternalref{::list scope:x '::' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{::}}\coqdocvar{\_}\coqexternalref{::core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{)}} \ensuremath{\Rightarrow} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} ("Trailing tokens remaining: " \coqexternalref{::string scope:x '++' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocnotation{++}} \coqdocvar{t})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} \coqdocvar{err} \ensuremath{\Rightarrow} \coqref{LF.ImpParser.NoneE}{\coqdocconstructor{NoneE}} \coqdocvar{err}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{示例}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.ImpParser.eg1}{eg1}{\coqdocdefinition{eg1}} : \coqref{LF.ImpParser.parse}{\coqdocdefinition{parse}} "
  TEST x = y + 1 + 2 - y * 6 + 3 THEN
    x ::= x * 1;;
    y ::= 0
  ELSE
    SKIP
  END  "\coqdoceol
\coqdocnoindent
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} (\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} "x" \coqref{LF.Imp.::imp scope:x '=' x}{\coqdocnotation{=}} "y" \coqref{LF.Imp.::imp scope:x '+' x}{\coqdocnotation{+}} 1 \coqref{LF.Imp.::imp scope:x '+' x}{\coqdocnotation{+}} 2 \coqref{LF.Imp.::imp scope:x '-' x}{\coqdocnotation{-}} "y" \coqref{LF.Imp.::imp scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} 6 \coqref{LF.Imp.::imp scope:x '+' x}{\coqdocnotation{+}} 3 \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}}\coqdoceol
\coqdocindent{4.00em}
"x" \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} "x" \coqref{LF.Imp.::imp scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} 1\coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.00em}
"y" \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} 0\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.Imp.::imp scope:'SKIP'}{\coqdocnotation{SKIP}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}})\%\coqdocvar{imp}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{cbv}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.ImpParser.eg2}{eg2}{\coqdocdefinition{eg2}} : \coqref{LF.ImpParser.parse}{\coqdocdefinition{parse}} "
  SKIP;;
  z::=x*y*(x*x);;
  WHILE x=x DO
    TEST (z <= z*z) \&\& \~{}(x = 2) THEN
      x ::= z;;
      y ::= z
    ELSE
      SKIP
    END;;
    SKIP
  END;;
  x::=z  "\coqdoceol
\coqdocnoindent
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.ImpParser.SomeE}{\coqdocconstructor{SomeE}} (\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.::imp scope:'SKIP'}{\coqdocnotation{SKIP}}\coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{3.00em}
"z" \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} "x" \coqref{LF.Imp.::imp scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} "y" \coqref{LF.Imp.::imp scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{LF.Imp.::imp scope:x '*' x}{\coqdocnotation{(}}"x" \coqref{LF.Imp.::imp scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} "x"\coqref{LF.Imp.::imp scope:x '*' x}{\coqdocnotation{)}}\coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} "x" \coqref{LF.Imp.::imp scope:x '=' x}{\coqdocnotation{=}} "x" \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} \coqref{LF.Imp.::imp scope:x 'x26x26' x}{\coqdocnotation{(}}"z" \coqref{LF.Imp.::imp scope:x '<=' x}{\coqdocnotation{\ensuremath{\le}}} "z" \coqref{LF.Imp.::imp scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} "z"\coqref{LF.Imp.::imp scope:x 'x26x26' x}{\coqdocnotation{)}} \coqref{LF.Imp.::imp scope:x 'x26x26' x}{\coqdocnotation{\&\&}} \coqref{LF.Imp.::imp scope:'x7E' x}{\coqdocnotation{\~{}(}}"x" \coqref{LF.Imp.::imp scope:x '=' x}{\coqdocnotation{=}} 2\coqref{LF.Imp.::imp scope:'x7E' x}{\coqdocnotation{)}} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}}\coqdoceol
\coqdocindent{5.00em}
"x" \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} "z"\coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{5.00em}
"y" \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} "z"\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}}\coqdoceol
\coqdocindent{5.00em}
\coqref{LF.Imp.::imp scope:'SKIP'}{\coqdocnotation{SKIP}}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}}\coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.Imp.::imp scope:'SKIP'}{\coqdocnotation{SKIP}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}}\coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{3.00em}
"x" \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} "z")\%\coqdocvar{imp}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{cbv}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.Imp}{Library }{LF.Imp}

\begin{coqdoccode}
\end{coqdoccode}
\section{Imp: 简单的指令式程序}



 在本章中，我们会更加认真地看待如何用 Coq 来研究其它东西。
    我们的案例研究是一个名为 Imp 的\textit{'简单的指令式编程语言'}，
    它包含了传统主流语言（如 C 和 Java）的一小部分核心片段。下面是一个用
    Imp 编写的常见数学函数：


       Z ::= X;;
       Y ::= 1;;
       WHILE \~{}(Z = 0) DO
         Y ::= Y * Z;;
         Z ::= Z - 1
       END


 本章关注于如何定义 Imp 的\textit{'语法'}和\textit{'语义'}；\textit{'《编程语言基础》
    （Programming Language Foundations）'}（\textit{'《软件基础》'}第二卷）
    中的章节则发展了\textit{'程序等价关系（Program Equivalence）'}并引入了
    \textit{'霍尔逻辑（Hoare Logic）'}，它是一种广泛用于推理指令式程序的逻辑。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Bool.Bool}{\coqdoclibrary{Bool.Bool}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdoclibrary{Init.Nat}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.Arith}{\coqdoclibrary{Arith.Arith}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.EqNat}{\coqdoclibrary{Arith.EqNat}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.omega.Omega}{\coqdoclibrary{omega.Omega}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdoclibrary{Lists.List}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{Strings.String}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{ListNotations}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Import} \coqref{LF.Maps}{\coqdoclibrary{Maps}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{算术和布尔表达式}



 我们会分三部分来展示 Imp：首先是\textit{'算术和布尔表达式'}的核心语言，
    之后是用\textit{'变量'}对表达式的扩展，最后是一个包括赋值、条件、串连和循环的
    \textit{'指令'}语言。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{语法}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Imp.AExp}{AExp}{\coqdocmodule{AExp}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
以下两个定义指定了算术和布尔表达式的\textit{'抽象语法（Abstract Syntax）'}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.AExp.aexp}{aexp}{\coqdocinductive{aexp}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.ANum}{ANum}{\coqdocconstructor{ANum}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.APlus}{APlus}{\coqdocconstructor{APlus}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.AMinus}{AMinus}{\coqdocconstructor{AMinus}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.AMult}{AMult}{\coqdocconstructor{AMult}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.AExp.bexp}{bexp}{\coqdocinductive{bexp}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.BTrue}{BTrue}{\coqdocconstructor{BTrue}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.BFalse}{BFalse}{\coqdocconstructor{BFalse}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.BEq}{BEq}{\coqdocconstructor{BEq}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.BLe}{BLe}{\coqdocconstructor{BLe}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.BNot}{BNot}{\coqdocconstructor{BNot}} (\coqdocvar{b} : \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.BAnd}{BAnd}{\coqdocconstructor{BAnd}} (\coqdocvar{b1} \coqdocvar{b2} : \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在本章中，我们省略了大部分从程序员实际编写的具体语法到其抽象语法树的翻译
 例如，它会将字符串 "1 + 2 \ensuremath{\times} 3" 翻译成如下 AST：


      APlus (ANum 1) (AMult (ANum 2) (ANum 3)).


    可选的章节 \coqdoclibrary{ImpParser} 中开发了一个简单的词法分析器和解析器，
    它可以进行这种翻译。你\textit{'无需'}通过理解该章来理解本章，
    但如果你没有上过涵盖这些技术的课程（例如编译器课程），可能想要略读一下该章节。 

 作为对比，下面是用约定的 BNF（巴克斯-诺尔范式）文法定义的同样的抽象语法：


    a ::= nat
        | a + a
        | a - a
        | a * a


    b ::= true
        | false
        | a = a
        | a <= a
        | \~{} b
        | b \&\& b


 与前面的 Coq 版本相对比...



\begin{itemize}
\item  BNF 是非形式化的 -- 例如，它给出了表达式表面上的语法的建议
         （例如加法运算符写作中缀的 +），而没有指定词法分析和解析的其它方面
         （如 +、- 和 \ensuremath{\times} 的相对优先级，用括号来明确子表达式的分组等）。
         在实现编译器时，需要一些附加的信息（以及人类的智慧）
         才能将此描述转换成形式化的定义。


         Coq 版本则始终忽略了所有这些信息，只专注于抽象语法。



\item  反之，BNF 版本则更加清晰易读。它的非形式化使其更加灵活，
         在讨论和在黑板上书写时，它有很大的优势，
         此时传达一般的概念要比精确定下所有细节更加重要。


         确实，存在很多种类似 BNF 的记法，人们可以随意使用它们，
         而无需关心具体使用了哪种 BNF，因为没有必要：
         大致的理解是非常重要的。

\end{itemize}


    适应这两种记法都很有必要：非形式化的用语人类之间的交流，
    而形式化的则用于实现和证明。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{求值}



 对算术表达式进行\textit{'求值（Evaluation）'}会得到数值。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Imp.AExp.aeval}{aeval}{\coqdocdefinition{aeval}} (\coqdocvar{a} : \coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{a} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AExp.ANum}{\coqdocconstructor{ANum}} \coqdocvar{n} \ensuremath{\Rightarrow} \coqdocvar{n}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AExp.APlus}{\coqdocconstructor{APlus}}  \coqdocvar{a1} \coqdocvar{a2} \ensuremath{\Rightarrow} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvar{a1}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvar{a2}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AExp.AMinus}{\coqdocconstructor{AMinus}} \coqdocvar{a1} \coqdocvar{a2} \ensuremath{\Rightarrow} \coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvar{a1}\coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{-}} \coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvar{a2}\coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AExp.AMult}{\coqdocconstructor{AMult}}  \coqdocvar{a1} \coqdocvar{a2} \ensuremath{\Rightarrow} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvar{a1}\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvar{a2}\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Imp.AExp.test aeval1}{test\_aeval1}{\coqdocdefinition{test\_aeval1}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.AExp.aeval}{\coqdocdefinition{aeval}} (\coqref{LF.Imp.AExp.APlus}{\coqdocconstructor{APlus}} (\coqref{LF.Imp.AExp.ANum}{\coqdocconstructor{ANum}} 2) (\coqref{LF.Imp.AExp.ANum}{\coqdocconstructor{ANum}} 2)) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 4.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
同样，对布尔表达式求值会得到布尔值。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Imp.AExp.beval}{beval}{\coqdocdefinition{beval}} (\coqdocvar{b} : \coqref{LF.Imp.AExp.bexp}{\coqdocinductive{bexp}}) : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{b} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AExp.BTrue}{\coqdocconstructor{BTrue}}       \ensuremath{\Rightarrow} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AExp.BFalse}{\coqdocconstructor{BFalse}}      \ensuremath{\Rightarrow} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AExp.BEq}{\coqdocconstructor{BEq}} \coqdocvar{a1} \coqdocvar{a2}   \ensuremath{\Rightarrow} \coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{(}}\coqref{LF.Imp.AExp.aeval}{\coqdocdefinition{aeval}} \coqdocvar{a1}\coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{=?}} \coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{(}}\coqref{LF.Imp.AExp.aeval}{\coqdocdefinition{aeval}} \coqdocvar{a2}\coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AExp.BLe}{\coqdocconstructor{BLe}} \coqdocvar{a1} \coqdocvar{a2}   \ensuremath{\Rightarrow} \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{(}}\coqref{LF.Imp.AExp.aeval}{\coqdocdefinition{aeval}} \coqdocvar{a1}\coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{<=?}} \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{(}}\coqref{LF.Imp.AExp.aeval}{\coqdocdefinition{aeval}} \coqdocvar{a2}\coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AExp.BNot}{\coqdocconstructor{BNot}} \coqdocvar{b1}     \ensuremath{\Rightarrow} \coqexternalref{negb}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{negb}} (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvar{b1})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AExp.BAnd}{\coqdocconstructor{BAnd}} \coqdocvar{b1} \coqdocvar{b2}  \ensuremath{\Rightarrow} \coqexternalref{andb}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{andb}} (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvar{b1}) (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvar{b2})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{优化}



 我们尚未定义太多东西，不过从这些定义出发，已经能前进不少了。
    假设我们定义了一个接收算术表达式并对它稍微进行化简的函数，即将所有的
    0 + \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}}（如 (\coqref{LF.Imp.APlus}{\coqdocconstructor{APlus}} (\coqref{LF.Imp.ANum}{\coqdocconstructor{ANum}} 0) \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}}）化简为 \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Imp.AExp.optimize 0plus}{optimize\_0plus}{\coqdocdefinition{optimize\_0plus}} (\coqdocvar{a}:\coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}}) : \coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{a} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AExp.ANum}{\coqdocconstructor{ANum}} \coqdocvar{n} \ensuremath{\Rightarrow} \coqref{LF.Imp.AExp.ANum}{\coqdocconstructor{ANum}} \coqdocvar{n}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AExp.APlus}{\coqdocconstructor{APlus}} (\coqref{LF.Imp.AExp.ANum}{\coqdocconstructor{ANum}} 0) \coqdocvar{e2} \ensuremath{\Rightarrow} \coqref{LF.Imp.optimize 0plus}{\coqdocdefinition{optimize\_0plus}} \coqdocvar{e2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AExp.APlus}{\coqdocconstructor{APlus}}  \coqdocvar{e1} \coqdocvar{e2} \ensuremath{\Rightarrow} \coqref{LF.Imp.AExp.APlus}{\coqdocconstructor{APlus}}  (\coqref{LF.Imp.optimize 0plus}{\coqdocdefinition{optimize\_0plus}} \coqdocvar{e1}) (\coqref{LF.Imp.optimize 0plus}{\coqdocdefinition{optimize\_0plus}} \coqdocvar{e2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AExp.AMinus}{\coqdocconstructor{AMinus}} \coqdocvar{e1} \coqdocvar{e2} \ensuremath{\Rightarrow} \coqref{LF.Imp.AExp.AMinus}{\coqdocconstructor{AMinus}} (\coqref{LF.Imp.optimize 0plus}{\coqdocdefinition{optimize\_0plus}} \coqdocvar{e1}) (\coqref{LF.Imp.optimize 0plus}{\coqdocdefinition{optimize\_0plus}} \coqdocvar{e2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AExp.AMult}{\coqdocconstructor{AMult}}  \coqdocvar{e1} \coqdocvar{e2} \ensuremath{\Rightarrow} \coqref{LF.Imp.AExp.AMult}{\coqdocconstructor{AMult}}  (\coqref{LF.Imp.optimize 0plus}{\coqdocdefinition{optimize\_0plus}} \coqdocvar{e1}) (\coqref{LF.Imp.optimize 0plus}{\coqdocdefinition{optimize\_0plus}} \coqdocvar{e2})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
要保证我们的优化是正确的，可以在某些示例中测试它并观察其输出出否正确。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Imp.AExp.test optimize 0plus}{test\_optimize\_0plus}{\coqdocdefinition{test\_optimize\_0plus}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.AExp.optimize 0plus}{\coqdocdefinition{optimize\_0plus}} (\coqref{LF.Imp.AExp.APlus}{\coqdocconstructor{APlus}} (\coqref{LF.Imp.AExp.ANum}{\coqdocconstructor{ANum}} 2)\coqdoceol
\coqdocindent{12.00em}
(\coqref{LF.Imp.AExp.APlus}{\coqdocconstructor{APlus}} (\coqref{LF.Imp.AExp.ANum}{\coqdocconstructor{ANum}} 0)\coqdoceol
\coqdocindent{15.50em}
(\coqref{LF.Imp.AExp.APlus}{\coqdocconstructor{APlus}} (\coqref{LF.Imp.AExp.ANum}{\coqdocconstructor{ANum}} 0) (\coqref{LF.Imp.AExp.ANum}{\coqdocconstructor{ANum}} 1))))\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Imp.AExp.APlus}{\coqdocconstructor{APlus}} (\coqref{LF.Imp.AExp.ANum}{\coqdocconstructor{ANum}} 2) (\coqref{LF.Imp.AExp.ANum}{\coqdocconstructor{ANum}} 1).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
但如果要确保该优化的正确性，即优化后的表达式与原表达式的求值结果相同，
    那么我们应当证明它。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.AExp.optimize 0plus sound}{optimize\_0plus\_sound}{\coqdoclemma{optimize\_0plus\_sound}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{a},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.AExp.aeval}{\coqdocdefinition{aeval}} (\coqref{LF.Imp.AExp.optimize 0plus}{\coqdocdefinition{optimize\_0plus}} \coqdocvariable{a}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Imp.AExp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{a}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{a}. \coqdoctac{induction} \coqdocvar{a}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{destruct} \coqdocvar{a1} \coqdocvar{eqn}:\coqdocvar{Ea1}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{destruct} \coqdocvar{n} \coqdocvar{eqn}:\coqdocvar{En}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times}   \coqdoctac{simpl}. \coqdoctac{apply} \coqdocvar{IHa2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times}  \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{IHa2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{IHa1}. \coqdoctac{rewrite} \coqdocvar{IHa1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{IHa2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{IHa1}. \coqdoctac{rewrite} \coqdocvar{IHa1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{IHa2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{IHa1}. \coqdoctac{rewrite} \coqdocvar{IHa1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{IHa2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{IHa1}. \coqdoctac{rewrite} \coqdocvar{IHa2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{IHa1}. \coqdoctac{rewrite} \coqdocvar{IHa2}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Coq 自动化}



 上一个证明中的大量重复很让人烦躁。无论算术表达式的语言，
    还是证明优化的可靠性明显都更加复杂，因此它会成为一个真正的问题。


    目前为止，我们所有的证明都只使用了一点趁手的 Coq 的策略，
    而它自动构造部分证明的强大功能则完全被忽略了。本节引入了这样的一些功能，
    而在下一章中我们会看到更多。要使用它们需要耗费点精力 --
    Coq 的自动化是个强大的工具 -- 不过它能让我们从无聊、重复、
    底层的细节中解放出来，专注于更加复杂的定义和更加有趣的性质。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{泛策略}



 \textit{'泛策略（Tacticals）'}是 Coq 中的术语，它表示一个接受其它策略作为参数的策略，
    当然，你愿意的话也可以把它称为“高阶策略”。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsubsection{\texorpdfstring{\protect\coqdoctac{try}}{try} 泛策略}



 如果 \coqdocvariable{T} 是一个策略，那么 \coqdoctac{try} \coqdocvariable{T} 是一个和 \coqdocvariable{T} 一样的策略，只是如果
    \coqdocvariable{T} 失败的话，\coqdoctac{try} \coqdocvariable{T} 就会\textit{'成功地'}什么也不做（而非失败）。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.AExp.silly1}{silly1}{\coqdoclemma{silly1}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{ae}, \coqref{LF.Imp.AExp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{ae} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Imp.AExp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{ae}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{try} \coqdoctac{reflexivity}.  \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.AExp.silly2}{silly2}{\coqdoclemma{silly2}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{P} : \coqdockw{Prop}), \coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{HP}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{try} \coqdoctac{reflexivity}. \coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{HP}. \coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们并没有真正的理由在像这样的手动证明中使用 \coqdoctac{try}，不过在连同
    ; 泛策略一起进行自动化证明时它会非常有用，接下来我们来展示它。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsubsection{; 泛策略（简单形式）}



 在最常用的形式中，; 泛策略会接受两个策略作为参数。复合策略 \coqdocvariable{T};\coqdocvar{T'}
    会先执行 \coqdocvariable{T}，然后在 \coqdocvariable{T} 生成的\textit{'每个子目标'}中执行 \coqdocvar{T'}。 

 例如，考虑以下平凡的引理： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Imp.AExp.foo}{foo}{\coqdoclemma{foo}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, 0 \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{<=?}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{n}.\coqdoceol
\coqdocindent{2.00em}
-  \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
-  \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们可以用 ; 泛策略来化简它： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Imp.AExp.foo'}{foo'}{\coqdoclemma{foo'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, 0 \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{<=?}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{n};\coqdoceol
\coqdocindent{1.00em}
\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl};\coqdoceol
\coqdocindent{1.00em}
\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdoctac{try} 配合 ; 一同使用，我们可以从之前证明中麻烦的重复里解脱出来。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.AExp.optimize 0plus sound'}{optimize\_0plus\_sound'}{\coqdoclemma{optimize\_0plus\_sound'}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{a},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.AExp.aeval}{\coqdocdefinition{aeval}} (\coqref{LF.Imp.AExp.optimize 0plus}{\coqdocdefinition{optimize\_0plus}} \coqdocvariable{a}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Imp.AExp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{a}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{a}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{a};\coqdoceol
\coqdocindent{2.00em}
\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{try} (\coqdoctac{simpl}; \coqdoctac{rewrite} \coqdocvar{IHa1}; \coqdoctac{rewrite} \coqdocvar{IHa2}; \coqdoctac{reflexivity}).\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{a1} \coqdocvar{eqn}:\coqdocvar{Ea1};\coqdoceol
\coqdocindent{3.00em}
\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{try} (\coqdoctac{simpl}; \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{IHa1}; \coqdoctac{rewrite} \coqdocvar{IHa1};\coqdoceol
\coqdocindent{5.50em}
\coqdoctac{rewrite} \coqdocvar{IHa2}; \coqdoctac{reflexivity}).\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{destruct} \coqdocvar{n} \coqdocvar{eqn}:\coqdocvar{En};\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl}; \coqdoctac{rewrite} \coqdocvar{IHa2}; \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Coq 专家经常在像 \coqdoctac{induction} 这样的策略之后使用这种“...; \coqdoctac{try}... ”的习语，
    以便一次处理所有相似的情况。自然，在非形式化证明中也有同样的做法。
    例如，以下对该优化定理的非形式化证明与形式化证明的结构一致：


    \textit{'定理'}：对于所有的算术表达式 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}}，


       aeval (optimize\_0plus a) = aeval a.


    \textit{'证明'}：对 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 进行归纳。大部分情况根据即可 IH 得证。其余情况如下：



\begin{itemize}
\item  假设设对于某些 \coqdocvariable{n} 有 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} = \coqref{LF.Imp.ANum}{\coqdocconstructor{ANum}} \coqdocvariable{n} for some \coqdocvariable{n}。我们必须证明


          aeval (optimize\_0plus (ANum n)) = aeval (ANum n).


        这一点根据 \coqref{LF.Imp.AExp.optimize 0plus}{\coqdocdefinition{optimize\_0plus}} 的定义即可得证。



\item  假设对于某些 \coqdocvariable{a1} 和 \coqdocvariable{a2} 有 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} = \coqref{LF.Imp.APlus}{\coqdocconstructor{APlus}} \coqdocvariable{a1} \coqdocvariable{a2}。我们必须证明


          aeval (optimize\_0plus (APlus a1 a2)) = aeval (APlus a1 a2).


        考虑 \coqdocvariable{a1} 可能的形式。对于大部分的情况，\coqref{LF.Imp.AExp.optimize 0plus}{\coqdocdefinition{optimize\_0plus}}
        会对子表达式简单地递归调用自身并重建一个与 \coqdocvariable{a1} 形式相同的新表达式；
        在这些情况下，其结果根据 IH 即可得证。


        对某些 \coqdocvariable{n} 有 \coqdocvariable{a1} = \coqref{LF.Imp.ANum}{\coqdocconstructor{ANum}} \coqdocvariable{n} 是个有趣的情况。若 \coqdocvariable{n} = 0，则


          optimize\_0plus (APlus a1 a2) = optimize\_0plus a2


        而 \coqdocvariable{a2} 的 IH 正是所需的。另一方面，如果对于某些 \coqdocvariable{n'} 有 \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}
        那么同样 \coqref{LF.Imp.AExp.optimize 0plus}{\coqdocdefinition{optimize\_0plus}} 会简单地递归调用自身，而其结果根据
        IH 即可得证。 \ensuremath{\Box} 
\end{itemize}


 然而，此证明仍然可以改进：第一种情况（\coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} = \coqref{LF.Imp.ANum}{\coqdocconstructor{ANum}} \coqdocvariable{n}）非常平凡，
    甚至比我们根据归纳假设化简的那个情况还要平凡，然而我们却把它完整地写了出来。
    为了更加清楚，最好把它去掉，然后在最上面说：“大部分情况可以立即得出，
    或直接从归纳假设得出。唯一有趣的情况是 \coqref{LF.Imp.APlus}{\coqdocconstructor{APlus}}...”
    我们也可以在形式化证明中做出这种改进，方法如下： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.AExp.optimize 0plus sound''}{optimize\_0plus\_sound'{}'}{\coqdoclemma{optimize\_0plus\_sound'{}'}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{a},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.AExp.aeval}{\coqdocdefinition{aeval}} (\coqref{LF.Imp.AExp.optimize 0plus}{\coqdocdefinition{optimize\_0plus}} \coqdocvariable{a}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Imp.AExp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{a}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{a}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{a};\coqdoceol
\coqdocindent{2.00em}
\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{try} (\coqdoctac{simpl}; \coqdoctac{rewrite} \coqdocvar{IHa1}; \coqdoctac{rewrite} \coqdocvar{IHa2}; \coqdoctac{reflexivity});\coqdoceol
\coqdocindent{2.00em}
\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{try} \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{a1}; \coqdoctac{try} (\coqdoctac{simpl}; \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{IHa1}; \coqdoctac{rewrite} \coqdocvar{IHa1};\coqdoceol
\coqdocindent{11.00em}
\coqdoctac{rewrite} \coqdocvar{IHa2}; \coqdoctac{reflexivity}).\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{destruct} \coqdocvar{n};\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl}; \coqdoctac{rewrite} \coqdocvar{IHa2}; \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{; 泛策略（一般形式）}



 ; 除了我们前面见到的简单形式 \coqdocvariable{T};\coqdocvar{T'} 外，还有种更一般的形式。
    如果 \coqdocvariable{T}, \coqdocvar{T1}, ..., \coqdocvar{Tn} 都是策略，那么


      T; \coqdocvar{T1} \ensuremath{|} \coqdocvar{T2} \ensuremath{|} ... \ensuremath{|} \coqdocvar{Tn}


   就是一个首先执行 \coqdocvariable{T}，然后在 \coqdocvariable{T} 生成的第一个字母表中执行 \coqdocvar{T1}，
   在第二个子目标中执行 \coqdocvar{T2}，以此类推。


   因此，\coqdocvariable{T};\coqdocvar{T'} 只是一种当所有 \coqdocvar{Ti} 为相同策略时的特殊记法，即，\coqdocvariable{T};\coqdocvar{T'}
   是以下形式的简写：


      T; \coqdocvar{T'} \ensuremath{|} \coqdocvar{T'} \ensuremath{|} ... \ensuremath{|} \coqdocvar{T'}
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsubsection{\texorpdfstring{\protect\coqdoctac{repeat}}{repeat} 泛策略}



 \coqdoctac{repeat} 泛策略接受另一个测略并重复应用它直至失败。以下示例用
    \coqdoctac{repeat} 证明了 10 在一个长列表中。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.AExp.In10}{In10}{\coqdoclemma{In10}} : \coqexternalref{In}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} 10 \coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[}}1\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}2\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}3\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}4\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}5\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}6\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}7\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}8\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}9\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}10\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} (\coqdoctac{try} (\coqdoctac{left}; \coqdoctac{reflexivity}); \coqdoctac{right}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
策略 \coqdoctac{repeat} \coqdocvariable{T} 永远不会失败：如果策略 \coqdocvariable{T} 并未应用到原始目标上，
    那么 \coqdoctac{repeat} 仍然会成功而不改变原始目标（即，它重复了零次）。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.AExp.In10'}{In10'}{\coqdoclemma{In10'}} : \coqexternalref{In}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocdefinition{In}} 10 \coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[}}1\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}2\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}3\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}4\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}5\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}6\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}7\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}8\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}9\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}10\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} (\coqdoctac{left}; \coqdoctac{reflexivity}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} (\coqdoctac{right}; \coqdoctac{try} (\coqdoctac{left}; \coqdoctac{reflexivity})).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
策略 \coqdoctac{repeat} \coqdocvariable{T} 应用 \coqdocvariable{T} 的次数也没有任何上界。如果 \coqdocvariable{T} 策略总是成功，
    那么重复 \coqdocvariable{T} 会永远循环（例如 \coqdoctac{repeat} \coqdoctac{simpl} 会一直循环，因为 \coqdoctac{simpl}
    总是会成功）。虽然 Coq 的主语言 Gallina 中的求值保证会终止，
    然而策略却不会！然而这并不会影响 Coq 的逻辑一致性，因为 \coqdoctac{repeat}
    和其它策略的工作就是指导 Coq 去构造证明；如果构造过程发散（即不停机），
    那就意味着我们构造证明失败，而非构造出了错误的证明。 

\paragraph{练习：3 星, standard (optimize\_0plus\_b\_sound)}




    由于 \coqref{LF.Imp.AExp.optimize 0plus}{\coqdocdefinition{optimize\_0plus}} 变换不会改变 \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}} 的值，
    因此我们可以将它应用到所有出现在 \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}} 中的 \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}} 上而不改变
    \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}} 的值。请编写一个对 \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}} 执行此变换的函数，并证明它的可靠性。
    利用我们刚学过的泛策略来构造一个尽可能优雅的证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Imp.AExp.optimize 0plus b}{optimize\_0plus\_b}{\coqdocdefinition{optimize\_0plus\_b}} (\coqdocvar{b} : \coqref{LF.Imp.AExp.bexp}{\coqdocinductive{bexp}}) : \coqref{LF.Imp.AExp.bexp}{\coqdocinductive{bexp}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.AExp.optimize 0plus b sound}{optimize\_0plus\_b\_sound}{\coqdoclemma{optimize\_0plus\_b\_sound}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.AExp.beval}{\coqdocdefinition{beval}} (\coqref{LF.Imp.AExp.optimize 0plus b}{\coqdocaxiom{optimize\_0plus\_b}} \coqdocvariable{b}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Imp.AExp.beval}{\coqdocdefinition{beval}} \coqdocvariable{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：4 星, standard, optional (optimize)}




    \textit{'设计练习'}：\coqref{LF.Imp.AExp.optimize 0plus}{\coqdocdefinition{optimize\_0plus}} 函数只是众多算术和布尔表达式优化的方法之一。
    请编写一个更加聪明的优化器并证明它的正确性。（最容易的方法就是从小处着手：
    一开始只添加单个简单的优化并证明它的正确性，然后逐渐增加其它更有趣的优化。） \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\subsection{定义新的策略记法}



 Coq 还提供了几种对策略脚本进行“编程”的方式。



\begin{itemize}
\item  下面展示的 \coqdockw{Tactic} \coqdockw{Notation} 习语给出了定义“简写策略”的简便方式，
      它将多个策略封装成单条指令。



\item  对于更加复杂的编程，Coq 提供了内建的 \coqdockw{Ltac} 语言，
      它带有可以检查和修改证明状态的原语。由于详情太过复杂，这里不便展开
      （\coqdockw{Ltac} 通常也被认为不是 Coq 的设计中最美妙的部分！），
      你可以在参考手册和其它关于 Coq 的书中找到它，Coq 的标准库中有很多
      \coqdockw{Ltac} 定义的例子，你也可以参考它们。



\item  还有 OCaml 的 API，它可以构建从底层访问 Coq 内部结构的策略，
      不过普通 Coq 用于很少需要麻烦它。

\end{itemize}


    \coqdockw{Tactic} \coqdockw{Notation} 机制是最易于掌握的，它为很多用途提供了强大的能力。
    下面就是个例子。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Tactic Notation} "simpl\_and\_try" \coqdocvar{tactic}(\coqdocvar{c}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl};\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{try} \coqdocvar{c}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这定义了一个新的名为 \coqdocvar{simpl\_and\_try} 的泛策略，它接受一个策略 \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}}
    作为参数，其定义等价于策略 \coqdoctac{simpl}; \coqdoctac{try} \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}}。现在在证明中写
    “\coqdocvar{simpl\_and\_try} \coqdoctac{reflexivity}.”和写“\coqdoctac{simpl}; \coqdoctac{try} \coqdoctac{reflexivity}.”是一样的。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{\texorpdfstring{\protect\coqdoctac{omega}}{omega} 策略}



 \coqdoctac{omega} 实现了一种决策过程，它是名为\textit{'Presburger 算术'}的一阶逻辑的一个子集。
    它基于启发自 William Pugh \coqdocvar{Pugh} 1991 (in Bib.v) 的 Omega 算法。


    如果证明目标是由以下元素构成的式子：



\begin{itemize}
\item  数值常量、加法（+ 和 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}}）、减法（- 和 \coqref{LF.Basics.NatPlayground.pred}{\coqdocdefinition{pred}}）以及常量乘法
        （这就是 Presburger 算术的构成要素）



\item  相等关系（= 和 \ensuremath{\not=}）和序（\ensuremath{\le}）



\item  逻辑连结 \ensuremath{\land}、\ensuremath{\lor}、\ensuremath{\lnot} 和 \ensuremath{\rightarrow}

\end{itemize}


    那么调用 \coqdoctac{omega} 要么会解决该证明目标，要么就会失败，这意味着该目标为假
    （目标\textit{'不满足'}此形式也会失败。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Imp.AExp.silly presburger example}{silly\_presburger\_example}{\coqdocdefinition{silly\_presburger\_example}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{o} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{o} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 3 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{p} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 3 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{m} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{omega}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（注意本文件顶部 \coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqdoclibrary{omega.Omega}.。）\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{更多方便的策略}



 最后，下面列出一些方便的其它技巧。



\begin{itemize}
\item  \coqdoctac{clear} \coqdocvariable{H}：从上下文中删除前提 \coqdocvariable{H}。



\item  \coqdoctac{subst} \coqdocvariable{x}：对于变量 \coqdocvariable{x}，在上下文中查找假设 \coqdocvariable{x} = \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} 或 \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} = \coqdocvariable{x}，
       将整个上下文和当前目标中的所有 \coqdocvariable{x} 替换为 \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} 并清除该假设。



\item  \coqdoctac{subst}：替换掉\textit{'所有'}形如 \coqdocvariable{x} = \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} 或 \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} = \coqdocvariable{x} 的假设（其中 \coqdocvariable{x} 为变量）。



\item  \coqdoctac{rename}... \coqdocvar{into}...：更改证明上下文中前提的名字。例如，
       如果上下文中包含名为 \coqdocvariable{x} 的变量，那么 \coqdoctac{rename} \coqdocvariable{x} \coqdocvar{into} \coqdocvariable{y}
       就会将所有出现的 \coqdocvariable{x} 重命名为 \coqdocvariable{y}。



\item  \coqdoctac{assumption}：尝试在上下文中查找完全匹配目标的前提 \coqdocvariable{H}。
       如果找到了，那么其行为与 \coqdoctac{apply} \coqdocvariable{H} 相同。



\item  \coqdocvar{contradiction}：尝试在当前上下文中查找逻辑等价于 \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}} 的前提 \coqdocvariable{H}。
      如果找到了，就解决该目标。



\item  \coqdoctac{constructor}：尝试在当前环境中的 \coqdockw{Inductive}
       定义中查找可用于解决当前目标的构造子 \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}}。如果找到了，那么其行为与
       \coqdoctac{apply} \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 相同。

\end{itemize}


    我们之后会看到所有它们的例子。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{求值作为关系}



 我们已经展示了用 \coqdockw{Fixpoint} 定义的函数 \coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} 和 \coqref{LF.Imp.beval}{\coqdocdefinition{beval}}。
    另一种通常更加灵活的思考求值的方式，就是把它当做表达式与其值的\textit{'关系'}。
    （译注：求值关系不满足对称性，因为它是有方向的。）
    这会自然地导出如下这种算术表达式的 \coqdockw{Inductive} 定义... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Imp.AExp.aevalR first try}{aevalR\_first\_try}{\coqdocmodule{aevalR\_first\_try}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.AExp.aevalR first try.aevalR}{aevalR}{\coqdocinductive{aevalR}} : \coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.aevalR first try.E ANum}{E\_ANum}{\coqdocconstructor{E\_ANum}} \coqdocvar{n} :\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} (\coqref{LF.Imp.AExp.ANum}{\coqdocconstructor{ANum}} \coqdocvariable{n}) \coqdocvariable{n}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.aevalR first try.E APlus}{E\_APlus}{\coqdocconstructor{E\_APlus}} (\coqdocvar{e1} \coqdocvar{e2}: \coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}}) (\coqdocvar{n1} \coqdocvar{n2}: \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} \coqdocvariable{e1} \coqdocvariable{n1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} \coqdocvariable{e2} \coqdocvariable{n2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} (\coqref{LF.Imp.AExp.APlus}{\coqdocconstructor{APlus}} \coqdocvariable{e1} \coqdocvariable{e2}) (\coqdocvariable{n1} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.aevalR first try.E AMinus}{E\_AMinus}{\coqdocconstructor{E\_AMinus}} (\coqdocvar{e1} \coqdocvar{e2}: \coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}}) (\coqdocvar{n1} \coqdocvar{n2}: \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} \coqdocvariable{e1} \coqdocvariable{n1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} \coqdocvariable{e2} \coqdocvariable{n2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} (\coqref{LF.Imp.AExp.AMinus}{\coqdocconstructor{AMinus}} \coqdocvariable{e1} \coqdocvariable{e2}) (\coqdocvariable{n1} \coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{-}} \coqdocvariable{n2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.aevalR first try.E AMult}{E\_AMult}{\coqdocconstructor{E\_AMult}} (\coqdocvar{e1} \coqdocvar{e2}: \coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}}) (\coqdocvar{n1} \coqdocvar{n2}: \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} \coqdocvariable{e1} \coqdocvariable{n1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} \coqdocvariable{e2} \coqdocvariable{n2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} (\coqref{LF.Imp.AExp.AMult}{\coqdocconstructor{AMult}} \coqdocvariable{e1} \coqdocvariable{e2}) (\coqdocvariable{n1} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{n2}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Imp.AExp.aevalR first try.TooHardToRead}{TooHardToRead}{\coqdocmodule{TooHardToRead}}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.AExp.aevalR first try.TooHardToRead.aevalR}{aevalR}{\coqdocinductive{aevalR}} : \coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.aevalR first try.TooHardToRead.E ANum}{E\_ANum}{\coqdocconstructor{E\_ANum}} \coqdocvar{n} :\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} (\coqref{LF.Imp.AExp.ANum}{\coqdocconstructor{ANum}} \coqdocvariable{n}) \coqdocvariable{n}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.aevalR first try.TooHardToRead.E APlus}{E\_APlus}{\coqdocconstructor{E\_APlus}} (\coqdocvar{e1} \coqdocvar{e2}: \coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}}) (\coqdocvar{n1} \coqdocvar{n2}: \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{H1} : \coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} \coqdocvariable{e1} \coqdocvariable{n1})\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{H2} : \coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} \coqdocvariable{e2} \coqdocvariable{n2}) :\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} (\coqref{LF.Imp.AExp.APlus}{\coqdocconstructor{APlus}} \coqdocvariable{e1} \coqdocvariable{e2}) (\coqdocvariable{n1} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.aevalR first try.TooHardToRead.E AMinus}{E\_AMinus}{\coqdocconstructor{E\_AMinus}} (\coqdocvar{e1} \coqdocvar{e2}: \coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}}) (\coqdocvar{n1} \coqdocvar{n2}: \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{H1} : \coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} \coqdocvariable{e1} \coqdocvariable{n1})\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{H2} : \coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} \coqdocvariable{e2} \coqdocvariable{n2}) :\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} (\coqref{LF.Imp.AExp.AMinus}{\coqdocconstructor{AMinus}} \coqdocvariable{e1} \coqdocvariable{e2}) (\coqdocvariable{n1} \coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{-}} \coqdocvariable{n2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.aevalR first try.TooHardToRead.E AMult}{E\_AMult}{\coqdocconstructor{E\_AMult}} (\coqdocvar{e1} \coqdocvar{e2}: \coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}}) (\coqdocvar{n1} \coqdocvar{n2}: \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{H1} : \coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} \coqdocvariable{e1} \coqdocvariable{n1})\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{H2} : \coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} \coqdocvariable{e2} \coqdocvariable{n2}) :\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} (\coqref{LF.Imp.AExp.AMult}{\coqdocconstructor{AMult}} \coqdocvariable{e1} \coqdocvariable{e2}) (\coqdocvariable{n1} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{n2}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Instead, we've chosen to leave the hypotheses anonymous, just
    giving their types.  This style gives us less control over the
    names that Coq chooses during proofs involving \coqref{LF.Imp.aevalR extended.aevalR}{\coqdocinductive{aevalR}}, but it
    makes the definition itself quite a bit lighter. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.Imp.AExp.aevalR first try.TooHardToRead}{\coqdocmodule{TooHardToRead}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
如果 \coqref{LF.Imp.aevalR extended.aevalR}{\coqdocinductive{aevalR}} 有中缀记法的话会很方便。我们用 \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} ==> \coqdocvariable{n}
    表示算术表达式 \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} 求值为 \coqdocvariable{n}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.AExp.aevalR first try.::type scope:x '==>' x}{"}{"}e '==>' n"\coqdoceol
\coqdocindent{4.50em}
:= (\coqref{LF.Imp.AExp.aevalR first try.aevalR}{\coqdocinductive{aevalR}} \coqdocvar{e} \coqdocvar{n})\coqdoceol
\coqdocindent{6.00em}
(\coqdoctac{at} \coqdockw{level} 50, \coqdoctac{left} \coqdockw{associativity})\coqdoceol
\coqdocindent{4.50em}
: \coqdocvar{type\_scope}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.Imp.AExp.aevalR first try}{\coqdocmodule{aevalR\_first\_try}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
实际上，Coq 提供了一种在 \coqref{LF.Imp.aevalR extended.aevalR}{\coqdocinductive{aevalR}} 自身内使用此记法的方式。
    这样可以避免在进行涉及 \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} ==> \coqdocvariable{n} 形式的证明时，必须向前引用
    \coqref{LF.Imp.aevalR extended.aevalR}{\coqdocinductive{aevalR}} \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} \coqdocvariable{n} 形式的定义的情况，从而减少混淆。


    具体做法是，我们先“保留”该记法，然后在给出定义的同时声明它的意义。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Reserved Notation} "e '==>' n" (\coqdoctac{at} \coqdockw{level} 90, \coqdoctac{left} \coqdockw{associativity}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.AExp.aevalR}{aevalR}{\coqdocinductive{aevalR}} : \coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.E ANum}{E\_ANum}{\coqdocconstructor{E\_ANum}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{(}}\coqref{LF.Imp.AExp.ANum}{\coqdocconstructor{ANum}} \coqdocvariable{n}\coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{)}} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.E APlus}{E\_APlus}{\coqdocconstructor{E\_APlus}} (\coqdocvar{e1} \coqdocvar{e2} : \coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}}) (\coqdocvar{n1} \coqdocvar{n2} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{e1} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n1}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{e2} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n2}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{(}}\coqref{LF.Imp.AExp.APlus}{\coqdocconstructor{APlus}} \coqdocvariable{e1} \coqdocvariable{e2}\coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{)}} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{(}}\coqdocvariable{n1} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n2}\coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.E AMinus}{E\_AMinus}{\coqdocconstructor{E\_AMinus}} (\coqdocvar{e1} \coqdocvar{e2} : \coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}}) (\coqdocvar{n1} \coqdocvar{n2} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{e1} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n1}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{e2} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n2}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{(}}\coqref{LF.Imp.AExp.AMinus}{\coqdocconstructor{AMinus}} \coqdocvariable{e1} \coqdocvariable{e2}\coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{)}} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{(}}\coqdocvariable{n1} \coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{-}} \coqdocvariable{n2}\coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AExp.E AMult}{E\_AMult}{\coqdocconstructor{E\_AMult}} (\coqdocvar{e1} \coqdocvar{e2} : \coqref{LF.Imp.AExp.aexp}{\coqdocinductive{aexp}}) (\coqdocvar{n1} \coqdocvar{n2} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{e1} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n1}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{e2} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n2}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{(}}\coqref{LF.Imp.AExp.AMult}{\coqdocconstructor{AMult}} \coqdocvariable{e1} \coqdocvariable{e2}\coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{)}} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{(}}\coqdocvariable{n1} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{n2}\coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{)}}\coqdoceol
\coqdocnoindent
\coqdoceol
\coqdocindent{1.00em}
\coqdockw{where} \coqdef{LF.Imp.AExp.::type scope:x '==>' x}{"}{"}e '==>' n" := (\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} \coqdocvar{e} \coqdocvar{n}) : \coqdocvar{type\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{推理规则的记法}



 在非形式化的讨论中，将 \coqref{LF.Imp.aevalR extended.aevalR}{\coqdocinductive{aevalR}} 和类似的关系写成更加易读的
    \textit{'推理规则（Inference Rule）'}的图像形式会十分方便，
    其中横线上方的前提证明了横线下方的结论是正确的（我们已经在
    \coqdoclibrary{IndProp} 一章中见过它们了）。 

 例如，构造子 \coqref{LF.Imp.aevalR extended.E APlus}{\coqdocconstructor{E\_APlus}}...


      | E\_APlus : forall (e1 e2: aexp) (n1 n2: nat),
          aevalR e1 n1 ->
          aevalR e2 n2 ->
          aevalR (APlus e1 e2) (n1 + n2)


    ...的推理规则写作：


                               e1 ==> n1
                               e2 ==> n2
\par
\noindent\hrulefill\par
\noindent{}                (E\_APlus)
                         APlus e1 e2 ==> n1+n2


 形式上来说，推理规则没什么深刻的含义：它们只是蕴含关系。
    你可以将右侧的规则名看做构造子名，将横线上每个前提见的换行（以及横线本身）
    看做 \ensuremath{\rightarrow}。规则中涉及的所有变量（如 \coqdocvariable{e1}、\coqdocvariable{n1} 等）从一开始都是全称量化的。
    （这种变量通常称为\textit{'元变量（Metavariables）'}，以区别于我们在语言中定义的变量。
    目前，我们的算术表达式中还不包含变量，不过之后会加入它们。）
    整个规则集合都被认为包裹在 \coqdockw{Inductive} 声明中。在非正式的叙述中，
    这一点要么会忽略，要么会通过类似于“令 \coqref{LF.Imp.aevalR extended.aevalR}{\coqdocinductive{aevalR}} 为对以下规则封闭的最小关系...”
    的句子来表述。 

 例如，==> 是对以下规则封闭的最小关系：
\par
\noindent\hrulefill\par
\noindent{}                               (E\_ANum)
                             ANum n ==> n


                               e1 ==> n1
                               e2 ==> n2
\par
\noindent\hrulefill\par
\noindent{}                         (E\_APlus)
                         APlus e1 e2 ==> n1+n2


                               e1 ==> n1
                               e2 ==> n2
\par
\noindent\hrulefill\par
\noindent{}                        (E\_AMinus)
                        AMinus e1 e2 ==> n1-n2


                               e1 ==> n1
                               e2 ==> n2
\par
\noindent\hrulefill\par
\noindent{}                         (E\_AMult)
                         AMult e1 e2 ==> n1*n2


\paragraph{练习：1 星, standard, optional (beval\_rules)}




    下面是 Coq 中 \coqref{LF.Imp.beval}{\coqdocdefinition{beval}} 函数的定义：


  Fixpoint beval (e : bexp) : bool :=
    match e with
    | BTrue       => true
    | BFalse      => false
    | BEq a1 a2   => (aeval a1) =? (aeval a2)
    | BLe a1 a2   => (aeval a1) <=? (aeval a2)
    | BNot b1     => negb (beval b1)
    | BAnd b1 b2  => andb (beval b1) (beval b2)
    end.


    请用推理规则记法将布尔求值的定义写成关系的形式。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.AExp.manual grade for beval rules}{manual\_grade\_for\_beval\_rules}{\coqdocdefinition{manual\_grade\_for\_beval\_rules}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{定义的等价关系}



 求值的函数式定义与关系式定义之间的一致性证明非常直观： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.AExp.aeval iff aevalR}{aeval\_iff\_aevalR}{\coqdoclemma{aeval\_iff\_aevalR}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{LF.Imp.AExp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{a} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{0.50em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{0.50em}
- \coqdoceol
\coqdocindent{1.50em}
\coqdoctac{intros} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{induction} \coqdocvar{H}; \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.50em}
+ \coqdoceol
\coqdocindent{2.50em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.50em}
+ \coqdoceol
\coqdocindent{2.50em}
\coqdoctac{rewrite} \coqdocvar{IHaevalR1}. \coqdoctac{rewrite} \coqdocvar{IHaevalR2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.50em}
+ \coqdoceol
\coqdocindent{2.50em}
\coqdoctac{rewrite} \coqdocvar{IHaevalR1}. \coqdoctac{rewrite} \coqdocvar{IHaevalR2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.50em}
+ \coqdoceol
\coqdocindent{2.50em}
\coqdoctac{rewrite} \coqdocvar{IHaevalR1}. \coqdoctac{rewrite} \coqdocvar{IHaevalR2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{0.50em}
- \coqdoceol
\coqdocindent{1.50em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{induction} \coqdocvar{a};\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl}; \coqdoctac{intros}; \coqdoctac{subst}.\coqdoceol
\coqdocindent{1.50em}
+ \coqdoceol
\coqdocindent{2.50em}
\coqdoctac{apply} \coqref{LF.Imp.AExp.E ANum}{\coqdocconstructor{E\_ANum}}.\coqdoceol
\coqdocindent{1.50em}
+ \coqdoceol
\coqdocindent{2.50em}
\coqdoctac{apply} \coqref{LF.Imp.AExp.E APlus}{\coqdocconstructor{E\_APlus}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHa1}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHa2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.50em}
+ \coqdoceol
\coqdocindent{2.50em}
\coqdoctac{apply} \coqref{LF.Imp.AExp.E AMinus}{\coqdocconstructor{E\_AMinus}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHa1}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHa2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.50em}
+ \coqdoceol
\coqdocindent{2.50em}
\coqdoctac{apply} \coqref{LF.Imp.AExp.E AMult}{\coqdocconstructor{E\_AMult}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHa1}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHa2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们可以利用泛策略将此证明缩减到很短。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.AExp.aeval iff aevalR'}{aeval\_iff\_aevalR'}{\coqdoclemma{aeval\_iff\_aevalR'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a} \coqref{LF.Imp.AExp.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{LF.Imp.AExp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{a} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{H}; \coqdoctac{induction} \coqdocvar{H}; \coqdoctac{subst}; \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{n}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{induction} \coqdocvar{a}; \coqdoctac{simpl}; \coqdoctac{intros}; \coqdoctac{subst}; \coqdoctac{constructor};\coqdoceol
\coqdocindent{3.50em}
\coqdoctac{try} \coqdoctac{apply} \coqdocvar{IHa1}; \coqdoctac{try} \coqdoctac{apply} \coqdocvar{IHa2}; \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：3 星, standard (bevalR)}




    用和 \coqref{LF.Imp.aevalR extended.aevalR}{\coqdocinductive{aevalR}} 同样的方式写出关系 \coqref{LF.Imp.AExp.bevalR}{\coqdocinductive{bevalR}}，并证明它等价于 \coqref{LF.Imp.beval}{\coqdocdefinition{beval}}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.AExp.bevalR}{bevalR}{\coqdocinductive{bevalR}}: \coqref{LF.Imp.AExp.bexp}{\coqdocinductive{bexp}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocnoindent
\coqdoceol
\coqdocnoindent
.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Imp.AExp.beval iff bevalR}{beval\_iff\_bevalR}{\coqdoclemma{beval\_iff\_bevalR}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{bv},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.AExp.bevalR}{\coqdocinductive{bevalR}} \coqdocvariable{b} \coqdocvariable{bv} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{LF.Imp.AExp.beval}{\coqdocdefinition{beval}} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{bv}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.Imp.AExp}{\coqdocmodule{AExp}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{计算式定义与关系式定义}



 对于算术和布尔表达式求值的定义方式而言，函数式和关系式二者均可，
    选择哪种主要取决于品味。


    然而在某些情况下，求值的关系式定义比函数式定义要更好。  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Imp.aevalR division}{aevalR\_division}{\coqdocmodule{aevalR\_division}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
例如，假设我们想要用除法来扩展算术运算： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.aevalR division.aexp}{aexp}{\coqdocinductive{aexp}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR division.ANum}{ANum}{\coqdocconstructor{ANum}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR division.APlus}{APlus}{\coqdocconstructor{APlus}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR division.AMinus}{AMinus}{\coqdocconstructor{AMinus}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR division.AMult}{AMult}{\coqdocconstructor{AMult}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR division.ADiv}{ADiv}{\coqdocconstructor{ADiv}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}}). \coqdocemptyline
\end{coqdoccode}
扩展 \coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} 的定义来处理此讯算并不是很直观（我们要返回什么作为
    \coqref{LF.Imp.aevalR division.ADiv}{\coqdocconstructor{ADiv}} (\coqref{LF.Imp.ANum}{\coqdocconstructor{ANum}} 5) (\coqref{LF.Imp.ANum}{\coqdocconstructor{ANum}} 0) 的结果？）。然而扩展 \coqref{LF.Imp.aevalR extended.aevalR}{\coqdocinductive{aevalR}} 却很简单。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Reserved Notation} "e '==>' n"\coqdoceol
\coqdocindent{9.00em}
(\coqdoctac{at} \coqdockw{level} 90, \coqdoctac{left} \coqdockw{associativity}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.aevalR division.aevalR}{aevalR}{\coqdocinductive{aevalR}} : \coqref{LF.Imp.aevalR division.aexp}{\coqdocinductive{aexp}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR division.E ANum}{E\_ANum}{\coqdocconstructor{E\_ANum}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{(}}\coqref{LF.Imp.aevalR division.ANum}{\coqdocconstructor{ANum}} \coqdocvariable{n}\coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{)}} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR division.E APlus}{E\_APlus}{\coqdocconstructor{E\_APlus}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aevalR division.aexp}{\coqdocinductive{aexp}}) (\coqdocvar{n1} \coqdocvar{n2} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a1} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n1}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a2} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n2}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{(}}\coqref{LF.Imp.aevalR division.APlus}{\coqdocconstructor{APlus}} \coqdocvariable{a1} \coqdocvariable{a2}\coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{)}} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{(}}\coqdocvariable{n1} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n2}\coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR division.E AMinus}{E\_AMinus}{\coqdocconstructor{E\_AMinus}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aevalR division.aexp}{\coqdocinductive{aexp}}) (\coqdocvar{n1} \coqdocvar{n2} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a1} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n1}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a2} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n2}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{(}}\coqref{LF.Imp.aevalR division.AMinus}{\coqdocconstructor{AMinus}} \coqdocvariable{a1} \coqdocvariable{a2}\coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{)}} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{(}}\coqdocvariable{n1} \coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{-}} \coqdocvariable{n2}\coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR division.E AMult}{E\_AMult}{\coqdocconstructor{E\_AMult}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aevalR division.aexp}{\coqdocinductive{aexp}}) (\coqdocvar{n1} \coqdocvar{n2} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a1} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n1}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a2} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n2}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{(}}\coqref{LF.Imp.aevalR division.AMult}{\coqdocconstructor{AMult}} \coqdocvariable{a1} \coqdocvariable{a2}\coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{)}} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{(}}\coqdocvariable{n1} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{n2}\coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR division.E ADiv}{E\_ADiv}{\coqdocconstructor{E\_ADiv}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aevalR division.aexp}{\coqdocinductive{aexp}}) (\coqdocvar{n1} \coqdocvar{n2} \coqdocvar{n3} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :          \coqdoceol
\coqdocindent{3.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a1} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n1}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a2} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n2}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n2} \coqexternalref{::nat scope:x '>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{>}} 0\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{mult}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{mult}} \coqdocvariable{n2} \coqdocvariable{n3} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n1}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{(}}\coqref{LF.Imp.aevalR division.ADiv}{\coqdocconstructor{ADiv}} \coqdocvariable{a1} \coqdocvariable{a2}\coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{)}} \coqref{LF.Imp.aevalR division.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n3}\coqdoceol
\coqdocnoindent
\coqdoceol
\coqdocnoindent
\coqdockw{where} \coqdef{LF.Imp.aevalR division.::type scope:x '==>' x}{"}{"}a '==>' n" := (\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} \coqdocvar{a} \coqdocvar{n}) : \coqdocvar{type\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Notice that the evaluation relation has now become \textit{partial}:
    There are some inputs for which it simply does not specify an
    output. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.Imp.aevalR division}{\coqdocmodule{aevalR\_division}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Imp.aevalR extended}{aevalR\_extended}{\coqdocmodule{aevalR\_extended}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
假设我们想要用非确定性的数值生成器 \coqdocvar{any} 来扩展算术运算，
    该生成器会在求值时产生任何数。（注意，这不同于在所有可能的数值中作出
    \textit{'概率上的'}选择 -- 我们没有为结果指定任何具体的概率分布，只是说了
    \textit{'可能的结果'}。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Reserved Notation} "e '==>' n" (\coqdoctac{at} \coqdockw{level} 90, \coqdoctac{left} \coqdockw{associativity}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.aevalR extended.aexp}{aexp}{\coqdocinductive{aexp}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR extended.AAny}{AAny}{\coqdocconstructor{AAny}}                           \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR extended.ANum}{ANum}{\coqdocconstructor{ANum}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR extended.APlus}{APlus}{\coqdocconstructor{APlus}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR extended.AMinus}{AMinus}{\coqdocconstructor{AMinus}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR extended.AMult}{AMult}{\coqdocconstructor{AMult}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
同样，扩展 \coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} 会很棘手，因为现在的求值\textit{'并不是'}一个从表达式到数值的确定性函数，
    而扩展 \coqref{LF.Imp.aevalR extended.aevalR}{\coqdocinductive{aevalR}} 则无此问题... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.aevalR extended.aevalR}{aevalR}{\coqdocinductive{aevalR}} : \coqref{LF.Imp.aevalR extended.aexp}{\coqdocinductive{aexp}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR extended.E Any}{E\_Any}{\coqdocconstructor{E\_Any}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR extended.AAny}{\coqdocconstructor{AAny}} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n}                        \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR extended.E ANum}{E\_ANum}{\coqdocconstructor{E\_ANum}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{(}}\coqref{LF.Imp.aevalR extended.ANum}{\coqdocconstructor{ANum}} \coqdocvariable{n}\coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{)}} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR extended.E APlus}{E\_APlus}{\coqdocconstructor{E\_APlus}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aevalR extended.aexp}{\coqdocinductive{aexp}}) (\coqdocvar{n1} \coqdocvar{n2} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a1} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n1}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a2} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n2}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{(}}\coqref{LF.Imp.aevalR extended.APlus}{\coqdocconstructor{APlus}} \coqdocvariable{a1} \coqdocvariable{a2}\coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{)}} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{(}}\coqdocvariable{n1} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n2}\coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR extended.E AMinus}{E\_AMinus}{\coqdocconstructor{E\_AMinus}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aevalR extended.aexp}{\coqdocinductive{aexp}}) (\coqdocvar{n1} \coqdocvar{n2} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a1} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n1}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a2} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n2}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{(}}\coqref{LF.Imp.aevalR extended.AMinus}{\coqdocconstructor{AMinus}} \coqdocvariable{a1} \coqdocvariable{a2}\coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{)}} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{(}}\coqdocvariable{n1} \coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{-}} \coqdocvariable{n2}\coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.aevalR extended.E AMult}{E\_AMult}{\coqdocconstructor{E\_AMult}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aevalR extended.aexp}{\coqdocinductive{aexp}}) (\coqdocvar{n1} \coqdocvar{n2} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a1} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n1}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a2} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqdocvariable{n2}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{(}}\coqref{LF.Imp.aevalR extended.AMult}{\coqdocconstructor{AMult}} \coqdocvariable{a1} \coqdocvariable{a2}\coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{)}} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{==>}} \coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{(}}\coqdocvariable{n1} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{n2}\coqref{LF.Imp.aevalR extended.::type scope:x '==>' x}{\coqdocnotation{)}}\coqdoceol
\coqdocnoindent
\coqdoceol
\coqdocnoindent
\coqdockw{where} \coqdef{LF.Imp.aevalR extended.::type scope:x '==>' x}{"}{"}a '==>' n" := (\coqref{LF.Imp.aevalR}{\coqdocinductive{aevalR}} \coqdocvar{a} \coqdocvar{n}) : \coqdocvar{type\_scope}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.Imp.aevalR extended}{\coqdocmodule{aevalR\_extended}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这时你可能会问：默认情况下应该使用哪种风格？
    我们刚看到的例子表明关系式的定义反而比函数式的更加有用。
    对于这种定义的东西不太容易用函数表达，或者确实\textit{'不是'}函数的情况来说，
    明显别无选择。但如果两种风格均可行呢？


    关系式定义的一个优点是，它们会更优雅，更容易理解。


    另一个优点是，Coq 会根据 \coqdockw{Inductive} 定义自动生成不错的反演函数和归纳法则。 

 另一方面，函数式定义通常会更方便：

\begin{itemize}
\item  函数的定义是确定性的，且在所有参数上定义；而对于关系式定义来说，
       我们需要这些性质时必须显式地\textit{'证明'}它们。

\item  有了函数，我们还可以利用 Coq 的计算机制在证明过程中简化表达式。

\end{itemize}


    此外，函数还可以直接从 Gallina“提取”出 OCaml 或 Haskell 的可执行代码。 

 最终，选择视具体情况而定，或者只是品味问题。确实，在大型的 Coq
    开发中，经常可以看到一个定义同时给出了函数式和关系式\textit{'两种'}风格，
    加上一条陈述了二者等价的引理，以便在之后的证明中能够在这两种视角下随意切换。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{带变量的表达式}



 让我们回到 Imp 的定义上来。接下来我们要为算术和布尔表达式加上变量。
   为简单起见，我们会假设所有变量是都全局的，且它们只保存数值。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{状态}



 由于需要查找变量来获得它们的具体值，因此我们重用了 \coqdoclibrary{Maps}
    一章中的映射。我们在 Imp 中以 \coqref{LF.IndProp.string}{\coqdocdefinition{string}} 作为变量的类型。


    \textit{'机器的状态'}（简称\textit{'状态'}）表示程序执行中某一时刻\textit{'所有变量'}的值。 

 虽然任何给定的程序只会涉及有限数量的变量，不过为简单起见，
    我们假设状态为\textit{'所有的'}变量定义。状态会捕获内存中所有的信息。
    对 Imp 程序而言，由于每个变量都存储了一个自然数，
    因此我们可以将状态表示为一个从字符串到 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 的映射，并且用 0
    作为存储中的默认值。对于更复杂的编程语言，状态会有更多结构。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.state}{state}{\coqdocdefinition{state}} := \coqref{LF.Maps.total map}{\coqdocdefinition{total\_map}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{语法}



 我们只需为之前的算术表达式再加一个构造子就能添加变量： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.aexp}{aexp}{\coqdocinductive{aexp}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.ANum}{ANum}{\coqdocconstructor{ANum}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AId}{AId}{\coqdocconstructor{AId}} (\coqdocvar{x} :  \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}})             \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.APlus}{APlus}{\coqdocconstructor{APlus}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AMinus}{AMinus}{\coqdocconstructor{AMinus}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.AMult}{AMult}{\coqdocconstructor{AMult}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
为几个变量名定义简单记法能让示例更加易读： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.W}{W}{\coqdocdefinition{W}} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}} := "W".\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.X}{X}{\coqdocdefinition{X}} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}} := "X".\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.Y}{Y}{\coqdocdefinition{Y}} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}} := "Y".\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.Z}{Z}{\coqdocdefinition{Z}} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}} := "Z".\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（这种命名程序变量的约定（\coqref{LF.Imp.X}{\coqdocdefinition{X}}、\coqref{LF.Imp.Y}{\coqdocdefinition{Y}}、\coqref{LF.Basics.Z}{\coqdocconstructor{Z}}）
    与我们之前使用大写字母表示类型有点冲突。由于我们在本章中开发 Imp
    时没怎么使用多态，所以这种重载应该不会产生混淆。） 

 \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}} 的定义现在除了引用了新的 \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}} 之外并未更改： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.bexp}{bexp}{\coqdocinductive{bexp}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.BTrue}{BTrue}{\coqdocconstructor{BTrue}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.BFalse}{BFalse}{\coqdocconstructor{BFalse}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.BEq}{BEq}{\coqdocconstructor{BEq}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.BLe}{BLe}{\coqdocconstructor{BLe}} (\coqdocvar{a1} \coqdocvar{a2} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.BNot}{BNot}{\coqdocconstructor{BNot}} (\coqdocvar{b} : \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.BAnd}{BAnd}{\coqdocconstructor{BAnd}} (\coqdocvar{b1} \coqdocvar{b2} : \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{记法}




    要让 Imp 程序更易读写，我们引入了一些记法和隐式转换（Coercion）。


    你无需理解以下声明具体做了些什么。简言而之，Coq 中的 \coqdockw{Coercion}
    声明规定了一个函数（或构造子）可以被类型系统隐式地用于将一个输入类型的值
    转换成输出类型的值。例如，\coqref{LF.Imp.AId}{\coqdocconstructor{AId}} 的转换声明在需要一个 \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}}
    时直接使用普通的字符串，该字符串会被隐式地用 \coqref{LF.Imp.AId}{\coqdocconstructor{AId}} 来包装。 

 下列记法在具体的\textit{'记法作用域'}中声明，以避免与其它符号相同的解释相冲突。
    同样，你暂时也无需理解其中的细节，但要意识到到我们为 +、-、\ensuremath{\times}、=、\ensuremath{\le}
    等运算符定义了\textit{'新的'}解释十分重要。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Coercion} \coqref{LF.Imp.AId}{\coqdocconstructor{AId}} \coqref{LF.Imp.AId}{\coqdocconstructor{:}} \coqref{LF.Imp.AId}{\coqdocconstructor{string}} \coqref{LF.Imp.AId}{\coqdocconstructor{>->}} \coqref{LF.Imp.AId}{\coqdocconstructor{aexp}}.\coqdoceol
\coqdocnoindent
\coqdockw{Coercion} \coqref{LF.Imp.ANum}{\coqdocconstructor{ANum}} \coqref{LF.Imp.ANum}{\coqdocconstructor{:}} \coqref{LF.Imp.ANum}{\coqdocconstructor{nat}} \coqref{LF.Imp.ANum}{\coqdocconstructor{>->}} \coqref{LF.Imp.ANum}{\coqdocconstructor{aexp}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.bool to bexp}{bool\_to\_bexp}{\coqdocdefinition{bool\_to\_bexp}} (\coqdocvar{b} : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}}) : \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{if} \coqdocvariable{b} \coqdockw{then} \coqref{LF.Imp.BTrue}{\coqdocconstructor{BTrue}} \coqdockw{else} \coqref{LF.Imp.BFalse}{\coqdocconstructor{BFalse}}.\coqdoceol
\coqdocnoindent
\coqdockw{Coercion} \coqref{LF.Imp.bool to bexp}{\coqdocdefinition{bool\_to\_bexp}} \coqref{LF.Imp.bool to bexp}{\coqdocdefinition{:}} \coqref{LF.Imp.bool to bexp}{\coqdocdefinition{bool}} \coqref{LF.Imp.bool to bexp}{\coqdocdefinition{>->}} \coqref{LF.Imp.bool to bexp}{\coqdocdefinition{bexp}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Bind} \coqdockw{Scope} \coqdocvar{imp\_scope} \coqdockw{with} \coqdocvar{aexp}.\coqdoceol
\coqdocnoindent
\coqdockw{Bind} \coqdockw{Scope} \coqdocvar{imp\_scope} \coqdockw{with} \coqdocvar{bexp}.\coqdoceol
\coqdocnoindent
\coqdockw{Delimit} \coqdockw{Scope} \coqdocvar{imp\_scope} \coqdockw{with} \coqdocvar{imp}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.::imp scope:x '+' x}{"}{"}x + y" := (\coqref{LF.Imp.APlus}{\coqdocconstructor{APlus}} \coqdocvar{x} \coqdocvar{y}) (\coqdoctac{at} \coqdockw{level} 50, \coqdoctac{left} \coqdockw{associativity}) : \coqdocvar{imp\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.::imp scope:x '-' x}{"}{"}x - y" := (\coqref{LF.Imp.AMinus}{\coqdocconstructor{AMinus}} \coqdocvar{x} \coqdocvar{y}) (\coqdoctac{at} \coqdockw{level} 50, \coqdoctac{left} \coqdockw{associativity}) : \coqdocvar{imp\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.::imp scope:x '*' x}{"}{"}x * y" := (\coqref{LF.Imp.AMult}{\coqdocconstructor{AMult}} \coqdocvar{x} \coqdocvar{y}) (\coqdoctac{at} \coqdockw{level} 40, \coqdoctac{left} \coqdockw{associativity}) : \coqdocvar{imp\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.::imp scope:x '<=' x}{"}{"}x <= y" := (\coqref{LF.Imp.BLe}{\coqdocconstructor{BLe}} \coqdocvar{x} \coqdocvar{y}) (\coqdoctac{at} \coqdockw{level} 70, \coqdockw{no} \coqdockw{associativity}) : \coqdocvar{imp\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.::imp scope:x '=' x}{"}{"}x = y" := (\coqref{LF.Imp.BEq}{\coqdocconstructor{BEq}} \coqdocvar{x} \coqdocvar{y}) (\coqdoctac{at} \coqdockw{level} 70, \coqdockw{no} \coqdockw{associativity}) : \coqdocvar{imp\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.::imp scope:x 'x26x26' x}{"}{"}x \&\& y" := (\coqref{LF.Imp.BAnd}{\coqdocconstructor{BAnd}} \coqdocvar{x} \coqdocvar{y}) (\coqdoctac{at} \coqdockw{level} 40, \coqdoctac{left} \coqdockw{associativity}) : \coqdocvar{imp\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.::imp scope:'x7E' x}{"}{"}'\~{}' b" := (\coqref{LF.Imp.BNot}{\coqdocconstructor{BNot}} \coqdocvar{b}) (\coqdoctac{at} \coqdockw{level} 75, \coqdoctac{right} \coqdockw{associativity}) : \coqdocvar{imp\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在我们可以用 3 + (\coqref{LF.Imp.X}{\coqdocdefinition{X}} \ensuremath{\times} 2) 来代替 \coqref{LF.Imp.APlus}{\coqdocconstructor{APlus}} 3 (\coqref{LF.Imp.AMult}{\coqdocconstructor{AMult}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} 2) 了，同样可以用
    \coqref{LF.Basics.true}{\coqdocconstructor{true}} \&\& !(\coqref{LF.Imp.X}{\coqdocdefinition{X}} \ensuremath{\le} 4) 来代替 \coqref{LF.Imp.BAnd}{\coqdocconstructor{BAnd}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} (\coqref{LF.Imp.BNot}{\coqdocconstructor{BNot}} (\coqref{LF.Imp.BLe}{\coqdocconstructor{BLe}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} 4))。
    然而这只有在我们告诉 Coq 在恰当的记法作用域中用 \%\coqdocvar{imp} 解析我们的表达式时，
    或者当 Coq 知道该表达式的类型（\coqref{LF.Imp.aexp}{\coqdocinductive{aexp}} 或 \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}}）被「限定」为使用该记法作用域时才可行。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.example aexp}{example\_aexp}{\coqdocdefinition{example\_aexp}} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}} := 3 \coqref{LF.Imp.::imp scope:x '+' x}{\coqdocnotation{+}} \coqref{LF.Imp.::imp scope:x '+' x}{\coqdocnotation{(}}\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} 2\coqref{LF.Imp.::imp scope:x '+' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.example bexp}{example\_bexp}{\coqdocdefinition{example\_bexp}} : \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}} := \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqref{LF.Imp.::imp scope:x 'x26x26' x}{\coqdocnotation{\&\&}} \coqref{LF.Imp.::imp scope:'x7E' x}{\coqdocnotation{\~{}(}}\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '<=' x}{\coqdocnotation{\ensuremath{\le}}} 4\coqref{LF.Imp.::imp scope:'x7E' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
强制转换有一点不便之处，即它会略微提高人类推导表达式类型的难度。
    如果你感到有点困惑，请用 \coqdockw{Set} \coqdockw{Printing} \coqdocvar{Coercions} 来查看具体发生了什么。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Set Printing Coercions}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqref{LF.Imp.example bexp}{\coqdocdefinition{example\_bexp}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Unset Printing Coercions}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{求值}



 算术和布尔求值器被扩展成以很显然的方式来处理变量，
    它接受一个状态作为额外的参数： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Imp.aeval}{aeval}{\coqdocdefinition{aeval}} (\coqdocvar{st} : \coqref{LF.Imp.state}{\coqdocdefinition{state}}) (\coqdocvar{a} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{a} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.ANum}{\coqdocconstructor{ANum}} \coqdocvar{n} \ensuremath{\Rightarrow} \coqdocvar{n}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AId}{\coqdocconstructor{AId}} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvariable{st} \coqdocvar{x}                                \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.APlus}{\coqdocconstructor{APlus}} \coqdocvar{a1} \coqdocvar{a2} \ensuremath{\Rightarrow} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvar{a1}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvar{a2}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AMinus}{\coqdocconstructor{AMinus}} \coqdocvar{a1} \coqdocvar{a2}  \ensuremath{\Rightarrow} \coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvar{a1}\coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{-}} \coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvar{a2}\coqexternalref{::nat scope:x '-' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.AMult}{\coqdocconstructor{AMult}} \coqdocvar{a1} \coqdocvar{a2} \ensuremath{\Rightarrow} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvar{a1}\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvar{a2}\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Imp.beval}{beval}{\coqdocdefinition{beval}} (\coqdocvar{st} : \coqref{LF.Imp.state}{\coqdocdefinition{state}}) (\coqdocvar{b} : \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}}) : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{b} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.BTrue}{\coqdocconstructor{BTrue}}       \ensuremath{\Rightarrow} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.BFalse}{\coqdocconstructor{BFalse}}      \ensuremath{\Rightarrow} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.BEq}{\coqdocconstructor{BEq}} \coqdocvar{a1} \coqdocvar{a2}   \ensuremath{\Rightarrow} \coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvar{a1}\coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{=?}} \coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvar{a2}\coqexternalref{::nat scope:x '=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.BLe}{\coqdocconstructor{BLe}} \coqdocvar{a1} \coqdocvar{a2}   \ensuremath{\Rightarrow} \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvar{a1}\coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{<=?}} \coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvar{a2}\coqexternalref{::nat scope:x '<=?' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.BNot}{\coqdocconstructor{BNot}} \coqdocvar{b1}     \ensuremath{\Rightarrow} \coqexternalref{negb}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{negb}} (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvar{b1})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.BAnd}{\coqdocconstructor{BAnd}} \coqdocvar{b1} \coqdocvar{b2}  \ensuremath{\Rightarrow} \coqexternalref{andb}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{andb}} (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvar{b1}) (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvar{b2})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们为具体状态的全映射声明具体的记法，即使用 (\coqdocvar{\_} !-> 0) 作为空状态。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.empty st}{empty\_st}{\coqdocdefinition{empty\_st}} := (\coqref{LF.Maps.:::''' ''' '!->' x}{\coqdocnotation{\_}} \coqref{LF.Maps.:::''' ''' '!->' x}{\coqdocnotation{!->}} 0).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在我们可以为“单例状态（singleton state）”添加新的记法了，
    即只有一个绑定到值的变量。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.:::x '!->' x}{"}{"}x '!->' v" := (\coqref{LF.Maps.t update}{\coqdocdefinition{t\_update}} \coqref{LF.Imp.empty st}{\coqdocdefinition{empty\_st}} \coqdocvar{x} \coqdocvar{v}) (\coqdoctac{at} \coqdockw{level} 100).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Imp.aexp1}{aexp1}{\coqdocdefinition{aexp1}} :\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} (\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.:::x '!->' x}{\coqdocnotation{!->}} 5) (3 \coqref{LF.Imp.::imp scope:x '+' x}{\coqdocnotation{+}} \coqref{LF.Imp.::imp scope:x '+' x}{\coqdocnotation{(}}\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} 2\coqref{LF.Imp.::imp scope:x '+' x}{\coqdocnotation{)}})\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 13.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Imp.bexp1}{bexp1}{\coqdocdefinition{bexp1}} :\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} (\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.:::x '!->' x}{\coqdocnotation{!->}} 5) (\coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqref{LF.Imp.::imp scope:x 'x26x26' x}{\coqdocnotation{\&\&}} \coqref{LF.Imp.::imp scope:'x7E' x}{\coqdocnotation{\~{}(}}\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '<=' x}{\coqdocnotation{\ensuremath{\le}}} 4\coqref{LF.Imp.::imp scope:'x7E' x}{\coqdocnotation{)}})\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{指令}



 现在我们可以定义 Imp \textit{'指令（Command）'}（有时称作\textit{'语句（Statement）'}）
    的语法和行为了。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{语法}



 指令 \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 可以用以下 BNF 文法非形式化地描述。


     c ::= SKIP | x ::= a | c ;; c | TEST b THEN c ELSE c FI
         | WHILE b DO c END


    （为了能够使用 Coq 的记法机制来定义 Imp 语法，我们选择了这种略尴尬的具体语法。
    具体来说，我们使用了 \coqdocvar{TEST} 来避免与表中库中的 \coqdockw{if} 记法相冲突。）
    例如，下面是用 Imp 编写的阶乘：


     Z ::= X;;
     Y ::= 1;;
     WHILE \~{}(Z = 0) DO
       Y ::= Y * Z;;
       Z ::= Z - 1
     END


   当此指令终止后，\coqref{LF.Imp.Y}{\coqdocdefinition{Y}} 会保存初始值 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 的阶乘。 

 下面是指令的抽象语法的形式化定义： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.com}{com}{\coqdocinductive{com}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.CSkip}{CSkip}{\coqdocconstructor{CSkip}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.CAss}{CAss}{\coqdocconstructor{CAss}} (\coqdocvar{x} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) (\coqdocvar{a} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.CSeq}{CSeq}{\coqdocconstructor{CSeq}} (\coqdocvar{c1} \coqdocvar{c2} : \coqref{LF.Imp.com}{\coqdocinductive{com}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.CIf}{CIf}{\coqdocconstructor{CIf}} (\coqdocvar{b} : \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}}) (\coqdocvar{c1} \coqdocvar{c2} : \coqref{LF.Imp.com}{\coqdocinductive{com}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.CWhile}{CWhile}{\coqdocconstructor{CWhile}} (\coqdocvar{b} : \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}}) (\coqdocvar{c} : \coqref{LF.Imp.com}{\coqdocinductive{com}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
至于表达式，我们可以用一些 \coqdockw{Notation} 声明来让 Imp 程序的读写更加方便。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Bind} \coqdockw{Scope} \coqdocvar{imp\_scope} \coqdockw{with} \coqdocvar{com}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.::imp scope:'SKIP'}{"}{"}'SKIP'" :=\coqdoceol
\coqdocindent{1.50em}
\coqref{LF.Imp.CSkip}{\coqdocconstructor{CSkip}} : \coqdocvar{imp\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.::imp scope:x '::=' x}{"}{"}x '::=' a" :=\coqdoceol
\coqdocindent{1.00em}
(\coqref{LF.Imp.CAss}{\coqdocconstructor{CAss}} \coqdocvar{x} \coqdocvar{a}) (\coqdoctac{at} \coqdockw{level} 60) : \coqdocvar{imp\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.::imp scope:x ';;' x}{"}{"}c1 ;; c2" :=\coqdoceol
\coqdocindent{1.00em}
(\coqref{LF.Imp.CSeq}{\coqdocconstructor{CSeq}} \coqdocvar{c1} \coqdocvar{c2}) (\coqdoctac{at} \coqdockw{level} 80, \coqdoctac{right} \coqdockw{associativity}) : \coqdocvar{imp\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{"}{"}'WHILE' b 'DO' c 'END'" :=\coqdoceol
\coqdocindent{1.00em}
(\coqref{LF.Imp.CWhile}{\coqdocconstructor{CWhile}} \coqdocvar{b} \coqdocvar{c}) (\coqdoctac{at} \coqdockw{level} 80, \coqdoctac{right} \coqdockw{associativity}) : \coqdocvar{imp\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{"}{"}'TEST' c1 'THEN' c2 'ELSE' c3 'FI'" :=\coqdoceol
\coqdocindent{1.00em}
(\coqref{LF.Imp.CIf}{\coqdocconstructor{CIf}} \coqdocvar{c1} \coqdocvar{c2} \coqdocvar{c3}) (\coqdoctac{at} \coqdockw{level} 80, \coqdoctac{right} \coqdockw{associativity}) : \coqdocvar{imp\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
例如，下面是个阶乘函数，写成 Coq 的形式化定义： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.fact in coq}{fact\_in\_coq}{\coqdocdefinition{fact\_in\_coq}} : \coqref{LF.Imp.com}{\coqdocinductive{com}} :=\coqdoceol
\coqdocindent{1.00em}
(\coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqref{LF.Imp.X}{\coqdocdefinition{X}}\coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} 1\coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqref{LF.Imp.::imp scope:'x7E' x}{\coqdocnotation{\~{}(}}\coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Imp.::imp scope:x '=' x}{\coqdocnotation{=}} 0\coqref{LF.Imp.::imp scope:'x7E' x}{\coqdocnotation{)}} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqref{LF.Imp.::imp scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{LF.Imp.Z}{\coqdocdefinition{Z}}\coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Imp.::imp scope:x '-' x}{\coqdocnotation{-}} 1\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{脱糖记法}



 Coq 为管理日益复杂的工作对象提供了丰富的特性，例如隐式转换和记法。
    然而，过度使用它们会产生繁杂的语法。为了教学，我们通常会用以下命令来
    “关闭”这些特性以获得对事物更加本质的描述：



\begin{itemize}
\item  \coqdockw{Unset} \coqdockw{Printing} \coqdocvar{Notations}（用 \coqdockw{Set} \coqdockw{Printing} \coqdocvar{Notations} 撤销）

\item  \coqdockw{Set} \coqdockw{Printing} \coqdocvar{Coercions}（用 \coqdockw{Unset} \coqdockw{Printing} \coqdocvar{Coercions} 撤销）

\item  \coqdockw{Set} \coqdockw{Printing} \coqdockw{All}（用 \coqdockw{Unset} \coqdockw{Printing} \coqdockw{All} 撤销）

\end{itemize}


    这些命令也可在证明过程中详述当前目标和上下文。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Unset} \coqdockw{Printing} \coqdocvar{Notations}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqref{LF.Imp.fact in coq}{\coqdocdefinition{fact\_in\_coq}}.\coqdoceol
\coqdocnoindent
\coqdockw{Set} \coqdockw{Printing} \coqdocvar{Notations}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Set Printing Coercions}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqref{LF.Imp.fact in coq}{\coqdocdefinition{fact\_in\_coq}}.\coqdoceol
\coqdocnoindent
\coqdockw{Unset Printing Coercions}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{\texorpdfstring{\protect\coqdockw{Locate}}{Locate} 命令}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsubsection{查询记法}



 当遇到未知记法时，可使用 \coqdockw{Locate} 后跟一个包含其符号的\textit{'字符串'}
    来查看其可能的解释。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Locate} "\&\&".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Locate} ";;".\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Locate} "WHILE".\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{查询标识符}



 当以标示符使用 \coqdockw{Locate} 时，它会打印作用域中同名的所有值的完成路径。
    它很适合解决由变量覆盖所引起的问题。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Locate} \coqdocvar{aexp}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{更多示例}



 赋值： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.plus2}{plus2}{\coqdocdefinition{plus2}} : \coqref{LF.Imp.com}{\coqdocinductive{com}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '+' x}{\coqdocnotation{+}} 2.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.XtimesYinZ}{XtimesYinZ}{\coqdocdefinition{XtimesYinZ}} : \coqref{LF.Imp.com}{\coqdocinductive{com}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.subtract slowly body}{subtract\_slowly\_body}{\coqdocdefinition{subtract\_slowly\_body}} : \coqref{LF.Imp.com}{\coqdocinductive{com}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Imp.::imp scope:x '-' x}{\coqdocnotation{-}} 1 \coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '-' x}{\coqdocnotation{-}} 1.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{循环}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.subtract slowly}{subtract\_slowly}{\coqdocdefinition{subtract\_slowly}} : \coqref{LF.Imp.com}{\coqdocinductive{com}} :=\coqdoceol
\coqdocindent{1.00em}
(\coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqref{LF.Imp.::imp scope:'x7E' x}{\coqdocnotation{\~{}(}}\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '=' x}{\coqdocnotation{=}} 0\coqref{LF.Imp.::imp scope:'x7E' x}{\coqdocnotation{)}} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Imp.subtract slowly body}{\coqdocdefinition{subtract\_slowly\_body}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.subtract 3 from 5 slowly}{subtract\_3\_from\_5\_slowly}{\coqdocdefinition{subtract\_3\_from\_5\_slowly}} : \coqref{LF.Imp.com}{\coqdocinductive{com}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} 3 \coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} 5 \coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.subtract slowly}{\coqdocdefinition{subtract\_slowly}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{无限循环：}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.loop}{loop}{\coqdocdefinition{loop}} : \coqref{LF.Imp.com}{\coqdocinductive{com}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Imp.::imp scope:'SKIP'}{\coqdocnotation{SKIP}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{求值指令}



 接下来我们要定义对 Imp 指令进行求值是什么意思。
    \coqdocvar{WHILE} 未必会终止的事实让定义它的求值函数有点棘手... \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{求值作为函数（失败的尝试）}



 下面是一次为指令定义求值函数的尝试，我们忽略了 \coqdocvar{WHILE} 的情况。 

 为了在模式匹配中使用记法，我们需要以下声明。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Open} \coqdockw{Scope} \coqdocvar{imp\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Imp.ceval fun no while}{ceval\_fun\_no\_while}{\coqdocdefinition{ceval\_fun\_no\_while}} (\coqdocvar{st} : \coqref{LF.Imp.state}{\coqdocdefinition{state}}) (\coqdocvar{c} : \coqref{LF.Imp.com}{\coqdocinductive{com}})\coqdoceol
\coqdocindent{13.00em}
: \coqref{LF.Imp.state}{\coqdocdefinition{state}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{c} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'SKIP'}{\coqdocnotation{SKIP}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdocvariable{st}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{x} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqdocvar{a1} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
(\coqdocvar{x} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{(}}\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvar{a1}\coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{)}} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{st})\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{c1} \coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}} \coqdocvar{c2} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{let} \coqdocvar{st'} := \coqref{LF.Imp.ceval fun no while}{\coqdocdefinition{ceval\_fun\_no\_while}} \coqdocvariable{st} \coqdocvar{c1} \coqdoctac{in}\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.Imp.ceval fun no while}{\coqdocdefinition{ceval\_fun\_no\_while}} \coqdocvariable{st'} \coqdocvar{c2}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} \coqdocvar{b} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}} \coqdocvar{c1} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}} \coqdocvar{c2} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{if} (\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvar{b})\coqdoceol
\coqdocindent{5.00em}
\coqdockw{then} \coqref{LF.Imp.ceval fun no while}{\coqdocdefinition{ceval\_fun\_no\_while}} \coqdocvariable{st} \coqdocvar{c1}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{else} \coqref{LF.Imp.ceval fun no while}{\coqdocdefinition{ceval\_fun\_no\_while}} \coqdocvariable{st} \coqdocvar{c2}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqdocvar{b} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqdocvar{c} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdocvariable{st}  \coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocnoindent
\coqdockw{Close} \coqdockw{Scope} \coqdocvar{imp\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在 OCaml 或 Haskell 这类传统的函数式编程语言中，我们可以像下面这样添加
    \coqdocvar{WHILE} 的情况：


        Fixpoint ceval\_fun (st : state) (c : com) : state :=
          match c with
            ...
            | WHILE b DO c END =>
                if (beval st b)
                  then ceval\_fun st (c ;; WHILE b DO c END)
                  else st
          end.


    Coq 会拒绝这种定义（“Error: Cannot guess decreasing argument of fix”，
    错误：无法猜测出固定的递减参数），因为我们想要定义的函数并不保证终止。
    确实，它并不\textit{'总是会终止'}：例如，\coqdocvar{ceval\_fun} 函数应用到上面的 \coqref{LF.Imp.loop}{\coqdocdefinition{loop}}
    程序的完整版本永远不会终止。由于 Coq 不仅是一个函数式编程语言，
    还是个逻辑一致的语言，因此任何潜在的不可终止函数都会被拒绝。下面是一个
    （无效的）程序，它展示了如果 Coq 允许不可终止的递归函数的话会产生什么错误：


         Fixpoint loop\_false (n : nat) : False := loop\_false n.


    也就是说，像 \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}} 这样的假命题可以被证明（\coqdocvar{loop\_false} 0 会是 \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}}
    的一个证明），这对于 Coq 的逻辑一致性来说是个灾难。


    由于它对于所有的输入都不会终止，因此 \coqdocvar{ceval\_fun} 无法在 Coq 中写出
 至少需要一些技巧和变通才行（如果你对此好奇的话请阅读
    \coqdoclibrary{ImpCEvalFun} 一章）。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{求值作为一种关系}



 下面是一种更好的方法：将 \coqref{LF.Imp.BreakImp.ceval}{\coqdocinductive{ceval}} 定义成一种\textit{'关系'}而非一个\textit{'函数'}
    -- 即，用 \coqdockw{Prop} 而非用 \coqdockw{Type} 来定义它，和我们前面对 \coqref{LF.Imp.aevalR extended.aevalR}{\coqdocinductive{aevalR}} 做的那样。 

 这是一个非常重要的更改。除了能将我们从尴尬的变通中解放出来之外，
    它还给我们的定义赋予了更多的灵活性。例如，如果我们要为该语言添加更多像
    \coqdocvar{any} 这样非确定性的特性，我们需要让求值的定义也是非确定性的 --
    即，它不仅会有不完全性，甚至还可以不是个函数！ 

 我们将使用记法 \coqdocvariable{st} =[ \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} ]=> \coqdocvariable{st'} 来表示 \coqref{LF.Imp.BreakImp.ceval}{\coqdocinductive{ceval}} 这种关系：\coqdocvariable{st} =[ \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} ]=> \coqdocvariable{st'}
    表示在开始状态 \coqdocvariable{st} 下启动程序并在结束状态 \coqdocvariable{st'} 下产生结果。它可以读作：
    “\coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 将状态 \coqdocvariable{st} 变成 \coqdocvariable{st'}”。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsubsection{操作语义}



 下面是求值的非形式化定义，为了可读性表示成推理规则：
\par
\noindent\hrulefill\par
\noindent{}                             (E\_Skip)
                           st = \coqdocvar{SKIP} => st


                           aeval st a1 = n
\par
\noindent\hrulefill\par
\noindent{}                       (E\_Ass)
                   st = \coqdocvariable{x} := \coqdocvariable{a1} => (x !-> n ; st)


                           st  = \coqref{LF.IndProp.R.c1}{\coqdocconstructor{c1}} => st'
                           st' = \coqref{LF.IndProp.R.c2}{\coqdocconstructor{c2}} => st''
\par
\noindent\hrulefill\par
\noindent{}                            (E\_Seq)
                         st = \coqref{LF.IndProp.R.c1}{\coqdocconstructor{c1}};;\coqref{LF.IndProp.R.c2}{\coqdocconstructor{c2}} => st''


                          beval st b1 = true
                           st = \coqref{LF.IndProp.R.c1}{\coqdocconstructor{c1}} => st'
\par
\noindent\hrulefill\par
\noindent{}                (E\_IfTrue)
                st = \coqdocvar{TEST} \coqdocvariable{b1} \coqdocvar{THEN} \coqref{LF.IndProp.R.c1}{\coqdocconstructor{c1}} \coqdocvar{ELSE} \coqref{LF.IndProp.R.c2}{\coqdocconstructor{c2}} \coqdocvar{FI} => st'


                         beval st b1 = false
                           st = \coqref{LF.IndProp.R.c2}{\coqdocconstructor{c2}} => st'
\par
\noindent\hrulefill\par
\noindent{}               (E\_IfFalse)
                st = \coqdocvar{TEST} \coqdocvariable{b1} \coqdocvar{THEN} \coqref{LF.IndProp.R.c1}{\coqdocconstructor{c1}} \coqdocvar{ELSE} \coqref{LF.IndProp.R.c2}{\coqdocconstructor{c2}} \coqdocvar{FI} => st'


                         beval st b = false
\par
\noindent\hrulefill\par
\noindent{}                  (E\_WhileFalse)
                    st = \coqdocvar{WHILE} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} \coqdocvar{DO} \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} \coqdocvar{END} => st


                          beval st b = true
                           st = \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} => st'
                  st' = \coqdocvar{WHILE} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} \coqdocvar{DO} \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} \coqdocvar{END} => st''
\par
\noindent\hrulefill\par
\noindent{}                  (E\_WhileTrue)
                  st  = \coqdocvar{WHILE} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} \coqdocvar{DO} \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} \coqdocvar{END} => st''


 下面是它的形式化定义。请确保你理解了它是如何与以上推理规则相对应的。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Reserved Notation} "st '=[' c ']=>' st'"\coqdoceol
\coqdocindent{9.00em}
(\coqdoctac{at} \coqdockw{level} 40).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.ceval}{ceval}{\coqdocinductive{ceval}} : \coqref{LF.Imp.com}{\coqdocinductive{com}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.state}{\coqdocdefinition{state}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.state}{\coqdocdefinition{state}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.E Skip}{E\_Skip}{\coqdocconstructor{E\_Skip}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{st},\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Imp.::imp scope:'SKIP'}{\coqdocnotation{SKIP}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.E Ass}{E\_Ass}{\coqdocconstructor{E\_Ass}}  : \coqdockw{\ensuremath{\forall}} \coqdocvar{st} \coqdocvar{a1} \coqdocvar{n} \coqdocvar{x},\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvariable{a1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{x} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqdocvariable{a1} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{n} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{st}\coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.E Seq}{E\_Seq}{\coqdocconstructor{E\_Seq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{c1} \coqdocvar{c2} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{st'{}'},\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st}  \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c1} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st'} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c2} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'{}'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st}  \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c1} \coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}} \coqdocvariable{c2} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'{}'}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.E IfTrue}{E\_IfTrue}{\coqdocconstructor{E\_IfTrue}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{b} \coqdocvar{c1} \coqdocvar{c2},\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c1} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} \coqdocvariable{b} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}} \coqdocvariable{c1} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}} \coqdocvariable{c2} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.E IfFalse}{E\_IfFalse}{\coqdocconstructor{E\_IfFalse}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{b} \coqdocvar{c1} \coqdocvar{c2},\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c2} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} \coqdocvariable{b} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}} \coqdocvariable{c1} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}} \coqdocvariable{c2} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.E WhileFalse}{E\_WhileFalse}{\coqdocconstructor{E\_WhileFalse}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{st} \coqdocvar{c},\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqdocvariable{b} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqdocvariable{c} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.E WhileTrue}{E\_WhileTrue}{\coqdocconstructor{E\_WhileTrue}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{st'{}'} \coqdocvar{b} \coqdocvar{c},\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st}  \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st'} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqdocvariable{b} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqdocvariable{c} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'{}'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st}  \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqdocvariable{b} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqdocvariable{c} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'{}'}\coqdoceol
\coqdocnoindent
\coqdoceol
\coqdocindent{1.00em}
\coqdockw{where} \coqdef{LF.Imp.:::x '=[' x ']=>' x}{"}{"}st =[ c ]=> st'" := (\coqref{LF.Imp.ceval}{\coqdocinductive{ceval}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st'}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
将求值定义成关系而非函数的代价是，我们需要自己为某个程序求值成某种结束状态\textit{'构造证明'}，
    而不能只是交给 Coq 的计算机制去做了。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Imp.ceval example1}{ceval\_example1}{\coqdocdefinition{ceval\_example1}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.empty st}{\coqdocdefinition{empty\_st}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} 2\coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '<=' x}{\coqdocnotation{\ensuremath{\le}}} 1\coqdoceol
\coqdocindent{3.50em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} 3\coqdoceol
\coqdocindent{3.50em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}} \coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} 4\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{(}}\coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} 4 \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.:::x '!->' x}{\coqdocnotation{!->}} 2\coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.Imp.E Seq}{\coqdocconstructor{E\_Seq}} \coqdockw{with} (\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.:::x '!->' x}{\coqdocnotation{!->}} 2).\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{LF.Imp.E Ass}{\coqdocconstructor{E\_Ass}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{LF.Imp.E IfFalse}{\coqdocconstructor{E\_IfFalse}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{LF.Imp.E Ass}{\coqdocconstructor{E\_Ass}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard (ceval\_example2)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Imp.ceval example2}{ceval\_example2}{\coqdocdefinition{ceval\_example2}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.empty st}{\coqdocdefinition{empty\_st}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} 0\coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} 1\coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}} \coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} 2\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{(}}\coqref{LF.Imp.Z}{\coqdocdefinition{Z}} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} 2 \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} 1 \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.:::x '!->' x}{\coqdocnotation{!->}} 0\coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard, optional (pup\_to\_n)}




    写一个 Imp 程序对从 1 到 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 进行求值（包括：将 1 + 2 + ... + \coqref{LF.Imp.X}{\coqdocdefinition{X}}) 赋予变量 \coqref{LF.Imp.Y}{\coqdocdefinition{Y}}。
   证明此程序对于 \coqref{LF.Imp.X}{\coqdocdefinition{X}} = 2 会按预期执行（这可能比你预想的还要棘手）。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.pup to n}{pup\_to\_n}{\coqdocdefinition{pup\_to\_n}} : \coqref{LF.Imp.com}{\coqdocinductive{com}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.pup to 2 ceval}{pup\_to\_2\_ceval}{\coqdoclemma{pup\_to\_2\_ceval}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{(}}\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.:::x '!->' x}{\coqdocnotation{!->}} 2\coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{)}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Imp.pup to n}{\coqdocaxiom{pup\_to\_n}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{(}}\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} 0 \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} 3 \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} 1 \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} 2 \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} 0 \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.:::x '!->' x}{\coqdocnotation{!->}} 2\coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{求值的确定性}



 将求值从计算式定义换成关系式定义是个不错的改变，
    因为它将我们从求值必须是全函数的人工需求中解放了出来。不过这仍然引发了一个问题：
    求值的第二种定义真的是一个偏函数吗？从同样的 \coqdocvariable{st}
    开始, 我们是否有可能按照不同的方式对某个指令 \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 进行求值，
    从而到达两个不同的输出状态 \coqdocvariable{st'} 和 \coqdocvariable{st'{}'}?


    实际上这不可能发生，因为 \coqref{LF.Imp.BreakImp.ceval}{\coqdocinductive{ceval}} \textit{'确实'}是一个偏函数： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.ceval deterministic}{ceval\_deterministic}{\coqdoclemma{ceval\_deterministic}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2},\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st1}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{st1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{st2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2} \coqdocvar{E1} \coqdocvar{E2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{st2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{E1}; \coqdoctac{intros} \coqdocvar{st2} \coqdocvar{E2}; \coqdoctac{inversion} \coqdocvar{E2}; \coqdoctac{subst}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{st'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{st'0}) \coqdockw{as} \coqdocvar{EQ1}.\coqdoceol
\coqdocindent{2.00em}
\{  \coqdoctac{apply} \coqdocvar{IHE1\_1}; \coqdoctac{assumption}. \}\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{subst} \coqdocvar{st'0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{IHE1\_2}. \coqdoctac{assumption}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHE1}. \coqdoctac{assumption}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H5}. \coqdoctac{discriminate} \coqdocvar{H5}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H5}. \coqdoctac{discriminate} \coqdocvar{H5}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHE1}. \coqdoctac{assumption}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H2}. \coqdoctac{discriminate} \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{H4}. \coqdoctac{discriminate} \coqdocvar{H4}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{assert} (\coqdocvar{st'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{st'0}) \coqdockw{as} \coqdocvar{EQ1}.\coqdoceol
\coqdocindent{3.00em}
\{  \coqdoctac{apply} \coqdocvar{IHE1\_1}; \coqdoctac{assumption}. \}\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{subst} \coqdocvar{st'0}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHE1\_2}. \coqdoctac{assumption}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{对 Imp 进行推理}



 我们会在\textit{'《编程语言基础》'}中更加深入地探讨对 Imp 程序进行推理的系统性技术，
    不过目前只根据定义就能做很多工作。本节中会我们会探讨一些实例。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.plus2 spec}{plus2\_spec}{\coqdoclemma{plus2\_spec}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{st} \coqdocvar{n} \coqdocvar{st'},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{st} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Imp.plus2}{\coqdocdefinition{plus2}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{st'} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 2.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{st} \coqdocvar{n} \coqdocvar{st'} \coqdocvar{HX} \coqdocvar{Heval}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
反转 \coqdocvar{Heval} 实际上会强制让 Coq 展开 \coqref{LF.Imp.BreakImp.ceval}{\coqdocinductive{ceval}} 求值的一个步骤 --
      由于 \coqref{LF.Imp.plus2}{\coqdocdefinition{plus2}} 是一个赋值，因此这种情况揭示了 \coqdocvariable{st'} 一定是 \coqdocvariable{st}
      通过新的值 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 扩展而来的。 \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{inversion} \coqdocvar{Heval}. \coqdoctac{subst}. \coqdoctac{clear} \coqdocvar{Heval}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.Maps.t update eq}{\coqdocaxiom{t\_update\_eq}}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：3 星, standard, optional (XtimesYinZ\_spec)}




    叙述并证明 \coqref{LF.Imp.XtimesYinZ}{\coqdocdefinition{XtimesYinZ}} 的规范（Specification）。 \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.manual grade for XtimesYinZ spec}{manual\_grade\_for\_XtimesYinZ\_spec}{\coqdocdefinition{manual\_grade\_for\_XtimesYinZ\_spec}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard, recommended (loop\_never\_stops)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.loop never stops}{loop\_never\_stops}{\coqdoclemma{loop\_never\_stops}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{st} \coqdocvar{st'},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\~{}(}}\coqdocvariable{st} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{=[}} \coqref{LF.Imp.loop}{\coqdocdefinition{loop}} \coqref{LF.Imp.:::x '=[' x ']=>' x}{\coqdocnotation{]=>}} \coqdocvariable{st'}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{contra}. \coqdoctac{unfold} \coqref{LF.Imp.loop}{\coqdocdefinition{loop}} \coqdoctac{in} \coqdocvar{contra}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{remember} (\coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqref{LF.Imp.::imp scope:'SKIP'}{\coqdocnotation{SKIP}} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}})\%\coqdocvar{imp} \coqdockw{as} \coqdocvar{loopdef}\coqdoceol
\coqdocindent{5.50em}
\coqdocvar{eqn}:\coqdocvar{Heqloopdef}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
归纳讨论假设“\coqdocvar{loopdef} 会终止”之构造，其中多数情形的矛盾显而易见，
      可用 \coqdoctac{discriminate} 一步解决。 \begin{coqdoccode}
\coqdocemptyline
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard (no\_whiles\_eqv)}




    考虑以下函数： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Open} \coqdockw{Scope} \coqdocvar{imp\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Imp.no whiles}{no\_whiles}{\coqdocdefinition{no\_whiles}} (\coqdocvar{c} : \coqref{LF.Imp.com}{\coqdocinductive{com}}) : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{c} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'SKIP'}{\coqdocnotation{SKIP}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{\_} \coqref{LF.Imp.::imp scope:x '::=' x}{\coqdocnotation{::=}} \coqdocvar{\_} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{c1} \coqref{LF.Imp.::imp scope:x ';;' x}{\coqdocnotation{;;}} \coqdocvar{c2} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{andb}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{andb}} (\coqref{LF.Imp.no whiles}{\coqdocdefinition{no\_whiles}} \coqdocvar{c1}) (\coqref{LF.Imp.no whiles}{\coqdocdefinition{no\_whiles}} \coqdocvar{c2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{TEST}} \coqdocvar{\_} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{THEN}} \coqdocvar{ct} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{ELSE}} \coqdocvar{cf} \coqref{LF.Imp.::imp scope:'TEST' x 'THEN' x 'ELSE' x 'FI'}{\coqdocnotation{FI}} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{andb}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{andb}} (\coqref{LF.Imp.no whiles}{\coqdocdefinition{no\_whiles}} \coqdocvar{ct}) (\coqref{LF.Imp.no whiles}{\coqdocdefinition{no\_whiles}} \coqdocvar{cf})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqdocvar{\_} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqdocvar{\_} \coqref{LF.Imp.::imp scope:'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}}  \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocnoindent
\coqdockw{Close} \coqdockw{Scope} \coqdocvar{imp\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
此断言只对没有 \coqdocvar{WHILE} 循环的程序产生 \coqref{LF.Basics.true}{\coqdocconstructor{true}}。请用 \coqdockw{Inductive}
    写出一个性质 \coqref{LF.Imp.no whilesR}{\coqdocinductive{no\_whilesR}} 使得 \coqref{LF.Imp.no whilesR}{\coqdocinductive{no\_whilesR}} \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 仅当 \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 是个没有
    \coqdocvar{WHILE} 循环的程序时才可以证明。之后证明它与 \coqref{LF.Imp.no whiles}{\coqdocdefinition{no\_whiles}} 等价。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.no whilesR}{no\_whilesR}{\coqdocinductive{no\_whilesR}}: \coqref{LF.Imp.com}{\coqdocinductive{com}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{0.50em}
\coqdoceol
\coqdocnoindent
.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.no whiles eqv}{no\_whiles\_eqv}{\coqdoclemma{no\_whiles\_eqv}}:\coqdoceol
\coqdocindent{1.50em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{c}, \coqref{LF.Imp.no whiles}{\coqdocdefinition{no\_whiles}} \coqdocvariable{c} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{LF.Imp.no whilesR}{\coqdocinductive{no\_whilesR}} \coqdocvariable{c}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：4 星, standard (no\_whiles\_terminating)}




    不涉及 \coqdocvar{WHILE} 循环的 Imp 程序一定会终止。请陈述并证明定理
    \coqdocvar{no\_whiles\_terminating} 来说明这一点。


    按照你的偏好使用 \coqref{LF.Imp.no whiles}{\coqdocdefinition{no\_whiles}} 或 \coqref{LF.Imp.no whilesR}{\coqdocinductive{no\_whilesR}}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Imp.manual grade for no whiles terminating}{manual\_grade\_for\_no\_whiles\_terminating}{\coqdocdefinition{manual\_grade\_for\_no\_whiles\_terminating}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{附加练习}



\paragraph{练习：3 星, standard (stack\_compiler)}




    旧式惠普计算器的编程语言类似于 Forth 和 Postscript，而其抽象机器类似于
    Java 虚拟机，即所有对算术表达式的求值都使用\textit{'栈'}来进行。例如，表达式


      (2*3)+(3*(4-2))


   会被写成


      2 3 * 3 4 2 - * +


   的形式，其求值过程如下（右侧为被求值的程序，左侧为栈中的内容）：


                  |    2 3 * 3 4 2 - * +
      2           |    3 * 3 4 2 - * +
      3, 2        |    * 3 4 2 - * +
      6           |    3 4 2 - * +
      3, 6        |    4 2 - * +
      4, 3, 6     |    2 - * +
      2, 4, 3, 6  |    - * +
      2, 3, 6     |    * +
      6, 6        |    +
      12          |


  此练习的目的在于编写一个小型编译器，它将 \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}} 翻译成栈机器指令。


  栈语言的指令集由以下指令构成：

\begin{itemize}
\item  \coqref{LF.Imp.SPush}{\coqdocconstructor{SPush}} \coqdocvariable{n}：将数 \coqdocvariable{n} 压栈。

\item  \coqref{LF.Imp.SLoad}{\coqdocconstructor{SLoad}} \coqdocvariable{x}：从存储中加载标识符 \coqdocvariable{x} 并将其压栈。

\item  \coqref{LF.Imp.SPlus}{\coqdocconstructor{SPlus}}：  从栈顶弹出两个数，将二者相加，并将其结果压栈。

\item  \coqref{LF.Imp.SMinus}{\coqdocconstructor{SMinus}}： 类似，不过执行减法。

\item  \coqref{LF.Imp.SMult}{\coqdocconstructor{SMult}}：  类似，不过执行乘法。 
\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.sinstr}{sinstr}{\coqdocinductive{sinstr}} : \coqdockw{Type} :=\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.Imp.SPush}{SPush}{\coqdocconstructor{SPush}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.Imp.SLoad}{SLoad}{\coqdocconstructor{SLoad}} (\coqdocvar{x} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}})\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.Imp.SPlus}{SPlus}{\coqdocconstructor{SPlus}}\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.Imp.SMinus}{SMinus}{\coqdocconstructor{SMinus}}\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.Imp.SMult}{SMult}{\coqdocconstructor{SMult}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
请编写一个函数对栈语言程序进行求值。它应当接受一个状态、
    一个表示为数字列表的栈（栈顶项在表头），以及一个表示为指令列表的程序作为输入，
    并在程序执行后返回该栈。请在以下示例中测试你的函数。


    注意，当栈中的元素少于两个时，规范并未指定 \coqref{LF.Imp.SPlus}{\coqdocconstructor{SPlus}}、\coqref{LF.Imp.SMinus}{\coqdocconstructor{SMinus}} 或 \coqref{LF.Imp.SMult}{\coqdocconstructor{SMult}} 指令的行为。
    从某种意义上说，这样做并无必要，因为我们的编译器永远不会产生这种畸形的程序。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Imp.s execute}{s\_execute}{\coqdocdefinition{s\_execute}} (\coqdocvar{st} : \coqref{LF.Imp.state}{\coqdocdefinition{state}}) (\coqdocvar{stack} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{9.50em}
(\coqdocvar{prog} : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.Imp.sinstr}{\coqdocinductive{sinstr}})\coqdoceol
\coqdocindent{8.50em}
: \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Imp.s execute1}{s\_execute1}{\coqdocdefinition{s\_execute1}} :\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Imp.s execute}{\coqdocaxiom{s\_execute}} \coqref{LF.Imp.empty st}{\coqdocdefinition{empty\_st}} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[]}}\coqdoceol
\coqdocindent{3.50em}
\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqref{LF.Imp.SPush}{\coqdocconstructor{SPush}} 5\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} \coqref{LF.Imp.SPush}{\coqdocconstructor{SPush}} 3\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} \coqref{LF.Imp.SPush}{\coqdocconstructor{SPush}} 1\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} \coqref{LF.Imp.SMinus}{\coqdocconstructor{SMinus}}\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{]}}\coqdoceol
\coqdocindent{1.50em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[}}2\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} 5\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{]}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Imp.s execute2}{s\_execute2}{\coqdocdefinition{s\_execute2}} :\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Imp.s execute}{\coqdocaxiom{s\_execute}} (\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.:::x '!->' x}{\coqdocnotation{!->}} 3) \coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[}}3\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}}4\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{]}}\coqdoceol
\coqdocindent{3.50em}
\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqref{LF.Imp.SPush}{\coqdocconstructor{SPush}} 4\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} \coqref{LF.Imp.SLoad}{\coqdocconstructor{SLoad}} \coqref{LF.Imp.X}{\coqdocdefinition{X}}\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} \coqref{LF.Imp.SMult}{\coqdocconstructor{SMult}}\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} \coqref{LF.Imp.SPlus}{\coqdocconstructor{SPlus}}\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{]}}\coqdoceol
\coqdocindent{1.50em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[}}15\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} 4\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{]}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
接下来请编写一个将 \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}} 编译成栈机器程序的函数。运行此程序的效果
    应当和将该表达式的值压入栈中一致。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Imp.s compile}{s\_compile}{\coqdocdefinition{s\_compile}} (\coqdocvar{e} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}}) : \coqexternalref{list}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{list}} \coqref{LF.Imp.sinstr}{\coqdocinductive{sinstr}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在定义完 \coqref{LF.Imp.s compile}{\coqdocdefinition{s\_compile}} 之后，请证明以下示例来测试它是否起作用。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Imp.s compile1}{s\_compile1}{\coqdocdefinition{s\_compile1}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.s compile}{\coqdocaxiom{s\_compile}} (\coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqref{LF.Imp.::imp scope:x '-' x}{\coqdocnotation{-}} \coqref{LF.Imp.::imp scope:x '-' x}{\coqdocnotation{(}}2 \coqref{LF.Imp.::imp scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}}\coqref{LF.Imp.::imp scope:x '-' x}{\coqdocnotation{)}})\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[}}\coqref{LF.Imp.SLoad}{\coqdocconstructor{SLoad}} \coqref{LF.Imp.X}{\coqdocdefinition{X}}\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} \coqref{LF.Imp.SPush}{\coqdocconstructor{SPush}} 2\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} \coqref{LF.Imp.SLoad}{\coqdocconstructor{SLoad}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}}\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} \coqref{LF.Imp.SMult}{\coqdocconstructor{SMult}}\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{;}} \coqref{LF.Imp.SMinus}{\coqdocconstructor{SMinus}}\coqexternalref{ListNotations.::list scope:'[' x ';' x ';' '..' ';' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{]}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：4 星, advanced (stack\_compiler\_correct)}




    现在我们将证明在之前练习中实现的编译器的正确性。记住当栈中的元素少于两个时，
    规范并未指定 \coqref{LF.Imp.SPlus}{\coqdocconstructor{SPlus}}、\coqref{LF.Imp.SMinus}{\coqdocconstructor{SMinus}} 或 \coqref{LF.Imp.SMult}{\coqdocconstructor{SMult}} 指令的行为。
    （为了让正确性证明更加容易，你可能需要返回去修改你的实现！）


    请证明以下定理。你需要先陈述一个更一般的引理来得到一个有用的归纳假设，
    由它的话主定理就只是一个简单的推论了。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.s compile correct}{s\_compile\_correct}{\coqdoclemma{s\_compile\_correct}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{st} : \coqref{LF.Imp.state}{\coqdocdefinition{state}}) (\coqdocvar{e} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.s execute}{\coqdocaxiom{s\_execute}} \coqdocvariable{st} \coqexternalref{ListNotations.::list scope:'[' ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[]}} (\coqref{LF.Imp.s compile}{\coqdocaxiom{s\_compile}} \coqdocvariable{e}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{[}} \coqref{LF.Imp.aeval}{\coqdocdefinition{aeval}} \coqdocvariable{st} \coqdocvariable{e} \coqexternalref{ListNotations.::list scope:'[' x ']'}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard, optional (short\_circuit)}




    大部分现代编程语言对布尔 \coqref{LF.ProofObjects.Props.And.and}{\coqdocinductive{and}} 运算提供了“短路求值”的方法：要对
    \coqref{LF.Imp.BAnd}{\coqdocconstructor{BAnd}} \coqdocvariable{b1} \coqdocvariable{b2} 进行求值，首先对 \coqdocvariable{b1} 求值。如果结果为 \coqref{LF.Basics.false}{\coqdocconstructor{false}}，那么整个
    \coqref{LF.Imp.BAnd}{\coqdocconstructor{BAnd}} 表达式的求值就是 \coqref{LF.Basics.false}{\coqdocconstructor{false}}，而无需对 \coqdocvariable{b2} 求值。否则，\coqdocvariable{b2}
    的求值结果就决定了 \coqref{LF.Imp.BAnd}{\coqdocconstructor{BAnd}} 表达式的值。


    请编写 \coqref{LF.Imp.beval}{\coqdocdefinition{beval}} 的另一种版本，它能以这种方式对 \coqref{LF.Imp.BAnd}{\coqdocconstructor{BAnd}} 执行短路求值，
    并证明它等价于 \coqref{LF.Imp.beval}{\coqdocdefinition{beval}}。（注：二者等价只是因为 Imp 的表达式求值相当简单。
    在更大的语言中该表达式可能会发散，此时短路求值的 \coqref{LF.Imp.BAnd}{\coqdocconstructor{BAnd}} \textit{'并不'}
    等价于原始版本，因为它能让更多程序终止。） \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Imp.BreakImp}{BreakImp}{\coqdocmodule{BreakImp}}.\coqdoceol
\end{coqdoccode}
\paragraph{练习：4 星, advanced (break\_imp)}




    像 C 和 Java 这样的指令式语言通常会包含 \coqdocvar{break} 或类似地语句来中断循环的执行。
    在本练习中，我们考虑如何为 Imp 加上 \coqdocvar{break}。首先，我们需要丰富语言的指令。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.BreakImp.com}{com}{\coqdocinductive{com}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.BreakImp.CSkip}{CSkip}{\coqdocconstructor{CSkip}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.BreakImp.CBreak}{CBreak}{\coqdocconstructor{CBreak}}                        \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.BreakImp.CAss}{CAss}{\coqdocconstructor{CAss}} (\coqdocvar{x} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) (\coqdocvar{a} : \coqref{LF.Imp.aexp}{\coqdocinductive{aexp}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.BreakImp.CSeq}{CSeq}{\coqdocconstructor{CSeq}} (\coqdocvar{c1} \coqdocvar{c2} : \coqref{LF.Imp.com}{\coqdocinductive{com}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.BreakImp.CIf}{CIf}{\coqdocconstructor{CIf}} (\coqdocvar{b} : \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}}) (\coqdocvar{c1} \coqdocvar{c2} : \coqref{LF.Imp.com}{\coqdocinductive{com}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.BreakImp.CWhile}{CWhile}{\coqdocconstructor{CWhile}} (\coqdocvar{b} : \coqref{LF.Imp.bexp}{\coqdocinductive{bexp}}) (\coqdocvar{c} : \coqref{LF.Imp.com}{\coqdocinductive{com}}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.BreakImp.:::'SKIP'}{"}{"}'SKIP'" :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.BreakImp.CSkip}{\coqdocconstructor{CSkip}}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.BreakImp.:::'BREAK'}{"}{"}'BREAK'" :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.BreakImp.CBreak}{\coqdocconstructor{CBreak}}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.BreakImp.:::x '::=' x}{"}{"}x '::=' a" :=\coqdoceol
\coqdocindent{1.00em}
(\coqref{LF.Imp.BreakImp.CAss}{\coqdocconstructor{CAss}} \coqdocvar{x} \coqdocvar{a}) (\coqdoctac{at} \coqdockw{level} 60).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.BreakImp.:::x ';;' x}{"}{"}c1 ;; c2" :=\coqdoceol
\coqdocindent{1.00em}
(\coqref{LF.Imp.BreakImp.CSeq}{\coqdocconstructor{CSeq}} \coqdocvar{c1} \coqdocvar{c2}) (\coqdoctac{at} \coqdockw{level} 80, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.BreakImp.:::'WHILE' x 'DO' x 'END'}{"}{"}'WHILE' b 'DO' c 'END'" :=\coqdoceol
\coqdocindent{1.00em}
(\coqref{LF.Imp.BreakImp.CWhile}{\coqdocconstructor{CWhile}} \coqdocvar{b} \coqdocvar{c}) (\coqdoctac{at} \coqdockw{level} 80, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Imp.BreakImp.:::'TEST' x 'THEN' x 'ELSE' x 'FI'}{"}{"}'TEST' c1 'THEN' c2 'ELSE' c3 'FI'" :=\coqdoceol
\coqdocindent{1.00em}
(\coqref{LF.Imp.BreakImp.CIf}{\coqdocconstructor{CIf}} \coqdocvar{c1} \coqdocvar{c2} \coqdocvar{c3}) (\coqdoctac{at} \coqdockw{level} 80, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
接着，我们需要定义 \coqdocvar{BREAK} 的行为。非形式化地说，只要 \coqdocvar{BREAK}
    在指令序列中执行，它就会终止该序列的执行并发出最内层围绕它的循环应当终止的信号。
    （如果没有任何围绕它的循环，那么就终止整个程序。）最终状态应当与
    \coqdocvar{BREAK} 语句执行后的状态相同。


    其要点之一在于当一个给定的 \coqdocvar{BREAK} 位于多个循环中时应该做什么。
    此时，\coqdocvar{BREAK} 应当只终止\textit{'最内层'}的循环。因此，在执行完以下指令之后...


       X ::= 0;;
       Y ::= 1;;
       WHILE \~{}(0 = Y) DO
         WHILE true DO
           BREAK
         END;;
         X ::= 1;;
         Y ::= Y - 1
       END


    ...\coqref{LF.Imp.X}{\coqdocdefinition{X}} 的值应为 1 而非 0。


    表达这种行为的一种方式求值为求值关系添加一个形参，指定某个指令是否会执行
    \coqdocvar{BREAK} 语句： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.BreakImp.result}{result}{\coqdocinductive{result}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.BreakImp.SContinue}{SContinue}{\coqdocconstructor{SContinue}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.BreakImp.SBreak}{SBreak}{\coqdocconstructor{SBreak}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Reserved Notation} "st '=[' c ']=>' st' '/' s"\coqdoceol
\coqdocindent{4.50em}
(\coqdoctac{at} \coqdockw{level} 40, \coqdocvar{st'} \coqdoctac{at} \coqdocvar{next} \coqdockw{level}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
直觉上说，\coqdocvariable{st} =[ \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} ]=> \coqdocvariable{st'} / \coqdocvariable{s} 表示如果 \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 在 \coqdocvariable{st} 状况下开始，
    它会在 \coqdocvariable{st'} 状态下终止，围绕它的最内层循环（或整个程序）
    要么收到立即退出的信号（\coqdocvariable{s} = \coqref{LF.Imp.BreakImp.SBreak}{\coqdocconstructor{SBreak}}），要么继续正常执行（\coqdocvariable{s} = \coqref{LF.Imp.BreakImp.SContinue}{\coqdocconstructor{SContinue}}）。


    “\coqdocvariable{st} =[ \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} ]=> \coqdocvariable{st'} / \coqdocvariable{s}”关系的定义非常类似于之前我们为一般求值关系
    （\coqdocvariable{st} =[ \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} ]=> \coqdocvariable{st'}）给出的定义 -- 我们只需要恰当地处理终止信号。



\begin{itemize}
\item  若指令为 \coqdocvar{SKIP}，则状态不变，任何围绕它的循环继续正常执行。



\item  若指令为 \coqdocvar{BREAK}，则状态保持不变但发出 \coqref{LF.Imp.BreakImp.SBreak}{\coqdocconstructor{SBreak}} 的信号。



\item  若指令为赋值，则根据状态更新该变量绑定的值，并发出继续正常执行的信号。



\item  若指令为 \coqdocvar{TEST} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} \coqdocvar{THEN} \coqref{LF.IndProp.R.c1}{\coqdocconstructor{c1}} \coqdocvar{ELSE} \coqref{LF.IndProp.R.c2}{\coqdocconstructor{c2}} \coqdocvar{FI} 的形式，则按照 Imp 的原始语义更新状态，
      除此之外我们还要从被选择执行的分支中传播信号。



\item  若指令为一系列 \coqref{LF.IndProp.R.c1}{\coqdocconstructor{c1}} ;; \coqref{LF.IndProp.R.c2}{\coqdocconstructor{c2}}，我们首先执行 \coqref{LF.IndProp.R.c1}{\coqdocconstructor{c1}}。如果它产生了
      \coqref{LF.Imp.BreakImp.SBreak}{\coqdocconstructor{SBreak}}，我们就跳过 \coqref{LF.IndProp.R.c2}{\coqdocconstructor{c2}} 的执行并将 \coqref{LF.Imp.BreakImp.SBreak}{\coqdocconstructor{SBreak}} 的信号传给其外围的上下文中;
      结果状态与执行 \coqref{LF.IndProp.R.c1}{\coqdocconstructor{c1}} 后获得的相同。否则，我们在执行完 \coqref{LF.IndProp.R.c1}{\coqdocconstructor{c1}} 后的状态下执行
      \coqref{LF.IndProp.R.c2}{\coqdocconstructor{c2}} 并继续传递它产生的信号。



\item  最后，对于形如 \coqdocvar{WHILE} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} \coqdocvar{DO} \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} \coqdocvar{END} 的循环，其语义基本和此前相同。
      唯一的不同是，当 \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} 求值为 \coqref{LF.Basics.true}{\coqdocconstructor{true}} 时执行 \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 并检查它产生的信号。
      若信号为 \coqref{LF.Imp.BreakImp.SContinue}{\coqdocconstructor{SContinue}}，则按照原始语义继续执行。否则，我们终止此循环的执行，
      而其结果状态与当前迭代执行的结果相同。对于其它情况，由于 \coqdocvar{BREAK}
      只终止最内层的循环，因此 \coqdocvar{WHILE} 发出 \coqref{LF.Imp.BreakImp.SContinue}{\coqdocconstructor{SContinue}} 的信号。 
\end{itemize}


 基于以上描述，请完成 \coqref{LF.Imp.BreakImp.ceval}{\coqdocinductive{ceval}} 关系的定义。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Imp.BreakImp.ceval}{ceval}{\coqdocinductive{ceval}} : \coqref{LF.Imp.BreakImp.com}{\coqdocinductive{com}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.state}{\coqdocdefinition{state}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.BreakImp.result}{\coqdocinductive{result}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Imp.state}{\coqdocdefinition{state}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Imp.BreakImp.E Skip}{E\_Skip}{\coqdocconstructor{E\_Skip}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{st},\coqdoceol
\coqdocindent{3.00em}
\coqdocvariable{st} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{=[}} \coqref{LF.Imp.BreakImp.CSkip}{\coqdocconstructor{CSkip}} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{]=>}} \coqdocvariable{st} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{/}} \coqref{LF.Imp.BreakImp.SContinue}{\coqdocconstructor{SContinue}}\coqdoceol
\coqdocindent{1.00em}
\coqdoceol
\coqdocnoindent
\coqdoceol
\coqdocindent{1.00em}
\coqdockw{where} \coqdef{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{"}{"}st '=[' c ']=>' st' '/' s" := (\coqref{LF.Imp.ceval}{\coqdocinductive{ceval}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{s} \coqdocvar{st'}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在证明你定义的 \coqref{LF.Imp.BreakImp.ceval}{\coqdocinductive{ceval}} 的如下性质： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.BreakImp.break ignore}{break\_ignore}{\coqdoclemma{break\_ignore}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{s},\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{st} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{=[}} \coqref{LF.Imp.BreakImp.:::'BREAK'}{\coqdocnotation{BREAK}}\coqref{LF.Imp.BreakImp.:::x ';;' x}{\coqdocnotation{;;}} \coqdocvariable{c} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{]=>}} \coqdocvariable{st'} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{/}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{st} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{st'}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.BreakImp.while continue}{while\_continue}{\coqdoclemma{while\_continue}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st'} \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{st} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{=[}} \coqref{LF.Imp.BreakImp.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqdocvariable{b} \coqref{LF.Imp.BreakImp.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqdocvariable{c} \coqref{LF.Imp.BreakImp.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{]=>}} \coqdocvariable{st'} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{/}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Imp.BreakImp.SContinue}{\coqdocconstructor{SContinue}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.BreakImp.while stops on break}{while\_stops\_on\_break}{\coqdoclemma{while\_stops\_on\_break}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st'},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{st} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{]=>}} \coqdocvariable{st'} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{/}} \coqref{LF.Imp.BreakImp.SBreak}{\coqdocconstructor{SBreak}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{st} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{=[}} \coqref{LF.Imp.BreakImp.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqdocvariable{b} \coqref{LF.Imp.BreakImp.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqdocvariable{c} \coqref{LF.Imp.BreakImp.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{]=>}} \coqdocvariable{st'} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{/}} \coqref{LF.Imp.BreakImp.SContinue}{\coqdocconstructor{SContinue}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, advanced, optional (while\_break\_true)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.BreakImp.while break true}{while\_break\_true}{\coqdoclemma{while\_break\_true}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c} \coqdocvar{st} \coqdocvar{st'},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{st} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{=[}} \coqref{LF.Imp.BreakImp.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{WHILE}} \coqdocvariable{b} \coqref{LF.Imp.BreakImp.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{DO}} \coqdocvariable{c} \coqref{LF.Imp.BreakImp.:::'WHILE' x 'DO' x 'END'}{\coqdocnotation{END}} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{]=>}} \coqdocvariable{st'} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{/}} \coqref{LF.Imp.BreakImp.SContinue}{\coqdocconstructor{SContinue}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Imp.beval}{\coqdocdefinition{beval}} \coqdocvariable{st'} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{st'{}'}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{st'{}'} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{]=>}} \coqdocvariable{st'} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{/}} \coqref{LF.Imp.BreakImp.SBreak}{\coqdocconstructor{SBreak}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：4 星, advanced, optional (ceval\_deterministic)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Imp.BreakImp.ceval deterministic}{ceval\_deterministic}{\coqdoclemma{ceval\_deterministic}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{c}:\coqref{LF.Imp.BreakImp.com}{\coqdocinductive{com}}) \coqdocvar{st} \coqdocvar{st1} \coqdocvar{st2} \coqdocvar{s1} \coqdocvar{s2},\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{st} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{]=>}} \coqdocvariable{st1} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{/}} \coqdocvariable{s1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{st} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{=[}} \coqdocvariable{c} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{]=>}} \coqdocvariable{st2} \coqref{LF.Imp.BreakImp.:::x '=[' x ']=>' x '/' x}{\coqdocnotation{/}} \coqdocvariable{s2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{st1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{st2} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{s1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{s2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocnoindent
\coqdockw{End} \coqref{LF.Imp.BreakImp}{\coqdocmodule{BreakImp}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：4 星, standard, optional (add\_for\_loop)}




    为该语言添加 C 风格的 \coqdockw{for} 循环指令，更新 \coqref{LF.Imp.BreakImp.ceval}{\coqdocinductive{ceval}} 的定义来定义
    \coqdockw{for} 循环，按需添加 \coqdockw{for} 循环的情况使得本文件中的所有证明都被
    Coq 所接受。


    \coqdockw{for} 循环的参数应当包含 (a) 一个初始化执行的语句；
    (b) 一个在循环的每次迭代中都执行的测试，它决定了循环是否应当继续；
    (c) 一个在循环的每次迭代最后执行的语句，以及 (d) 一个创建循环体的语句
    （你不必关心为 \coqdockw{for} 构造一个具体的记法，不过如果你喜欢，可以随意去做。） \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.Rel}{Library }{LF.Rel}

\begin{coqdoccode}
\end{coqdoccode}
\section{Rel: 关系的性质}



 本章为可选章节，主要讲述了在 Coq 定义二元关系的一些基本方法和相关定理的证明。
    关键定义会在实际用到的地方复述（\textit{'编程语言基础'}中的\coqdocvar{Smallstep}一章），
    因此熟悉这些概念的读者可以略读或跳过本章。不过，这些内容也是对 Coq
    的证明功能很好的练习，因此在读完 \coqdoclibrary{IndProp} 一章后，
    阅读本章也许会对你有所帮助。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Export} \coqref{LF.IndProp}{\coqdoclibrary{IndProp}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{关系}



 集合 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 上的二元\textit{'关系（Relation）'}指所有由两个 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 中的元素参数化的命题，
    即，有关一对 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 中的元素的命题。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Rel.relation}{relation}{\coqdocdefinition{relation}} (\coqdocvar{X}: \coqdockw{Type}) := \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
令人困惑的是，“关系”原本是个更为通用的词语，然而 Coq 标准库中的“关系”
    却单指这一种“某个集合中的元素之间二元关系”。为了与标准库保持一致，
    我们将会沿用这一定义。然而“关系”一词除了指这一意义以外，
    也可以指代任何数量的，可能是不同集合之间的更一般的关系。
    在讨论中使用“关系”一词时，应该在上下文中解释具体所指的含义。

 一个关系的例子是 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 上的 \coqref{LF.IndProp.Playground.le}{\coqdocinductive{le}}，即“小于或等于”关系，我们通常写作
    \coqdocvariable{n1} \ensuremath{\le} \coqdocvariable{n2}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqexternalref{le}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocinductive{le}}.\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqexternalref{le}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocinductive{le}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}.\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqexternalref{le}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocinductive{le}} : \coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}.\coqdoceol
\end{coqdoccode}
（为什么我们不直接写成 \coqdockw{Inductive} \coqref{LF.IndProp.Playground.le}{\coqdocinductive{le}} : \coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}... 呢？
    这是因为我们想要将第一个 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 放在 : 的左侧，这能让 Coq 为 \ensuremath{\le}
    更为友好的的归纳法则。） \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{基本性质}



 学过本科离散数学课的人都知道，与关系相关的东西有很多，
    包括对关系的性质（如自反性、传递性等），关于某类关系的一般定理，
    如何从一种关系构造出另一种关系等等。例如： \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsubsection{偏函数}



 对于集合 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 上的关系 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} ，如果对于任何 \coqdocvariable{x} 最多只有一个 \coqdocvariable{y}
    使得 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} \coqdocvariable{x} \coqdocvariable{y} 成立 -- 即，\coqref{LF.IndProp.R.R}{\coqdocinductive{R}} \coqdocvariable{x} \coqdocvariable{y1} 和 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} \coqdocvariable{x} \coqdocvariable{y2} 同时成立蕴含 \coqdocvariable{y1} = \coqdocvariable{y2}，
    则称 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 为\textit{'偏函数'}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Rel.partial function}{partial\_function}{\coqdocdefinition{partial\_function}} \{\coqdocvar{X}: \coqdockw{Type}\} (\coqdocvar{R}: \coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqdocvariable{X}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y1} \coqdocvar{y2} : \coqdocvariable{X}, \coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{y1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{y2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{y1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{y2}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
例如，之前定义的 \coqref{LF.IndProp.next nat}{\coqdocinductive{next\_nat}} 关系就是个偏函数。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqref{LF.IndProp.next nat}{\coqdocinductive{next\_nat}}.\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqref{LF.IndProp.next nat}{\coqdocinductive{next\_nat}} : \coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Rel.next nat partial function}{next\_nat\_partial\_function}{\coqdoclemma{next\_nat\_partial\_function}} :\coqdoceol
\coqdocindent{1.50em}
\coqref{LF.Rel.partial function}{\coqdocdefinition{partial\_function}} \coqref{LF.IndProp.next nat}{\coqdocinductive{next\_nat}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{LF.Rel.partial function}{\coqdocdefinition{partial\_function}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{y1} \coqdocvar{y2} \coqdocvar{H1} \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{inversion} \coqdocvar{H1}. \coqdoctac{inversion} \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
然而，数值上的 \ensuremath{\le} 关系并不是个偏函数。（利用反证法，假设 \ensuremath{\le}
    是一个偏函数。然而根据其定义我们有 0 \ensuremath{\le} 0 和 0 \ensuremath{\le} 1，这样会推出
    0 = 1。这是不可能的，所以原假设不成立。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Rel.le not a partial function}{le\_not\_a\_partial\_function}{\coqdoclemma{le\_not\_a\_partial\_function}} :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Rel.partial function}{\coqdocdefinition{partial\_function}} \coqexternalref{le}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocinductive{le}}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}}. \coqdoctac{unfold} \coqref{LF.Rel.partial function}{\coqdocdefinition{partial\_function}}. \coqdoctac{intros} \coqdocvar{Hc}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (0 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 1) \coqdockw{as} \coqdocvar{Nonsense}. \{\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{Hc} \coqdockw{with} (\coqdocvar{x} := 0).\coqdoceol
\coqdocindent{2.00em}
- \coqdoctac{apply} \coqexternalref{le n}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocconstructor{le\_n}}.\coqdoceol
\coqdocindent{2.00em}
- \coqdoctac{apply} \coqexternalref{le S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocconstructor{le\_S}}. \coqdoctac{apply} \coqexternalref{le n}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocconstructor{le\_n}}. \}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{discriminate} \coqdocvar{Nonsense}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard, optional (total\_relation\_not\_partial)}




    请证明 \coqdoclibrary{IndProp} 一章练习题中定义的 \coqdocvar{total\_relation} 不是偏函数。 \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard, optional (empty\_relation\_partial)}




    请证明 \coqdoclibrary{IndProp} 一章练习题中定义的 \coqdocvar{empty\_relation} 是偏函数。 \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\subsubsection{自反关系}



 集合 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 上的\textit{'自反关系'}是指 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 的每个元素都与其自身相关。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Rel.reflexive}{reflexive}{\coqdocdefinition{reflexive}} \{\coqdocvar{X}: \coqdockw{Type}\} (\coqdocvar{R}: \coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqdocvariable{X}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{a} : \coqdocvariable{X}, \coqdocvariable{R} \coqdocvariable{a} \coqdocvariable{a}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Rel.le reflexive}{le\_reflexive}{\coqdoclemma{le\_reflexive}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Rel.reflexive}{\coqdocdefinition{reflexive}} \coqexternalref{le}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocinductive{le}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{LF.Rel.reflexive}{\coqdocdefinition{reflexive}}. \coqdoctac{intros} \coqdocvar{n}. \coqdoctac{apply} \coqexternalref{le n}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocconstructor{le\_n}}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{传递关系}



 如果 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} 和 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 成立时 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 也成立，则称 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 为\textit{'传递关系'}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Rel.transitive}{transitive}{\coqdocdefinition{transitive}} \{\coqdocvar{X}: \coqdockw{Type}\} (\coqdocvar{R}: \coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqdocvariable{X}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c} : \coqdocvariable{X}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{R} \coqdocvariable{a} \coqdocvariable{b}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{R} \coqdocvariable{b} \coqdocvariable{c}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{R} \coqdocvariable{a} \coqdocvariable{c}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Rel.le trans}{le\_trans}{\coqdoclemma{le\_trans}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Rel.transitive}{\coqdocdefinition{transitive}} \coqexternalref{le}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocinductive{le}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{Hnm} \coqdocvar{Hmo}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{Hmo}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{apply} \coqdocvar{Hnm}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{apply} \coqexternalref{le S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocconstructor{le\_S}}. \coqdoctac{apply} \coqdocvar{IHHmo}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Rel.lt trans}{lt\_trans}{\coqdoclemma{lt\_trans}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Rel.transitive}{\coqdocdefinition{transitive}} \coqref{LF.IndProp.lt}{\coqdocdefinition{lt}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{LF.IndProp.lt}{\coqdocdefinition{lt}}. \coqdoctac{unfold} \coqref{LF.Rel.transitive}{\coqdocdefinition{transitive}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{Hnm} \coqdocvar{Hmo}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{le S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocconstructor{le\_S}} \coqdoctac{in} \coqdocvar{Hnm}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.Rel.le trans}{\coqdoclemma{le\_trans}} \coqdockw{with} (\coqdocvar{a} := (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n})) (\coqdocvar{b} := (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{m})) (\coqdocvar{c} := \coqdocvar{o}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{Hnm}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{Hmo}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard, optional (le\_trans\_hard\_way)}




    我们也可以不用 \coqref{LF.IndProp.le trans}{\coqdoclemma{le\_trans}}，直接通过归纳法来证明 \coqref{LF.Rel.lt trans}{\coqdoclemma{lt\_trans}}，
    不过这会耗费更多精力。请完成以下定理的证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Rel.lt trans'}{lt\_trans'}{\coqdoclemma{lt\_trans'}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Rel.transitive}{\coqdocdefinition{transitive}} \coqref{LF.IndProp.lt}{\coqdocdefinition{lt}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{LF.IndProp.lt}{\coqdocdefinition{lt}}. \coqdoctac{unfold} \coqref{LF.Rel.transitive}{\coqdocdefinition{transitive}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{Hnm} \coqdocvar{Hmo}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{Hmo} \coqdockw{as} [| \coqdocvar{m'} \coqdocvar{Hm'o}].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, optional (lt\_trans'')}




    再将此定理证明一遍，不过这次要对 \coqdocvariable{o} 使用归纳法。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Rel.lt trans''}{lt\_trans'{}'}{\coqdoclemma{lt\_trans'{}'}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Rel.transitive}{\coqdocdefinition{transitive}} \coqref{LF.IndProp.lt}{\coqdocdefinition{lt}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{LF.IndProp.lt}{\coqdocdefinition{lt}}. \coqdoctac{unfold} \coqref{LF.Rel.transitive}{\coqdocdefinition{transitive}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{Hnm} \coqdocvar{Hmo}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{o} \coqdockw{as} [| \coqdocvar{o'}].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 \coqref{LF.IndProp.Playground.le}{\coqdocinductive{le}} 的传递性反过来也能用于证明一些之后会用到的事实，
    例如后面对反对称性的证明： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Rel.le Sn le}{le\_Sn\_le}{\coqdoclemma{le\_Sn\_le}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m}, \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{apply} \coqref{LF.Rel.le trans}{\coqdoclemma{le\_trans}} \coqdockw{with} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqexternalref{le S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocconstructor{le\_S}}. \coqdoctac{apply} \coqexternalref{le n}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocconstructor{le\_n}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, standard, optional (le\_S\_n)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Rel.le S n}{le\_S\_n}{\coqdoclemma{le\_S\_n}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, optional (le\_Sn\_n\_inf)}




    请提写出以下定理的非形式化证明：


    Theorem: For every \coqdocvariable{n}, \ensuremath{\lnot} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n} \ensuremath{\le} \coqdocvariable{n})


    此定理的形式化证明在下面作为可选的练习，
    不过在做形式化证明之前请先尝试写出非形式化的证明。


    证明： \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, standard, optional (le\_Sn\_n)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Rel.le Sn n}{le\_Sn\_n}{\coqdoclemma{le\_Sn\_n}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{n}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 在后面的章节中，我们主要会用到自反性和传递性。不过，
    我们先看一些其它的概念，作为在 Coq 中对关系进行操作的练习... \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsubsection{对称关系与反对称关系}



 如果 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} 蕴含 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}}，那么 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 就是\textit{'对称关系'}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Rel.symmetric}{symmetric}{\coqdocdefinition{symmetric}} \{\coqdocvar{X}: \coqdockw{Type}\} (\coqdocvar{R}: \coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqdocvariable{X}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b} : \coqdocvariable{X}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{R} \coqdocvariable{a} \coqdocvariable{b}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{R} \coqdocvariable{b} \coqdocvariable{a}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard, optional (le\_not\_symmetric)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Rel.le not symmetric}{le\_not\_symmetric}{\coqdoclemma{le\_not\_symmetric}} :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Rel.symmetric}{\coqdocdefinition{symmetric}} \coqexternalref{le}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocinductive{le}}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 如果 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} 和 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 成立时有 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} = \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}}，那么 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 就是\textit{'反对称关系'}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Rel.antisymmetric}{antisymmetric}{\coqdocdefinition{antisymmetric}} \{\coqdocvar{X}: \coqdockw{Type}\} (\coqdocvar{R}: \coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqdocvariable{X}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b} : \coqdocvariable{X}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{R} \coqdocvariable{a} \coqdocvariable{b}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{R} \coqdocvariable{b} \coqdocvariable{a}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{a} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{b}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard, optional (le\_antisymmetric)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Rel.le antisymmetric}{le\_antisymmetric}{\coqdoclemma{le\_antisymmetric}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Rel.antisymmetric}{\coqdocdefinition{antisymmetric}} \coqexternalref{le}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocinductive{le}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, optional (le\_step)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Rel.le step}{le\_step}{\coqdoclemma{le\_step}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqref{LF.IndProp.:::x '<' x}{\coqdocnotation{<}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{m} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{p} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsubsection{等价关系}



 如果一个关系满足自反性、对称性和传递性，那么它就是\textit{'等价关系'}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Rel.equivalence}{equivalence}{\coqdocdefinition{equivalence}} \{\coqdocvar{X}:\coqdockw{Type}\} (\coqdocvar{R}: \coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqdocvariable{X}) :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Rel.reflexive}{\coqdocdefinition{reflexive}} \coqdocvariable{R}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Rel.symmetric}{\coqdocdefinition{symmetric}} \coqdocvariable{R}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Rel.transitive}{\coqdocdefinition{transitive}} \coqdocvariable{R}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{偏序关系与预序关系}



 如果某个关系满足自反性、\textit{'反'}对称性和传递性，那么它就一个是\textit{'偏序关系'}。
    在 Coq 标准库中，它被简短地称作“order”。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Rel.order}{order}{\coqdocdefinition{order}} \{\coqdocvar{X}:\coqdockw{Type}\} (\coqdocvar{R}: \coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqdocvariable{X}) :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Rel.reflexive}{\coqdocdefinition{reflexive}} \coqdocvariable{R}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Rel.antisymmetric}{\coqdocdefinition{antisymmetric}} \coqdocvariable{R}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Rel.transitive}{\coqdocdefinition{transitive}} \coqdocvariable{R}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
预序和偏序差不多，不过它无需满足反对称性。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Rel.preorder}{preorder}{\coqdocdefinition{preorder}} \{\coqdocvar{X}:\coqdockw{Type}\} (\coqdocvar{R}: \coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqdocvariable{X}) :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Rel.reflexive}{\coqdocdefinition{reflexive}} \coqdocvariable{R}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Rel.transitive}{\coqdocdefinition{transitive}} \coqdocvariable{R}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Rel.le order}{le\_order}{\coqdoclemma{le\_order}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Rel.order}{\coqdocdefinition{order}} \coqexternalref{le}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocinductive{le}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{LF.Rel.order}{\coqdocdefinition{order}}. \coqdoctac{split}.\coqdoceol
\coqdocindent{2.00em}
-  \coqdoctac{apply} \coqref{LF.Rel.le reflexive}{\coqdoclemma{le\_reflexive}}.\coqdoceol
\coqdocindent{2.00em}
- \coqdoctac{split}.\coqdoceol
\coqdocindent{3.00em}
+  \coqdoctac{apply} \coqref{LF.Rel.le antisymmetric}{\coqdocaxiom{le\_antisymmetric}}.\coqdoceol
\coqdocindent{3.00em}
+  \coqdoctac{apply} \coqref{LF.Rel.le trans}{\coqdoclemma{le\_trans}}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{自反传递闭包}



 关系 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 的\textit{'自反传递闭包'}是最小的包含 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 的自反传递关系。
    在 Coq 标准库的 Relations 模块中，此概念定义如下：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Rel.clos refl trans}{clos\_refl\_trans}{\coqdocinductive{clos\_refl\_trans}} \{\coqdocvar{A}: \coqdockw{Type}\} (\coqdocvar{R}: \coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqdocvariable{A}) : \coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqdocvar{A} :=\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdef{LF.Rel.rt step}{rt\_step}{\coqdocconstructor{rt\_step}} \coqdocvar{x} \coqdocvar{y} (\coqdocvar{H} : \coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{y}) : \coqref{LF.Rel.clos refl trans}{\coqdocinductive{clos\_refl\_trans}} \coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{y}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdef{LF.Rel.rt refl}{rt\_refl}{\coqdocconstructor{rt\_refl}} \coqdocvar{x} : \coqref{LF.Rel.clos refl trans}{\coqdocinductive{clos\_refl\_trans}} \coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{x}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdef{LF.Rel.rt trans}{rt\_trans}{\coqdocconstructor{rt\_trans}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}\coqdoceol
\coqdocindent{5.00em}
(\coqdocvar{Hxy} : \coqref{LF.Rel.clos refl trans}{\coqdocinductive{clos\_refl\_trans}} \coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{y})\coqdoceol
\coqdocindent{5.00em}
(\coqdocvar{Hyz} : \coqref{LF.Rel.clos refl trans}{\coqdocinductive{clos\_refl\_trans}} \coqdocvariable{R} \coqdocvariable{y} \coqdocvariable{z}) :\coqdoceol
\coqdocindent{5.00em}
\coqref{LF.Rel.clos refl trans}{\coqdocinductive{clos\_refl\_trans}} \coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{z}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
例如，\coqref{LF.IndProp.next nat}{\coqdocinductive{next\_nat}} 关系的自反传递闭包实际上就是 \coqref{LF.IndProp.Playground.le}{\coqdocinductive{le}}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Rel.next nat closure is le}{next\_nat\_closure\_is\_le}{\coqdoclemma{next\_nat\_closure\_is\_le}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}(\coqref{LF.Rel.clos refl trans}{\coqdocinductive{clos\_refl\_trans}} \coqref{LF.IndProp.next nat}{\coqdocinductive{next\_nat}}) \coqdocvariable{n} \coqdocvariable{m}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intro} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{apply} \coqref{LF.Rel.rt refl}{\coqdocconstructor{rt\_refl}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{LF.Rel.rt trans}{\coqdocconstructor{rt\_trans}} \coqdockw{with} \coqdocvar{m}. \coqdoctac{apply} \coqdocvar{IHle}. \coqdoctac{apply} \coqref{LF.Rel.rt step}{\coqdocconstructor{rt\_step}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{LF.IndProp.nn}{\coqdocconstructor{nn}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intro} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{apply} \coqexternalref{le S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocconstructor{le\_S}}. \coqdoctac{apply} \coqexternalref{le n}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocconstructor{le\_n}}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{apply} \coqexternalref{le n}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocconstructor{le\_n}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{LF.Rel.le trans}{\coqdoclemma{le\_trans}} \coqdockw{with} \coqdocvar{y}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHclos\_refl\_trans1}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHclos\_refl\_trans2}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
以上对自反传递闭包的定义十分自然：它直接将自反传递闭包定义为“包含
    \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 的，同时满足自反性和传递性的最小的关系”。
    然而此定义对于证明来说不是很方便，因为 \coqref{LF.Rel.rt trans}{\coqdocconstructor{rt\_trans}} 的“非确定性”
    有时会让归纳变得很棘手。下面是最常用的定义： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Rel.clos refl trans 1n}{clos\_refl\_trans\_1n}{\coqdocinductive{clos\_refl\_trans\_1n}} \{\coqdocvar{A} : \coqdockw{Type}\}\coqdoceol
\coqdocindent{14.50em}
(\coqdocvar{R} : \coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqdocvariable{A}) (\coqdocvar{x} : \coqdocvariable{A})\coqdoceol
\coqdocindent{14.50em}
: \coqdocvar{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Rel.rt1n refl}{rt1n\_refl}{\coqdocconstructor{rt1n\_refl}} : \coqref{LF.Rel.clos refl trans 1n}{\coqdocinductive{clos\_refl\_trans\_1n}} \coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{x}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Rel.rt1n trans}{rt1n\_trans}{\coqdocconstructor{rt1n\_trans}} (\coqdocvar{y} \coqdocvar{z} : \coqdocvariable{A})\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{Hxy} : \coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{y}) (\coqdocvar{Hrest} : \coqref{LF.Rel.clos refl trans 1n}{\coqdocinductive{clos\_refl\_trans\_1n}} \coqdocvariable{R} \coqdocvariable{y} \coqdocvariable{z}) :\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Rel.clos refl trans 1n}{\coqdocinductive{clos\_refl\_trans\_1n}} \coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{z}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这一新的定义将 \coqref{LF.Rel.rt step}{\coqdocconstructor{rt\_step}} 和 \coqref{LF.Rel.rt trans}{\coqdocconstructor{rt\_trans}} 合并成一条。在此规则的假设中
    \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 只用了一次，这会让归纳法则更简单。


    在使用这一定义并继续之前，我们需要检查这两个定义确实定义了相同的关系...


    首先，我们来证明 \coqref{LF.Rel.clos refl trans 1n}{\coqdocinductive{clos\_refl\_trans\_1n}} 模仿了两个“缺失”
    的 \coqref{LF.Rel.clos refl trans}{\coqdocinductive{clos\_refl\_trans}} 构造子的行为。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Rel.rsc R}{rsc\_R}{\coqdoclemma{rsc\_R}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{R}:\coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqdocvariable{X}) (\coqdocvar{x} \coqdocvar{y} : \coqdocvariable{X}),\coqdoceol
\coqdocindent{3.50em}
\coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Rel.clos refl trans 1n}{\coqdocinductive{clos\_refl\_trans\_1n}} \coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{R} \coqdocvar{x} \coqdocvar{y} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.Rel.rt1n trans}{\coqdocconstructor{rt1n\_trans}} \coqdockw{with} \coqdocvar{y}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{apply} \coqref{LF.Rel.rt1n refl}{\coqdocconstructor{rt1n\_refl}}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard, optional (rsc\_trans)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Rel.rsc trans}{rsc\_trans}{\coqdoclemma{rsc\_trans}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{R}: \coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqdocvariable{X}) (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvariable{X}),\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Rel.clos refl trans 1n}{\coqdocinductive{clos\_refl\_trans\_1n}} \coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{y}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Rel.clos refl trans 1n}{\coqdocinductive{clos\_refl\_trans\_1n}} \coqdocvariable{R} \coqdocvariable{y} \coqdocvariable{z} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.Rel.clos refl trans 1n}{\coqdocinductive{clos\_refl\_trans\_1n}} \coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{z}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 接着再用这些事实来证明这两个定义的自反性、
    传递性封闭确实定义了同样的关系。 

\paragraph{练习：3 星, standard, optional (rtc\_rsc\_coincide)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Rel.rtc rsc coincide}{rtc\_rsc\_coincide}{\coqdoclemma{rtc\_rsc\_coincide}} :\coqdoceol
\coqdocindent{4.50em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{R}: \coqref{LF.Rel.relation}{\coqdocdefinition{relation}} \coqdocvariable{X}) (\coqdocvar{x} \coqdocvar{y} : \coqdocvariable{X}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Rel.clos refl trans}{\coqdocinductive{clos\_refl\_trans}} \coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{y} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{LF.Rel.clos refl trans 1n}{\coqdocinductive{clos\_refl\_trans\_1n}} \coqdocvariable{R} \coqdocvariable{x} \coqdocvariable{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.IndPrinciples}{Library }{LF.IndPrinciples}

\begin{coqdoccode}
\end{coqdoccode}
\section{IndPrinciples: 归纳法则}



 在理解了柯里-霍华德同构及其 Coq 实现之后，我们就可以深入学习归纳法则了。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Export} \coqref{LF.ProofObjects}{\coqdoclibrary{ProofObjects}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{基础}



 每当我们使用 \coqdockw{Inductive} 来声明数据类型时，Coq 就会自动为该类型生成
    \textit{'归纳法则'}。这个归纳法则也是定理：如果 \coqdocvariable{t} 是归纳定义的，那么对应的
    归纳法则被称作 \coqdocvar{t\_ind}。这是自然数的归纳法则： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqexternalref{nat ind}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{nat\_ind}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In English: Suppose \coqdocvariable{P} is a property of natural numbers (that is,
      \coqdocvariable{P} \coqdocvariable{n} is a \coqdockw{Prop} for every \coqdocvariable{n}). To show that \coqdocvariable{P} \coqdocvariable{n} holds of all
      \coqdocvariable{n}, it suffices to show:



\begin{itemize}
\item  \coqdocvariable{P} holds of 0

\item  for any \coqdocvariable{n}, if \coqdocvariable{P} holds of \coqdocvariable{n}, then \coqdocvariable{P} holds of \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}. 
\end{itemize}


 \coqdoctac{induction} 利用归纳法则，执行 \coqdoctac{apply} \coqdocvar{t\_ind} 等策略。
    为了清楚地理解这一点，让我们直接使用 \coqdoctac{apply} \coqexternalref{nat ind}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{nat\_ind}} 而非 \coqdoctac{induction}
    策略来证明。例如，\coqdockw{Induction} 一章中 \coqref{LF.IndPrinciples.mult 0 r'}{\coqdoclemma{mult\_0\_r'}} 定理的另一种证明如下所示。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndPrinciples.mult 0 r'}{mult\_0\_r'}{\coqdoclemma{mult\_0\_r'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} 0 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{nat ind}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{nat\_ind}}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{n'} \coqdocvar{IHn'}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHn'}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这个证明基本上等同于之前的，但有几点区别值得注意。


    首先，在证明的归纳步骤（"\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}}" 情形）中，我们不得不手动管理变量名（即 \coqdoctac{intros}），
    而 \coqdoctac{induction} 会自动完成这些。


    其次，在应用 \coqexternalref{nat ind}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{nat\_ind}} 之前我们没有在上下文中引入 \coqdocvariable{n} —— \coqexternalref{nat ind}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{nat\_ind}} 的结论
    是一个带有量词的公式，\coqdoctac{apply} 需要这个结论精确地匹配当前证明目标状态的形状，包括其中的量词。
    相反，\coqdoctac{induction} 策略对于上下文中的变量或目标中由量词引入的变量都适用。


    第三，我们必须手动为 \coqdoctac{apply} 提供归纳法则，而 \coqdoctac{induction} 可以自己解决它。


    相比于直接使用 \coqexternalref{nat ind}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{nat\_ind}} 这样的归纳法则，在实践中使用 \coqdoctac{induction} 更加方便。
    但重要的是认识到除了这一点变量名的管理工作，我们在做的其实就是应用 \coqexternalref{nat ind}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{nat\_ind}}。 

\paragraph{练习：2 星, standard, optional (plus\_one\_r')}




    请不使用 \coqdoctac{induction} 策略来完成这个证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndPrinciples.plus one r'}{plus\_one\_r'}{\coqdoclemma{plus\_one\_r'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 Coq 为每一个 \coqdockw{Inductive} 定义的数据类型生成了归纳法则，包括那些非递归的。
    尽管我们不需要归纳，便可证明非递归数据类型的性质，但归纳原理仍可用来证明其性质；
    给定类型，及关于该类型所有值的性质，归纳原理提供了证明该性质的方法。 

 这些生成的原则都具有类似的模式。如果我们定义了带有构造子 \coqref{LF.IndProp.R.c1}{\coqdocconstructor{c1}} ... \coqdocvar{cn}
    的类型 \coqdocvariable{t}，那么 Coq 会生成形如下文的定理：


    t\_ind : forall P : t -> Prop,
              ... case for c1 ... ->
              ... case for c2 ... -> ...
              ... case for cn ... ->
              forall n : t, P n


    每个情形具体的形状取决于对应构造子的参数。 

 在尝试总结出一般规律前，让我们先来看看更多的例子。
    首先是一个无参数构造子的例子： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndPrinciples.time}{time}{\coqdocinductive{time}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndPrinciples.day}{day}{\coqdocconstructor{day}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndPrinciples.night}{night}{\coqdocconstructor{night}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.IndPrinciples.time ind}{\coqdocdefinition{time\_ind}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, standard, optional (rgb)}




    对如下数据类型，请写出 Coq 将会生成的归纳法则。
    先在纸上或注释内写下你的答案，然后同 Coq 打印出的结果比较。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndPrinciples.rgb}{rgb}{\coqdocinductive{rgb}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndPrinciples.red}{red}{\coqdocconstructor{red}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndPrinciples.green}{green}{\coqdocconstructor{green}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndPrinciples.blue}{blue}{\coqdocconstructor{blue}}.\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqref{LF.IndPrinciples.rgb ind}{\coqdocdefinition{rgb\_ind}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 下文例子中，有一个构造子调取多个参数。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndPrinciples.natlist}{natlist}{\coqdocinductive{natlist}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndPrinciples.nnil}{nnil}{\coqdocconstructor{nnil}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndPrinciples.ncons}{ncons}{\coqdocconstructor{ncons}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{l} : \coqref{LF.IndPrinciples.natlist}{\coqdocinductive{natlist}}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.IndPrinciples.natlist ind}{\coqdocdefinition{natlist\_ind}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, standard, optional (natlist1)}




    假设我们写下的定义和上面的有一些区别： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndPrinciples.natlist1}{natlist1}{\coqdocinductive{natlist1}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndPrinciples.nnil1}{nnil1}{\coqdocconstructor{nnil1}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndPrinciples.nsnoc1}{nsnoc1}{\coqdocconstructor{nsnoc1}} (\coqdocvar{l} : \coqref{LF.IndPrinciples.natlist1}{\coqdocinductive{natlist1}}) (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在归纳法则会是什么呢？


    \ensuremath{\Box} 

 通常，为归纳类型 \coqdocvariable{t} 生成的归纳法则形式如下：



\begin{itemize}
\item  每个构造子 \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 都会生成归纳法则中的一种情况

\item  若 \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 不接受参数，该情况为


      “P 对 c 成立”



\item  若 \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 接受参数 \coqdocvariable{x1}:\coqdocvariable{a1} ... \coqdocvar{xn}:\coqdocvar{an}，该情况为：


      “对于所有的 x1:a1 ... xn:an，
          若 \coqdocvariable{P} 对每个类型为 \coqdocvariable{t} 的函数都成立，
          则 \coqdocvariable{P} 对于 \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} \coqdocvariable{x1} ... \coqdocvar{xn} 成立”

\end{itemize}


\paragraph{练习：1 星, standard, optional (booltree\_ind)}




    对如下数据类型，请写出 Coq 将会生成的归纳法则。
   （与之前一样，先在纸上或注释内写下你的答案，然后同 Coq 打印出的结果比较。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndPrinciples.booltree}{booltree}{\coqdocinductive{booltree}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{0.50em}
\ensuremath{|} \coqdef{LF.IndPrinciples.bt empty}{bt\_empty}{\coqdocconstructor{bt\_empty}}\coqdoceol
\coqdocindent{0.50em}
\ensuremath{|} \coqdef{LF.IndPrinciples.bt leaf}{bt\_leaf}{\coqdocconstructor{bt\_leaf}} (\coqdocvar{b} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}})\coqdoceol
\coqdocindent{0.50em}
\ensuremath{|} \coqdef{LF.IndPrinciples.bt branch}{bt\_branch}{\coqdocconstructor{bt\_branch}} (\coqdocvar{b} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{t1} \coqdocvar{t2} : \coqref{LF.IndPrinciples.booltree}{\coqdocinductive{booltree}}).\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：1 星, standard, optional (ex\_set)}




    这是对一个归纳定义的集合的归纳法则。


      ExSet\_ind :
         forall P : ExSet -> Prop,
             (forall b : bool, P (con1 b)) ->
             (forall (n : nat) (e : ExSet), P e -> P (con2 n e)) ->
             forall e : ExSet, P e


    请写出使用 \coqdockw{Inductive} 来定义的 \coqref{LF.IndPrinciples.ExSet}{\coqdocinductive{ExSet}}： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndPrinciples.ExSet}{ExSet}{\coqdocinductive{ExSet}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoceol
\coqdocnoindent
.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{多态}



 多态数据结构会是怎样的呢？


    归纳定义的多态列表


      Inductive list (X:Type) : Type :=
        | nil : list X
        | cons : X -> list X -> list X.


    同 \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}} 是十分相似的。主要的区别是，这里全部的定义是由集合 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 所\textit{'参数化'}的：
    也即，我们定义了\textit{'一族'}归纳类型 \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}}，对于每个 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 有其对应的类型在此族中。
    （请注意，当 \coqref{LF.Poly.list}{\coqdocinductive{list}} 出现在声明体中时，它总是被应用参数 \coqref{LF.Imp.X}{\coqdocdefinition{X}}。）


  归纳法则同样被 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 所参数化：


      list\_ind :
        forall (X : Type) (P : list X -> Prop),
           P \ensuremath{\Box} ->
           (forall (x : X) (l : list X), P l -> P (x :: l)) ->
           forall l : list X, P l


    请注意归纳法则的\textit{'所有部分'}都被 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 所参数化。也即，\coqdocvar{list\_ind} 可认为是一个
    多态函数，当被应用类型 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 时，返回特化在类型 \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} 上的归纳法则。 

\paragraph{练习：1 星, standard, optional (tree)}




    对如下数据类型，请写出 Coq 将会生成的归纳法则，并与 Coq 打印出的结果比较。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndPrinciples.tree}{tree}{\coqdocinductive{tree}} (\coqdocvar{X}:\coqdockw{Type}) : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndPrinciples.leaf}{leaf}{\coqdocconstructor{leaf}} (\coqdocvar{x} : \coqdocvariable{X})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndPrinciples.node}{node}{\coqdocconstructor{node}} (\coqdocvar{t1} \coqdocvar{t2} : \coqref{LF.IndPrinciples.tree}{\coqdocinductive{tree}} \coqdocvariable{X}).\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqref{LF.IndPrinciples.tree ind}{\coqdocdefinition{tree\_ind}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：1 星, standard, optional (mytype)}




    请找到对应于以下归纳法则的归纳定义：


      mytype\_ind :
        forall (X : Type) (P : mytype X -> Prop),
            (forall x : X, P (constr1 X x)) ->
            (forall n : nat, P (constr2 X n)) ->
            (forall m : mytype X, P m ->
               forall n : nat, P (constr3 X m n)) ->
            forall m : mytype X, P m
 \ensuremath{\Box} 

\paragraph{练习：1 星, standard, optional (foo)}




    请找到对应于以下归纳法则的归纳定义：


      foo\_ind :
        forall (X Y : Type) (P : foo X Y -> Prop),
             (forall x : X, P (bar X Y x)) ->
             (forall y : Y, P (baz X Y y)) ->
             (forall f1 : nat -> foo X Y,
               (forall n : nat, P (f1 n)) -> P (quux X Y f1)) ->
             forall f2 : foo X Y, P f2
 \ensuremath{\Box} 

\paragraph{练习：1 星, standard, optional (foo')}




    请考虑以下归纳定义： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndPrinciples.foo'}{foo'}{\coqdocinductive{foo'}} (\coqdocvar{X}:\coqdockw{Type}) : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndPrinciples.C1}{C1}{\coqdocconstructor{C1}} (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) (\coqdocvar{f} : \coqref{LF.IndPrinciples.foo'}{\coqdocinductive{foo'}} \coqdocvariable{X})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndPrinciples.C2}{C2}{\coqdocconstructor{C2}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Coq 会为 \coqref{LF.IndPrinciples.foo'}{\coqdocinductive{foo'}} 生成什么归纳法则？请填写下面的空白，并使用 Coq 检查你的答案。


     foo'\_ind :
        forall (X : Type) (P : foo' X -> Prop),
              (forall (l : list X) (f : foo' X),
                    \textit{\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_} ->
                    \textit{\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_}   ) ->
             \textit{\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_} ->
             forall f : foo' X, \textit{\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_}


 \ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{归纳假设}



 “归纳假设”是在什么语境下出现的呢？


    对于数的归纳法则：


       forall P : nat -> Prop,
            P 0  ->
            (forall n : nat, P n -> P (S n))  ->
            forall n : nat, P n


  是一个对于所有命题 \coqdocvariable{P} （或更严格地说，对由数字 \coqdocvariable{n} 索引的所有命题 \coqdocvariable{P}）
  都成立的泛化陈述。每次使用这个原理，我们将 \coqdocvariable{P} 特化为一个类型为 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} \ensuremath{\rightarrow} \coqdockw{Prop}
  的表达式。


  通过命名这个表达式，我们可以让归纳证明更加明确。比如，除了陈述定理
  \coqref{LF.Induction.mult 0 r}{\coqdoclemma{mult\_0\_r}} 为 “\coqdockw{\ensuremath{\forall}} \coqdocvariable{n}, \coqdocvariable{n} \ensuremath{\times} 0 = 0”，我们还可以写成
  “\coqdockw{\ensuremath{\forall}} \coqdocvariable{n}, \coqref{LF.IndPrinciples.P m0r}{\coqdocdefinition{P\_m0r}} \coqdocvariable{n}”，其中 \coqdocvar{O\_m0r} 定义为…… \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.IndPrinciples.P m0r}{P\_m0r}{\coqdocdefinition{P\_m0r}} (\coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} 0 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
……或等价地： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.IndPrinciples.P m0r'}{P\_m0r'}{\coqdocdefinition{P\_m0r'}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} \coqdocvar{n} \ensuremath{\Rightarrow} \coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} 0 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在看看 \coqref{LF.IndPrinciples.P m0r}{\coqdocdefinition{P\_m0r}} 在证明中出现在哪里。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndPrinciples.mult 0 r''}{mult\_0\_r'{}'}{\coqdoclemma{mult\_0\_r'{}'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndPrinciples.P m0r}{\coqdocdefinition{P\_m0r}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqexternalref{nat ind}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{nat\_ind}}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{IHn}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqref{LF.IndPrinciples.P m0r}{\coqdocdefinition{P\_m0r}} \coqdoctac{in} \coqdocvar{IHn}. \coqdoctac{unfold} \coqref{LF.IndPrinciples.P m0r}{\coqdocdefinition{P\_m0r}}. \coqdoctac{simpl}. \coqdoctac{apply} \coqdocvar{IHn}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
通常我们并不会在证明中额外地为命题命名，但有意地进行一两个练习
    可以帮助我们清晰地看到哪个是归纳假设。
    如果对 \coqdocvariable{n} 归纳来证明 \coqdockw{\ensuremath{\forall}} \coqdocvariable{n}, \coqref{LF.IndPrinciples.P m0r}{\coqdocdefinition{P\_m0r}} \coqdocvariable{n}（使用 \coqdoctac{induction}
    或 \coqdoctac{apply} \coqexternalref{nat ind}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{nat\_ind}}），可以看到第一个子目标要求我们证明 \coqref{LF.IndPrinciples.P m0r}{\coqdocdefinition{P\_m0r}} 0
    （“\coqdocvariable{P} 对零成立”），而第二个子目标要求我们证明 \coqdockw{\ensuremath{\forall}} \coqdocvariable{n'}, \coqref{LF.IndPrinciples.P m0r}{\coqdocdefinition{P\_m0r}} \coqdocvariable{n'} \ensuremath{\rightarrow} \coqref{LF.IndPrinciples.P m0r}{\coqdocdefinition{P\_m0r}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'})
    （也即，“\coqdocvariable{P} 对 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'} 成立仅当其对 \coqdocvariable{n'} 成立”，或者说，“\coqdocvariable{P} 被 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 保持”）。
    \textit{'归纳假设'}是后一个蕴含式中的前提部分，即假设 \coqdocvariable{P} 对 \coqdocvariable{n'} 成立，这是我们在证明 \coqdocvariable{P}
    对 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'} 的过程中允许使用的。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{深入 \texorpdfstring{\protect\coqdoctac{induction}}{induction} 策略}



 \coqdoctac{induction} 策略事实上为我们做了更多低层次的工作。


    请回忆一下自然数归纳法则的非形式化陈述：

\begin{itemize}
\item  如果 \coqdocvariable{P} \coqdocvariable{n} 是某个涉及到数字 n 的命题，我们想要证明 \coqdocvariable{P} 对于\textit{'所有'}数字 n
        都成立，我们以如下方式推理：

\begin{itemize}
\item  证明 \coqdocvariable{P} 0 成立

\item  证明如果 \coqdocvariable{P} \coqdocvariable{n'} 成立，那么 \coqdocvariable{P} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}) 成立

\item  得出结论 \coqdocvariable{P} \coqdocvariable{n} 对所有 n 成立。

\end{itemize}

\end{itemize}
    因此，当以 \coqdoctac{intros} \coqdocvariable{n} 和 \coqdoctac{induction} \coqdocvariable{n} 开始一个证明时，我们首先在告诉 Coq
    考虑一个\textit{'特殊的'} \coqdocvariable{n}（通过引入到上下文中），然后告诉它证明一些关于
    \textit{'全体'}数字的性质（通过使用归纳）。


  在这种情况下，Coq 事实上在内部“再次一般化（re-generalize）”了我们进行归纳的变量。
    比如说，起初证明 \coqref{LF.Basics.NatPlayground2.plus}{\coqdocdefinition{plus}} 的结合性时……  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndPrinciples.plus assoc'}{plus\_assoc'}{\coqdoclemma{plus\_assoc'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHn'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
对目标中含有量词的变量应用 \coqdoctac{induction} 同样可以工作。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndPrinciples.plus comm'}{plus\_comm'}{\coqdoclemma{plus\_comm'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{intros} \coqdocvar{m}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{LF.Induction.plus n O}{\coqdoclemma{plus\_n\_O}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{intros} \coqdocvar{m}. \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHn'}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{LF.Induction.plus n Sm}{\coqdocaxiom{plus\_n\_Sm}}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
请注意，使用 \coqdoctac{induction} 后 \coqdocvariable{m} 在目标中仍然是绑定的，
    也即，归纳证明的陈述是以 \coqdockw{\ensuremath{\forall}} \coqdocvariable{m} 开始的。


    如果我们对目标中其他量词\textit{'后'}的量化变量使用 \coqdoctac{induction}，那么它会自动
    引入全部被量词绑定的变量到上下文中。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndPrinciples.plus comm''}{plus\_comm'{}'}{\coqdoclemma{plus\_comm'{}'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{m} \coqdockw{as} [| \coqdocvar{m'}]. \coqdocindent{1.00em}
-  \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{LF.Induction.plus n O}{\coqdoclemma{plus\_n\_O}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{IHm'}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{LF.Induction.plus n Sm}{\coqdocaxiom{plus\_n\_Sm}}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, standard, optional (plus\_explicit\_prop)}




    以类似 \coqref{LF.IndPrinciples.mult 0 r''}{\coqdoclemma{mult\_0\_r'{}'}} 的方式来重写 \coqref{LF.Induction.plus assoc'}{\coqdoclemma{plus\_assoc'}}，\coqref{LF.IndPrinciples.plus comm'}{\coqdoclemma{plus\_comm'}} 和它们的证明——
    对于每个定理，给出一个明确的命题的 \coqdockw{Definition}，陈述定理并用归纳法证明这个
    定义的命题。 \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\section{\texorpdfstring{\protect\coqdockw{Prop}}{Prop} 中的归纳法则}



 之前，我们仔细学习了 Coq 为归纳定义的\textit{'集合'}生成的归纳法则。 像 \coqref{LF.Logic.even}{\coqdocdefinition{even}}
    这样的归纳定义\textit{'命题'}的归纳法则会复杂一点点。就全部归纳法则来说，我们想要
    通过使用 \coqref{LF.Logic.even}{\coqdocdefinition{even}} 的归纳法则并归纳地考虑 \coqref{LF.Logic.even}{\coqdocdefinition{even}} 中所有可能的形式来证明一些东西。
    然而，直观地讲，我们想要证明的东西并不是关于\textit{'证据'}的陈述，而是关于
    \textit{'自然数'}的陈述：因此，我们想要让归纳法则允许通过对证据进行归纳来
    证明关于数字的性质。例如：


 根据我们前面所讲，你可能会期待这样归纳定义的 \coqref{LF.Logic.even}{\coqdocdefinition{even}}……


      Inductive even : nat -> Prop :=
      | ev\_0 : even 0
      | ev\_SS : forall n : nat, even n -> even (S (S n)).


    ……并给我们下面这样的归纳法则……


    ev\_ind\_max : forall P : (forall n : nat, even n -> Prop),
         P O ev\_0 ->
         (forall (m : nat) (E : even m),
            P m E ->
            P (S (S m)) (ev\_SS m E)) ->
         forall (n : nat) (E : even n),
         P n E




   ……因为：



\begin{itemize}
\item  由于 \coqref{LF.Logic.even}{\coqdocdefinition{even}} 被自然数 \coqdocvariable{n} 所索引（任何 \coqref{LF.Logic.even}{\coqdocdefinition{even}} 对象 \coqdocvar{E} 都是某个自然数 \coqdocvariable{n}
       是偶数的证据），且命题 \coqdocvariable{P} 同时被 \coqdocvariable{n} 和 \coqdocvar{E} 所参数化——因此，被用于证明断言的
       归纳法则同时涉及到一个偶数和这个数是偶数的证据。



\item  由于有两种方法来给出偶数性质的证据（因为 \coqref{LF.Logic.even}{\coqdocdefinition{even}} 有两个构造子），我们应用归纳法则生成
       了两个子目标：



\begin{itemize}
\item  须证明 \coqdocvariable{P} 对 0 和 \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}} 成立。



\item  须证明，当 \coqdocvariable{m} 是一个自然数且 \coqdocvar{E} 是其偶数性质的证据，如果 \coqdocvariable{P}
           对 \coqdocvariable{m} 和 \coqdocvar{E} 成立，那么它也对 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{m}) 和 \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} \coqdocvariable{m} \coqdocvar{E} 成立。



\end{itemize}

\item  如果这些子目标可以被证明，那么归纳法则告诉我们 \coqdocvariable{P} 对所有的偶数 \coqdocvariable{n}
       和它们的偶数性质 \coqdocvar{E} 成立。

\end{itemize}


    这比我们通常需要的或想要的更灵活一点：它为我们提供了一种方式证明逻辑断言，
    其断言涉及到一些关于偶数的证据的性质，然而我们真正想要的是证明某些\textit{'自然数'}
    是偶数这样的性质——我们感兴趣的是关于自然数的断言，而非关于证据。如果对于命题 \coqdocvariable{P}
    的归纳法则仅仅被 \coqdocvariable{n} 所参数化，且其结论是 \coqdocvariable{P} 对所有偶数 \coqdocvariable{n} 成立，那会方便许多：


       forall P : nat -> Prop,
         ... ->
       forall n : nat,
         even n -> P n


    出于这样的原因，Coq 实际上为 \coqref{LF.Logic.even}{\coqdocdefinition{even}} 生成了简化过的归纳法则： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.IndProp.ev ind}{\coqdocdefinition{ev\_ind}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
请特别注意，Coq 丢弃了命题 \coqdocvariable{P} 参数中的证据项 \coqdocvar{E}。 

 若用自然语言来表述 \coqref{LF.IndProp.ev ind}{\coqdocdefinition{ev\_ind}}，则是说：假设 \coqdocvariable{P} 是关于自然数的一个性质
    （也即，\coqdocvariable{P} \coqdocvariable{n} 是一个在全体 \coqdocvariable{n} 上的 \coqdockw{Prop}）。为了证明当 \coqdocvariable{n} 是偶数时
    \coqdocvariable{P} \coqdocvariable{n} 成立，需要证明：



\begin{itemize}
\item  \coqdocvariable{P} 对 0 成立，



\item  对任意 \coqdocvariable{n}，如果 \coqdocvariable{n} 是偶数且 \coqdocvariable{P} 对 \coqdocvariable{n} 成立，那么 \coqdocvariable{P} 对 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}) 成立。 
\end{itemize}


 正如期待的那样，我们可以不使用 \coqdoctac{induction} 而直接应用 \coqref{LF.IndProp.ev ind}{\coqdocdefinition{ev\_ind}}。
    比如，我们可以使用它来证明 \coqref{LF.IndProp.ev'}{\coqdocinductive{ev'}}（就是在 \coqdoclibrary{IndProp}
    一章的练习中那个有点笨拙的偶数性质的定义）等价于更简洁的归纳定义 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}}： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndPrinciples.ev'}{ev'}{\coqdocinductive{ev'}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.IndPrinciples.ev' 0}{ev'\_0}{\coqdocconstructor{ev'\_0}} : \coqref{LF.IndPrinciples.ev'}{\coqdocinductive{ev'}} 0\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.IndPrinciples.ev' 2}{ev'\_2}{\coqdocconstructor{ev'\_2}} : \coqref{LF.IndPrinciples.ev'}{\coqdocinductive{ev'}} 2\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.IndPrinciples.ev' sum}{ev'\_sum}{\coqdocconstructor{ev'\_sum}} \coqdocvar{n} \coqdocvar{m} (\coqdocvar{Hn} : \coqref{LF.IndPrinciples.ev'}{\coqdocinductive{ev'}} \coqdocvariable{n}) (\coqdocvar{Hm} : \coqref{LF.IndPrinciples.ev'}{\coqdocinductive{ev'}} \coqdocvariable{m}) : \coqref{LF.IndPrinciples.ev'}{\coqdocinductive{ev'}} (\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndPrinciples.ev ev'}{ev\_ev'}{\coqdoclemma{ev\_ev'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndPrinciples.ev'}{\coqdocinductive{ev'}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.IndProp.ev ind}{\coqdocdefinition{ev\_ind}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{LF.IndPrinciples.ev' 0}{\coqdocconstructor{ev'\_0}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{Hm} \coqdocvar{IH}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} (\coqref{LF.IndPrinciples.ev' sum}{\coqdocconstructor{ev'\_sum}} 2 \coqdocvar{m}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{LF.IndPrinciples.ev' 2}{\coqdocconstructor{ev'\_2}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{IH}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\end{coqdoccode}
\coqdockw{Inductive} 定义的具体形式会影响到 Coq 生成的归纳法则。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndPrinciples.le1}{le1}{\coqdocinductive{le1}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{2.50em}
\ensuremath{|} \coqdef{LF.IndPrinciples.le1 n}{le1\_n}{\coqdocconstructor{le1\_n}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqref{LF.IndPrinciples.le1}{\coqdocinductive{le1}} \coqdocvariable{n} \coqdocvariable{n}\coqdoceol
\coqdocindent{2.50em}
\ensuremath{|} \coqdef{LF.IndPrinciples.le1 S}{le1\_S}{\coqdocconstructor{le1\_S}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.IndPrinciples.le1}{\coqdocinductive{le1}} \coqdocvariable{n} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.IndPrinciples.le1}{\coqdocinductive{le1}} \coqdocvariable{n} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{m})\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.IndPrinciples.:::x '<=1' x}{"}{"}m <=1 n" := (\coqref{LF.IndPrinciples.le1}{\coqdocinductive{le1}} \coqdocvar{m} \coqdocvar{n}) (\coqdoctac{at} \coqdockw{level} 70).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
此定义其实可以稍微简化一点，我们观察到左侧的参数 \coqdocvariable{n}
    在定义中始终是相同的，于是可以把它变成整体定义中的一个“一般参数”，
    而非每个构造子的参数。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndPrinciples.le2}{le2}{\coqdocinductive{le2}} (\coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndPrinciples.le2 n}{le2\_n}{\coqdocconstructor{le2\_n}} : \coqref{LF.IndPrinciples.le2}{\coqdocinductive{le2}} \coqdocvariable{n} \coqdocvariable{n}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndPrinciples.le2 S}{le2\_S}{\coqdocconstructor{le2\_S}} \coqdocvar{m} (\coqdocvar{H} : \coqref{LF.IndPrinciples.le2}{\coqdocinductive{le2}} \coqdocvariable{n} \coqdocvariable{m}) : \coqref{LF.IndPrinciples.le2}{\coqdocinductive{le2}} \coqdocvariable{n} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{m}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.IndPrinciples.:::x '<=2' x}{"}{"}m <=2 n" := (\coqref{LF.IndPrinciples.le2}{\coqdocinductive{le2}} \coqdocvar{m} \coqdocvar{n}) (\coqdoctac{at} \coqdockw{level} 70).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
尽管第二个看起来不那么对称了，但它却更好一点。
    为什么呢？因为它会生成更简单的归纳法则。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.IndPrinciples.le1 ind}{\coqdocdefinition{le1\_ind}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.IndPrinciples.le2 ind}{\coqdocdefinition{le2\_ind}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{形式化 vs. 非形式化的归纳证明}



 问：命题 \coqdocvariable{P} 的形式化证明和同一个命题 \coqdocvariable{P} 的非形式化证明之间是什么关系？


    答：后者应当\textit{'教给'}读者如何产生前者。


    问：需要多少的细节？


    不幸的是，并没有一个正确的答案；当然了，其实有一系列的选择。


    一种选择是，我们可以为读者给出全部的形式化证明（也即，“非形式化的”证明只是把
    形式化的证明用文字表述出来）。这可能让读者有能力自己完成形式化的证明，但也许
    并没有\textit{'教给'}读者什么东西。


  而另一种选择则是，我们可以说“某个定理为真，如果你觉得它有些困难那么可以自己尝试把它搞明白。”
  这也不是一种很好的教学策略，因为书写证明常常需要一两个对于要证明的东西的重要洞察，
  而多数读者往往在自己发现这些这些洞察前已经放弃了。


  一种中庸之道是——我们提供含有重要洞察的证明（免去读者像我们一开始一样辛苦地寻找证明），
  加上模式化部分的高层次建议（比如，归纳假设是什么，以及归纳证明中每个情形的证明责任），
  这样帮助读者节省自己重新构造这些东西的时间，但不会有过多的细节以至于主要的概念和想法受到干扰。


  我们在本章中已经仔细查看了形式化的归纳证明的“底层原理”，现在是时候来看看非形式化的归纳证明了。


  在现实世界的数学交流中，证明的书写既有冗长的，也有非常简洁的。
  尽管理想状态是二者中间的某种形式，但从有一点冗长的证明开始学习是有好处的。
  同时，在学习的过程中，有一个明确的标准来进行比较也是有益的。为此，
  我们提供了两份模板：一份用于归纳证明\textit{'数据'}（也即，\coqdockw{Type} 中我们进行归纳的东西），
  另一份用于归纳证明\textit{'证据'}（也即，\coqdockw{Prop} 中归纳定义的东西）。\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{对归纳定义的集合进行归纳}



 \textit{'模板'}：



\begin{itemize}
\item  \textit{'定理'}： <有形如“For all \coqdocvariable{n}:\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}}, \coqdocvariable{P}(\coqdocvariable{n})”的全称量化命题，其中 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}}
          是某个归纳定义的集合。>


         \textit{'证明'}： 对 \coqdocvariable{n} 进行归纳。


           <\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 中的每个构造子 \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 的情形……>



\begin{itemize}
\item  假设 \coqdocvariable{n} = \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} \coqdocvariable{a1} ... \coqdocvar{ak}，其中 <…… 这里我们为每个具有类型 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 的 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 陈述其归纳假设（IH）> 。
             我们需要证明 <…… 我们在这里重新陈述 \coqdocvariable{P}(\coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} \coqdocvariable{a1} ... \coqdocvar{ak})>。


             <继续并证明 \coqdocvariable{P}(\coqdocvariable{n}) 来完成这个情形……>



\item  <其他情形以此类推……>                        \ensuremath{\Box}

\end{itemize}

\end{itemize}


    \textit{'举例'}:



\begin{itemize}
\item  \textit{'定理'}: 对所有集合 \coqref{LF.Imp.X}{\coqdocdefinition{X}}， 列表 \coqdocvariable{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}}，以及数字 \coqdocvariable{n}，如果
          \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} \coqdocvariable{l} = \coqdocvariable{n} 那么 \coqdocvar{index} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}) \coqdocvariable{l} = \coqref{LF.Lists.NatList.None}{\coqdocconstructor{None}}。


        \textit{'证明'}: 对 \coqdocvariable{l} 进行归纳。



\begin{itemize}
\item  假设 \coqdocvariable{l} = []。我们需要证明，对于任意数字 \coqdocvariable{n}，如果 \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} [] = \coqdocvariable{n}，那么
         \coqdocvar{index} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}) [] = \coqref{LF.Lists.NatList.None}{\coqdocconstructor{None}}。


          可从 \coqdocvar{index} 的定义中直接得出。



\item  假设 \coqdocvariable{l} = \coqdocvariable{x} :: \coqdocvariable{l'} 对某个 \coqdocvariable{x} 和 \coqdocvariable{l'}，其中 \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} \coqdocvariable{l'} = \coqdocvariable{n'} 对任意数字 \coqdocvariable{n'}
          蕴含了 \coqdocvar{index} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}) \coqdocvariable{l'} = \coqref{LF.Lists.NatList.None}{\coqdocconstructor{None}}。我们需要证明，对任意数字 \coqdocvariable{n}，如果
          \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} (\coqdocvariable{x}::\coqdocvariable{l'}) = \coqdocvariable{n} 那么 \coqdocvar{index} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}) (\coqdocvariable{x}::\coqdocvariable{l'}) = \coqref{LF.Lists.NatList.None}{\coqdocconstructor{None}}。


          设 \coqdocvariable{n} 为数字且 \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} \coqdocvariable{l} = \coqdocvariable{n}。因为


            length l = length (x::l') = S (length l'),


          需要证明


            index (S (length l')) l' = None.


          若选取 \coqdocvariable{n'} 为 \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} \coqdocvariable{l'} 这可从归纳假设中直接得出。  \ensuremath{\Box} 
\end{itemize}

\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{对归纳定义的命题进行归纳}



 由于归纳定义的证明对象经常被称作“导出树（derivation trees）”，这种形式的
    证明也被叫做\textit{'在导出式上归纳'}。
    \textit{'模板'}：



\begin{itemize}
\item  \textit{'定理'}: <有形如“\coqdocvariable{Q} \ensuremath{\rightarrow} \coqdocvariable{P}”的命题，其中 \coqdocvariable{Q} 是某个归纳定义的命题
        （更一般地，“对任意 \coqdocvariable{x} \coqdocvariable{y} \coqdocvariable{z}，\coqdocvariable{Q} \coqdocvariable{x} \coqdocvariable{y} \coqdocvariable{z} \ensuremath{\rightarrow} \coqdocvariable{P} \coqdocvariable{x} \coqdocvariable{y} \coqdocvariable{z}”）>


         \textit{'证明'}: 对 \coqdocvariable{Q} 的导出式进行归纳。<或者，更一般地，“假设给定 \coqdocvariable{x}，\coqdocvariable{y} 和
         \coqdocvariable{z}。通过对 \coqdocvariable{Q} \coqdocvariable{x} \coqdocvariable{y} \coqdocvariable{z} 的导出式进行归纳，我们证明 \coqdocvariable{Q} \coqdocvariable{x} \coqdocvariable{y} \coqdocvariable{z} 蕴含 \coqdocvariable{P} \coqdocvariable{x} \coqdocvariable{y} \coqdocvariable{z}”……>


           <\coqdocvariable{Q} 中的每个构造子 \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 的情形……>



\begin{itemize}
\item  假设被用于证明 \coqdocvariable{Q} 的最终规则是 \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}}。那么<……我们在这里陈述所有 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 的类型，
            从构造子的定义中得到的任何等式，以及每个具有类型 \coqdocvariable{Q} 的 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 的归纳假设>。
            我们需要证明<……我们在这里重新陈述 \coqdocvariable{P}>。


             <继续并证明 \coqdocvariable{P} 来完成这个情形……>



\item  <其他情形以此类推……>                        \ensuremath{\Box}

\end{itemize}

\end{itemize}


    \textit{'举例'}


\begin{itemize}
\item  \textit{'定理'}: \ensuremath{\le} 关系是传递的，也即，对任意数字 \coqdocvariable{n}，\coqdocvariable{m} 和 \coqdocvariable{o}，如果
         \coqdocvariable{n} \ensuremath{\le} \coqdocvariable{m} 且 \coqdocvariable{m} \ensuremath{\le} \coqdocvariable{o} 那么 \coqdocvariable{n} \ensuremath{\le} \coqdocvariable{o}。


         \textit{'证明'}: 对 \coqdocvariable{m} \ensuremath{\le} \coqdocvariable{o} 的导出式进行归纳。



\begin{itemize}
\item  假设被用于证明 \coqdocvariable{m} \ensuremath{\le} \coqdocvariable{o} 的最终规则是 \coqref{LF.IndProp.Playground.le n}{\coqdocconstructor{le\_n}}。
             那么 \coqdocvariable{m} = \coqdocvariable{o} 且我们需要证明 \coqdocvariable{n} \ensuremath{\le} \coqdocvariable{m}，其可从假设中直接得出。



\item  假设被用于证明 \coqdocvariable{m} \ensuremath{\le} \coqdocvariable{o} 的最终规则是 \coqref{LF.IndProp.Playground.le S}{\coqdocconstructor{le\_S}}。
             那么 \coqdocvariable{o} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvar{o'} 对某个 \coqdocvar{o'} 且 \coqdocvariable{m} \ensuremath{\le} \coqdocvar{o'}。我们需要证明 \coqdocvariable{n} \ensuremath{\le} \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvar{o'}。
             由归纳假设得出，\coqdocvariable{n} \ensuremath{\le} \coqdocvar{o'}。


             因此，根据 \coqref{LF.IndProp.Playground.le S}{\coqdocconstructor{le\_S}}，\coqdocvariable{n} \ensuremath{\le} \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvar{o'}。  \ensuremath{\Box} 
\end{itemize}

\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Explicit Proof Objects for Induction (Optional)}



 Although tactic-based proofs are normally much easier to
    work with, the ability to write a proof term directly is sometimes
    very handy, particularly when we want Coq to do something slightly
    non-standard.  

 Recall again the induction principle on naturals that Coq generates for
    us automatically from the Inductive declation for \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqexternalref{nat ind}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{nat\_ind}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
There's nothing magic about this induction lemma: it's just
   another Coq lemma that requires a proof.  Coq generates the proof
   automatically too...  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqexternalref{nat ind}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{nat\_ind}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We can read this as follows:
     Suppose we have evidence \coqdocvariable{f} that \coqdocvariable{P} holds on 0,  and
     evidence \coqdocvar{f0} that \coqdockw{\ensuremath{\forall}} \coqdocvariable{n}:\coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}, \coqdocvariable{P} \coqdocvariable{n} \ensuremath{\rightarrow} \coqdocvariable{P} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}).
     Then we can prove that \coqdocvariable{P} holds of an arbitrary nat \coqdocvariable{n} via
     a recursive function \coqdocvar{F} (here defined using the expression
     form \coqdockw{Fix} rather than by a top-level \coqdockw{Fixpoint}
     declaration).  \coqdocvar{F} pattern matches on \coqdocvariable{n}:

\begin{itemize}
\item  If it finds 0, \coqdocvar{F} uses \coqdocvariable{f} to show that \coqdocvariable{P} \coqdocvariable{n} holds.

\item  If it finds \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvar{n0}, \coqdocvar{F} applies itself recursively on \coqdocvar{n0}
         to obtain evidence that \coqdocvariable{P} \coqdocvar{n0} holds; then it applies \coqdocvar{f0}
         on that evidence to show that \coqdocvariable{P} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}) holds.

\end{itemize}
    \coqdocvar{F} is just an ordinary recursive function that happens to
    operate on evidence in \coqdockw{Prop} rather than on terms in \coqdockw{Set}.




  We can adapt this approach to proving \coqexternalref{nat ind}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocdefinition{nat\_ind}} to help prove
    \textit{non-standard} induction principles too.  As a motivating example,
    suppose that we want to prove the following lemma, directly
    relating the \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} predicate we defined in \coqdoclibrary{IndProp}
    to the \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} function defined in \coqdoclibrary{Basics}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndPrinciples.evenb ev}{evenb\_ev}{\coqdoclemma{evenb\_ev}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}: \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{n}; \coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} \coqdocvar{n}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}.\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Attempts to prove this by standard induction on \coqdocvariable{n} fail in the case for
    \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}),  because the induction hypothesis only tells us something about
    \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}, which is useless. There are various ways to hack around this problem;
    for example, we \textit{can} use ordinary induction on \coqdocvariable{n} to prove this (try it!):


    \coqdockw{Lemma} \coqdocvar{evenb\_ev'} : \coqdockw{\ensuremath{\forall}} \coqdocvariable{n} : \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}},
     (\coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvariable{n} = \coqref{LF.Basics.true}{\coqdocconstructor{true}} \ensuremath{\rightarrow} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}) \ensuremath{\land} (\coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}) = \coqref{LF.Basics.true}{\coqdocconstructor{true}} \ensuremath{\rightarrow} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n})).


    But we can make a much better proof by defining and proving a
    non-standard induction principle that goes ``by twos'':
 \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{0.50em}
\coqdockw{Definition} \coqdef{LF.IndPrinciples.nat ind2}{nat\_ind2}{\coqdocdefinition{nat\_ind2}} :\coqdoceol
\coqdocindent{2.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{P} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{P} 0 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{P} 1 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{P} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}}(\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}))\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} , \coqdocvariable{P} \coqdocvariable{n} :=\coqdoceol
\coqdocindent{3.50em}
\coqdockw{fun} \coqdocvar{P} \ensuremath{\Rightarrow} \coqdockw{fun} \coqdocvar{P0} \ensuremath{\Rightarrow} \coqdockw{fun} \coqdocvar{P1} \ensuremath{\Rightarrow} \coqdockw{fun} \coqdocvar{PSS} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqdockw{fix} \coqdocvar{f} (\coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) := \coqdockw{match} \coqdocvariable{n} \coqdockw{with}\coqdoceol
\coqdocindent{14.50em}
0 \ensuremath{\Rightarrow} \coqdocvariable{P0}\coqdoceol
\coqdocindent{13.50em}
\ensuremath{|} 1 \ensuremath{\Rightarrow} \coqdocvariable{P1}\coqdoceol
\coqdocindent{13.50em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n'}) \ensuremath{\Rightarrow} \coqdocvariable{PSS} \coqdocvar{n'} (\coqdocvariable{f} \coqdocvar{n'})\coqdoceol
\coqdocindent{13.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Once you get the hang of it, it is entirely straightforward to
     give an explicit proof term for induction principles like this.
     Proving this as a lemma using tactics is much less intuitive.


     The \coqdoctac{induction} ... \coqdockw{using} tactic variant gives a convenient way to
     utilize a non-standard induction principle like this. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndPrinciples.evenb ev}{evenb\_ev}{\coqdoclemma{evenb\_ev}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{0.50em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{0.50em}
\coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [ \ensuremath{|} \ensuremath{|}\coqdocvar{n'}] \coqdockw{using} \coqref{LF.IndPrinciples.nat ind2}{\coqdocdefinition{nat\_ind2}}.\coqdoceol
\coqdocindent{0.50em}
- \coqdoctac{apply} \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}}.\coqdoceol
\coqdocindent{0.50em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{0.50em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{apply} \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{apply} \coqdocvar{IHn'}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{The Coq Trusted Computing Base}



 One issue that arises with any automated proof assistant is ``why
    trust it?'': what if there is a bug in the implementation that
    renders all its reasoning suspect?


    While it is impossible to allay such concerns completely, the fact
    that Coq is based on the Curry-Howard correspondence gives it a
    strong foundation. Because propositions are just types and proofs
    are just terms, checking that an alleged proof of a proposition is
    valid just amounts to \textit{type-checking} the term.  Type checkers are
    relatively small and straightforward programs, so the ``trusted
    computing base'' for Coq -- the part of the code that we have to
    believe is operating correctly -- is small too.


    What must a typechecker do?  Its primary job is to make sure that
    in each function application the expected and actual argument
    types match, that the arms of a \coqdockw{match} expression are constructor
    patterns belonging to the inductive type being matched over and
    all arms of the \coqdockw{match} return the same type, and so on.


    There are a few additional wrinkles:



\begin{itemize}
\item  Since Coq types can themselves be expressions, the checker must
      normalize these (by using the computation rules) before
      comparing them.



\item  The checker must make sure that \coqdockw{match} expressions are
      \textit{exhaustive}.  That is, there must be an arm for every possible
      constructor.  To see why, consider the following alleged proof
      object:


      Definition or\_bogus : forall P Q, P \symbol{92}/ Q -> P :=
        fun (P Q : Prop) (A : P \symbol{92}/ Q) =>
           match A with
           | or\_introl H => H
           end.


      All the types here match correctly, but the \coqdockw{match} only
      considers one of the possible constructors for \coqref{LF.ProofObjects.Props.Or.or}{\coqdocinductive{or}}.  Coq's
      exhaustiveness check will reject this definition.



\item  The checker must make sure that each \coqdockw{fix} expression
      terminates.  It does this using a syntactic check to make sure
      that each recursive call is on a subexpression of the original
      argument.  To see why this is essential, consider this alleged
      proof:


          Definition nat\_false : forall (n:nat), False :=
             fix f (n:nat) : False := f n.


      Again, this is perfectly well-typed, but (fortunately) Coq will
      reject it. 
\end{itemize}


 Note that the soundness of Coq depends only on the correctness of
    this typechecking engine, not on the tactic machinery.  If there
    is a bug in a tactic implementation (and this certainly does
    happen!), that tactic might construct an invalid proof term.  But
    when you type \coqdockw{Qed}, Coq checks the term for validity from
    scratch.  Only lemmas whose proofs pass the type-checker can be
    used in further proof developments.  \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.ProofObjects}{Library }{LF.ProofObjects}

\begin{coqdoccode}
\end{coqdoccode}
\section{ProofObjects: 柯里-霍华德对应}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Export} \coqref{LF.IndProp}{\coqdoclibrary{IndProp}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
"\textit{'算法是证明的计算性内容。'}"  --Robert Harper 

 前文已讨论过 Coq 既可以用 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}、\coqref{LF.Poly.list}{\coqdocinductive{list}} 等归纳类型及其函数\textit{'编程'}，又可
    以用归纳命题（如 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}}）、蕴含式、全称量词等工具\textit{'证明'}程序的性质。我们一直
    以来区别对待此两种用法，在很多情况下确实可以这样。但也有迹象表明在 Coq 中编
    程与证明紧密相关。例如，关键字 \coqdockw{Inductive} 同时用于声明数据类型和命题，以及
    \ensuremath{\rightarrow} 同时用于描述函数类型和逻辑蕴含式。这可并不是语法上的巧合！事实上，在 Coq
    里面程序和证明几乎就是同一件事情。这一章我们会学习背后的原理。


    我们已经知道这个基础的思想：在Coq里面，可证明性表现为拥有具体的\textit{'证据'}。
    为基本命题构造证明，实则以树状结构表示其证据。


    对于形如 \coqref{LF.Basics.A}{\coqdocconstructor{A}} \ensuremath{\rightarrow} \coqref{LF.Basics.B}{\coqdocconstructor{B}} 的蕴含式，其证明为证据\textit{'转化装置（transformer）'}，可将任何
    证明 \coqref{LF.Basics.A}{\coqdocconstructor{A}} 的依据转化为 \coqref{LF.Basics.B}{\coqdocconstructor{B}} 的证据。所以从根本上来讲，证明仅仅就是操纵证据的程
    序。 

 试问：如果是证据是数据，那么命题本身是什么？


    答曰：类型也！ 

 回顾一下 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 这个性质的形式化定义。  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们可以换种方式来解读“:”：用“是……的证明”而非“具有……类型”。例如将 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}}
    定义中第二行的 \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}} : \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 0 读作“\coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}} 是 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 0 的证明”而非“\coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}} 的类型为
    \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 0”。 

 此处 : 既在类型层面表达“具有……类型”，又在命题层面表示“是……的证明”。
    这种双关称为\textit{'柯里-霍华德同构（Curry-Howard correspondence）'}。
    它指出了逻辑与计算之间的深层联系：


                 命题           \~{}  类型
                 证明           \~{}  数据值


    \coqdocvar{Wadler} 2015 (in Bib.v) 里有简单的历史和最新的详细介绍可供参考。 

 该同构启发很多看问题的新方法。首先，对 \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 构造子的理解变得更加自然： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}\coqdoceol
\coqdocindent{1.00em}
: \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
可以将其读作“\coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 构造子接受两个参数——数字 \coqdocvariable{n} 以及命题 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}
    的证明——并产生 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n})) 的证明。” 

 现在让我们回顾一下之前有关 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 的一个证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.ProofObjects.ev 4}{ev\_4}{\coqdoclemma{ev\_4}} : \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 4.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}. \coqdoctac{apply} \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}. \coqdoctac{apply} \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
就像是处理普通的数据值和函数一样，我们可以使用 \coqdockw{Print} 指令来查看
    这个证明脚本所产生的\textit{'证据对象 (proof object)'} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqref{LF.ProofObjects.ev 4}{\coqdoclemma{ev\_4}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
实际上，我们也可以不借助脚本\textit{'直接'}写出表达式作为证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 2 (\coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 0 \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}}))\coqdoceol
\coqdocindent{1.00em}
: \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 4.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
表达式 \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 2 (\coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 0 \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}}) 可视为向构造子 \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 传入参数 2 和 0
    等参数，以及对应的 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 2 与 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 0 之依据所构造的证明。或言之，视 \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}
    为“构造证明”之原语，需要给定一个数字，并进一步提供该数为偶数之依据以构造证明。
    其类型表明了它的功能：


      forall n, ev n -> ev (S (S n)),


    类似地，多态类型 \coqdockw{\ensuremath{\forall}} \coqref{LF.Imp.X}{\coqdocdefinition{X}}, \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} 表明可以将 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}}
    视为从某类型到由该类型元素组成的空列表的函数。 

 我们在 \coqdoclibrary{Logic} 这一章中已经了解到，我们可以使用函数应用
    的语法来实例化引理中的全称量化变量，也可以使用该语法提供引理所要求
    的假设。例如： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.ProofObjects.ev 4'}{ev\_4'}{\coqdoclemma{ev\_4'}}: \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 4.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 2 (\coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 0 \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}})).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{证明脚本}



 我们一直在讨论的\textit{'证明对象 (Proof Objects)'}是Coq如何运作的核心。
    当Coq执行一个证明脚本的时候，在内部，Coq逐渐构造出一个证明对象——
    一个类型是想要证明的命题的项。在 \coqdockw{Proof} 和 \coqdockw{Qed} 之间的策略告诉
    Coq如何构造该项。为了了解这个过程是如何进行的，在下面的策略证明里，
    我们在多个地方使用 \coqdockw{Show} \coqdockw{Proof} 指令来显示当前证明树的状态。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.ProofObjects.ev 4''}{ev\_4'{}'}{\coqdoclemma{ev\_4'{}'}} : \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 4.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Show} \coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Show} \coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Show} \coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Show} \coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在任意的给定时刻，Coq已经构造了一个包含一个“洞(hole)”（即
    ?\coqdockw{Goal} ）的项，并且Coq知道该洞需要什么类型的证据来填补。


    每一个洞对应一个子目标。当没有子目标时，代表证明已经完成。此时，我
    们构造的证明将会被存储在全局环境中，其名字就是在 \coqdockw{Theorem} 中给定的名字 

 策略证明非常有用且方便，但是它们并不是必要的：原则上，我们总是能够
    手动构造想要的证据，如下所示。此处我们可以通过 \coqdockw{Definition} （而非
    \coqdockw{Theorem}）来直接给这个证据一个全局名称。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ProofObjects.ev 4'''}{ev\_4'{}'{}'}{\coqdocdefinition{ev\_4'{}'{}'}} : \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 4 :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 2 (\coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 0 \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
所有这些构造证明的不同方式，对应的存储在全局环境中的证明是完全一样的。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqref{LF.ProofObjects.ev 4}{\coqdoclemma{ev\_4}}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqref{LF.ProofObjects.ev 4'}{\coqdoclemma{ev\_4'}}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqref{LF.ProofObjects.ev 4''}{\coqdoclemma{ev\_4'{}'}}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqref{LF.ProofObjects.ev 4'''}{\coqdocdefinition{ev\_4'{}'{}'}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard (eight\_is\_even)}




    写出对应 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 8 的策略证明和证明对象。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.ProofObjects.ev 8}{ev\_8}{\coqdoclemma{ev\_8}} : \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 8.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ProofObjects.ev 8'}{ev\_8'}{\coqdocdefinition{ev\_8'}} : \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 8\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{量词，蕴含式，函数}



 在Coq的计算世界里（即所有的数据结构和程序存在的地方），有两种值的
    类型中拥有箭头：一种是\textit{'构造子(Constructor)'}，它通过归纳地定义数据类型
    引入，另一种是\textit{'函数(Function)'}。


    类似地，在Coq的逻辑世界里（即我们运用证明的地方），有两种方式来给
    与蕴含式需要的证据：构造子，通过归纳地定义命题引入，和...函数！
    

 例如，考虑下列陈述： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.ProofObjects.ev plus4}{ev\_plus4}{\coqdoclemma{ev\_plus4}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (4 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{H}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
对应 \coqref{LF.IndProp.ev plus4}{\coqdoclemma{ev\_plus4}} 的证明对象是什么？


    我们在寻找一个\textit{'类型(Type)'}是 \coqdockw{\ensuremath{\forall}} \coqdocvariable{n}, \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \ensuremath{\rightarrow} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (4 + \coqdocvariable{n}) 的表达式——也
    就是说，一个接受两个参数（一个数字和一个证据）并返回一个证据的
    \textit{'函数(Function)'}!


    它的证据对象： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ProofObjects.ev plus4'}{ev\_plus4'}{\coqdocdefinition{ev\_plus4'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (4 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) \ensuremath{\Rightarrow} \coqdockw{fun} (\coqdocvar{H} : \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n})) (\coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} \coqdocvariable{n} \coqdocvariable{H}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
回顾 \coqdockw{fun} \coqdocvariable{n} \ensuremath{\Rightarrow} \coqdocvar{blah} 意味着“一个函数，给定 \coqdocvariable{n}，产生 \coqdocvar{blah}”，
    并且Coq认为 4 + \coqdocvariable{n} 和 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}))) 是同义词，所以另一种写出
    这个定义的方式是： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ProofObjects.ev plus4''}{ev\_plus4'{}'}{\coqdocdefinition{ev\_plus4'{}'}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{H} : \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n})\coqdoceol
\coqdocindent{10.00em}
: \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (4 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n}) :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n})) (\coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} \coqdocvariable{n} \coqdocvariable{H}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.ProofObjects.ev plus4''}{\coqdocdefinition{ev\_plus4'{}'}}\coqdoceol
\coqdocindent{1.00em}
: \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (4 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
当我们将 \coqref{LF.IndProp.ev plus4}{\coqdoclemma{ev\_plus4}} 证明的命题视为一个函数类型时，我们可以发现一个
    有趣的现象：第二个参数的类型，\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}，依赖于第一个参数 \coqdocvariable{n} 的\textit{'值'}。


    虽然这样的\textit{'依赖类型 (Dependent type)'}在传统的编程语言中并不存在，
    但是它们对于编程来说有时候非常有用。最近它们在函数式编程社区里的活
    跃很好地表明了这一点。 

 注意到蕴含式（\ensuremath{\rightarrow}）和量化（\coqdockw{\ensuremath{\forall}}）都表示证据上的函数。事实上，他们
    是同一个东西：当我们使用\coqdockw{\ensuremath{\forall}}时没有依赖，就可以简写为当\ensuremath{\rightarrow}。即，我
    们没有必要给与箭头左边的类型一个名字：


           forall (x:nat), nat
        =  forall (\_:nat), nat
        =  nat -> nat


 例如，考虑下列命题： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ProofObjects.ev plus2}{ev\_plus2}{\coqdocdefinition{ev\_plus2}} : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdockw{\ensuremath{\forall}} (\coqdocvar{E} : \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}), \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 2).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这个命题的一个证明项会是一个拥有两个参数的函数：一个数字\coqdocvariable{n}
    和一个表明\coqdocvariable{n}是偶数的证据\coqdocvar{E}。但是对于这个证据来说，名字\coqdocvar{E}并没有
    在\coqref{LF.ProofObjects.ev plus2}{\coqdocdefinition{ev\_plus2}}剩余的陈述里面被使用，所以还专门为它取一个名字并没有意
    义。因此我们可以使用虚拟标志符\coqdocvar{\_}来替换真实的名字： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ProofObjects.ev plus2'}{ev\_plus2'}{\coqdocdefinition{ev\_plus2'}} : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdockw{\ensuremath{\forall}} (\coqdocvar{\_} : \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}), \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 2).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
或者，等同地，我们可以使用更加熟悉的记号： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ProofObjects.ev plus2''}{ev\_plus2'{}'}{\coqdocdefinition{ev\_plus2'{}'}} : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 2).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
总的来说，``\coqdocvariable{P} \ensuremath{\rightarrow} \coqdocvariable{Q}''只是 ``\coqdockw{\ensuremath{\forall}} (\coqdocvar{\_}:\coqdocvariable{P}), \coqdocvariable{Q}''的语法糖。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{使用策略编程}



 如果我们可以通过显式地给出项，而不是执行策略脚本，来构造证明，你可
    能会好奇我们是否可以通过\textit{'策略'}，而不是显式地给出项，来构造\textit{'程序'}。
    自然地，答案是可以！ \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ProofObjects.add1}{add1}{\coqdocdefinition{add1}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}.\coqdoceol
\coqdocnoindent
\coqdoctac{intro} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Show} \coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdoctac{apply} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}}.\coqdoceol
\coqdocnoindent
\coqdockw{Show} \coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdoctac{apply} \coqdocvar{n}. \coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqref{LF.ProofObjects.add1}{\coqdocdefinition{add1}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Compute} \coqref{LF.ProofObjects.add1}{\coqdocdefinition{add1}} 2.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
注意到我们通过使用.终止了\coqdockw{Definition}，而不是使用:=和一个项来
    定义它。这个记号会告诉Coq进入\textit{'证明脚本模式(Proof Scripting
    Mode)'}来构造类型是\coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} \ensuremath{\rightarrow} \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}的项。并且，我们通过使用\coqdockw{Defined}而不是
    \coqdockw{Qed}来终止证明；这使得这个定义是\textit{'透明的(Transparent)'}，所以它可
    以在计算中就像正常定义的函数一样被使用。（通过\coqdockw{Qed}定义的对象在计
    算中是不透明的。）


    这个特性主要是在定义拥有依赖类型的函数时非常有用。我们不会在本书中
    详细讨论后者。但是它确实表明了Coq里面基本思想的一致性和正交性。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{逻辑联结词作为归纳类型}



 归纳定义足够用于表达我们目前为止遇到的大多数的联结词。事实上，
    只有全称量化（以及作为特殊情况的蕴含式）是Coq内置的，所有其他的都是被归纳
    定义的。在这一节中我们会看到它们的定义。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.ProofObjects.Props}{Props}{\coqdocmodule{Props}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{合取}



 为了证明\coqdocvariable{P} \ensuremath{\land} \coqdocvariable{Q}成立，我们必须同时给出\coqdocvariable{P}和\coqdocvariable{Q}的证据。因此，我们可
    以合理地将\coqdocvariable{P} \ensuremath{\land} \coqdocvariable{Q}的证明对象定义为包含两个证明的元祖：一个是\coqdocvariable{P}的
    证明，另一个是\coqdocvariable{Q}的证明。即我们拥有如下定义。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.ProofObjects.Props.And}{And}{\coqdocmodule{And}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.ProofObjects.Props.And.and}{and}{\coqdocinductive{and}} (\coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop}) : \coqdockw{Prop} :=\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.ProofObjects.Props.And.conj}{conj}{\coqdocconstructor{conj}} : \coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.ProofObjects.and}{\coqdocinductive{and}} \coqdocvariable{P} \coqdocvariable{Q}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.ProofObjects.Props.And}{\coqdocmodule{And}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
注意到这个定义与在章节 \coqdoclibrary{Poly} 中给出的 \coqref{LF.Poly.prod}{\coqdocinductive{prod}} 定义的类型的相似处；
    唯一的不同之处在于，\coqref{LF.Poly.prod}{\coqdocinductive{prod}}的参数是\coqdockw{Type}，而\coqref{LF.ProofObjects.Props.And.and}{\coqdocinductive{and}}的类型是\coqdockw{Prop}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqref{LF.Poly.prod}{\coqdocinductive{prod}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这个定义能够解释为什么\coqdoctac{destruct}和\coqdoctac{intros}模式能用于一个合取前提。
    情况分析允许我们考虑所有\coqdocvariable{P} \ensuremath{\land} \coqdocvariable{Q}可能被证明的方式——只有一种方式（即
    \coqref{LF.ProofObjects.Props.And.conj}{\coqdocconstructor{conj}}构造子）。


    类似地，\coqdoctac{split}策略能够用于所有只有一个构造子的归
    纳定义命题。特别地，它能够用于\coqref{LF.ProofObjects.Props.And.and}{\coqdocinductive{and}}： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.ProofObjects.Props.and comm}{and\_comm}{\coqdoclemma{and\_comm}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop}, \coqdocvariable{P} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{Q} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{Q} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} [\coqdocvar{HP} \coqdocvar{HQ}]. \coqdoctac{split}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{HQ}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{HP}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} [\coqdocvar{HQ} \coqdocvar{HP}]. \coqdoctac{split}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{HP}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{HQ}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这解释了为什么一直以来我们能够使用策略来操作\coqref{LF.ProofObjects.Props.And.and}{\coqdocinductive{and}}的归纳定义。我们
    也可以使用模式匹配来用它直接构造证明。例如： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ProofObjects.Props.and comm' aux}{and\_comm'\_aux}{\coqdocdefinition{and\_comm'\_aux}} \coqdocvar{P} \coqdocvar{Q} (\coqdocvar{H} : \coqdocvariable{P} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{Q}) : \coqdocvariable{Q} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{P} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{H} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{conj}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocconstructor{conj}} \coqdocvar{HP} \coqdocvar{HQ} \ensuremath{\Rightarrow} \coqexternalref{conj}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocconstructor{conj}} \coqdocvar{HQ} \coqdocvar{HP}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ProofObjects.Props.and comm'}{and\_comm'}{\coqdocdefinition{and\_comm'}} \coqdocvar{P} \coqdocvar{Q} : \coqdocvariable{P} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{Q} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{Q} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{P} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{conj}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocconstructor{conj}} (\coqref{LF.ProofObjects.Props.and comm' aux}{\coqdocdefinition{and\_comm'\_aux}} \coqdocvariable{P} \coqdocvariable{Q}) (\coqref{LF.ProofObjects.Props.and comm' aux}{\coqdocdefinition{and\_comm'\_aux}} \coqdocvariable{Q} \coqdocvariable{P}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard, optional (conj\_fact)}




    构造一个证明对象来证明下列命题。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ProofObjects.Props.conj fact}{conj\_fact}{\coqdocdefinition{conj\_fact}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R}, \coqdocvariable{P} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{R} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{R}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{析取}



 析取的归纳定义有两个构造子，分别用于析取的两边： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.ProofObjects.Props.Or}{Or}{\coqdocmodule{Or}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.ProofObjects.Props.Or.or}{or}{\coqdocinductive{or}} (\coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop}) : \coqdockw{Prop} :=\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.ProofObjects.Props.Or.or introl}{or\_introl}{\coqdocconstructor{or\_introl}} : \coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.ProofObjects.or}{\coqdocinductive{or}} \coqdocvariable{P} \coqdocvariable{Q}\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.ProofObjects.Props.Or.or intror}{or\_intror}{\coqdocconstructor{or\_intror}} : \coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.ProofObjects.or}{\coqdocinductive{or}} \coqdocvariable{P} \coqdocvariable{Q}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.ProofObjects.Props.Or}{\coqdocmodule{Or}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这个声明解释了\coqdoctac{destruct}策略在一个析取前提上的行为，产生的子类型和
    \coqref{LF.ProofObjects.Props.Or.or introl}{\coqdocconstructor{or\_introl}}以及\coqref{LF.ProofObjects.Props.Or.or intror}{\coqdocconstructor{or\_intror}}构造子的形状相匹配。


    又一次地，我们可以不使用策略，直接写出涉及\coqref{LF.ProofObjects.Props.Or.or}{\coqdocinductive{or}}的定义的证明对象。 

\paragraph{练习：2 星, standard, optional (or\_commut'')}




    尝试写下\coqref{LF.Logic.or commut}{\coqdoclemma{or\_commut}}的显式证明对象。（不要使用\coqdockw{Print}来偷看我们已经
    定义的版本！） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ProofObjects.Props.or comm}{or\_comm}{\coqdocdefinition{or\_comm}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q}, \coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{P}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{存在量化}



 为了给出存在量词的证据，我们将一个证据类型\coqdocvariable{x}和\coqdocvariable{x}满足性质\coqdocvariable{P}的证明打包在一起： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.ProofObjects.Props.Ex}{Ex}{\coqdocmodule{Ex}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.ProofObjects.Props.Ex.ex}{ex}{\coqdocinductive{ex}} \{\coqdocvar{A} : \coqdockw{Type}\} (\coqdocvar{P} : \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) : \coqdockw{Prop} :=\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.ProofObjects.Props.Ex.ex intro}{ex\_intro}{\coqdocconstructor{ex\_intro}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} : \coqdocvariable{A}, \coqdocvariable{P} \coqdocvariable{x} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.ProofObjects.ex}{\coqdocinductive{ex}} \coqdocvariable{P}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.ProofObjects.Props.Ex}{\coqdocmodule{Ex}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
打包之后的命题可以通过解包操作受益。这里的核心定义是为了用于构造
    \coqref{LF.ProofObjects.Props.Ex.ex}{\coqdocinductive{ex}} \coqdocvariable{P}命题的类型构造器\coqref{LF.ProofObjects.Props.Ex.ex}{\coqdocinductive{ex}}，其中\coqdocvariable{P}自身是一个从类型为\coqref{LF.Basics.A}{\coqdocconstructor{A}}的证据类型
    值到命题的\textit{'函数(Function)'}。构造子\coqref{LF.ProofObjects.Props.Ex.ex intro}{\coqdocconstructor{ex\_intro}}提供了一个给定
    证据类型\coqdocvariable{x}和\coqdocvariable{P} \coqdocvariable{x}的证 明，可以构造\coqref{LF.ProofObjects.Props.Ex.ex}{\coqdocinductive{ex}} \coqdocvariable{P}的证据的方式。 

 我们更加熟悉的类型\coqdoctac{\ensuremath{\exists}} \coqdocvariable{x}, \coqdocvariable{P} \coqdocvariable{x}可以转换为一个涉及\coqref{LF.ProofObjects.Props.Ex.ex}{\coqdocinductive{ex}}的表达式： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqexternalref{ex}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocinductive{ex}} (\coqdockw{fun} \coqdocvar{n} \ensuremath{\Rightarrow} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}) : \coqdockw{Prop}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
下面是我们如何定义一个涉及\coqref{LF.ProofObjects.Props.Ex.ex}{\coqdocinductive{ex}}的显式证明对象： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ProofObjects.Props.some nat is even}{some\_nat\_is\_even}{\coqdocdefinition{some\_nat\_is\_even}} : \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{n}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{ex intro}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocconstructor{ex\_intro}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 4 (\coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 2 (\coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 0 \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard, optional (ex\_ev\_Sn)}




    完成下列证明对象的定义： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ProofObjects.Props.ex ev Sn}{ex\_ev\_Sn}{\coqdocdefinition{ex\_ev\_Sn}} : \coqexternalref{ex}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocinductive{ex}} (\coqdockw{fun} \coqdocvar{n} \ensuremath{\Rightarrow} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}))\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{\texorpdfstring{\protect\coqref{LF.ProofObjects.Props.True}{\coqdocinductive{True}}}{True}和\texorpdfstring{\protect\coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}}}{False}}



 \coqref{LF.ProofObjects.Props.True}{\coqdocinductive{True}}命题的归纳定义很简单： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.ProofObjects.Props.True}{True}{\coqdocinductive{True}} : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.ProofObjects.Props.I}{I}{\coqdocconstructor{I}} : \coqref{LF.ProofObjects.True}{\coqdocinductive{True}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
它拥有一个构造子（因此\coqref{LF.ProofObjects.Props.True}{\coqdocinductive{True}}的所有证据都是一样的，所以给出一个
    \coqref{LF.ProofObjects.Props.True}{\coqdocinductive{True}}的证明并没有信息量。） 

 \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}}也一样的简单——事实上，它是如此简单，以致于第一眼看上去像是一个
    语法错误。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.ProofObjects.Props.False}{False}{\coqdocinductive{False}} : \coqdockw{Prop} := .\coqdoceol
\coqdocemptyline
\end{coqdoccode}
也就是说， \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}}是一个\textit{'没有'}构造子的归纳类型--即，没有任何方式能
    够构造一个它的证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.ProofObjects.Props}{\coqdocmodule{Props}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{相等关系}



 在Coq里，甚至连相等关系都不是内置的。它拥有如下的归纳定义。（事实上，
    在标准库里的定义是这里给出的定义的轻微变体，前者给出了稍微容易使用
    一些的归纳法则。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.ProofObjects.MyEquality}{MyEquality}{\coqdocmodule{MyEquality}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.ProofObjects.MyEquality.eq}{eq}{\coqdocinductive{eq}} \{\coqdocvar{X}:\coqdockw{Type}\} : \coqdocvar{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvar{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.ProofObjects.MyEquality.eq refl}{eq\_refl}{\coqdocconstructor{eq\_refl}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqref{LF.ProofObjects.eq}{\coqdocinductive{eq}} \coqdocvariable{x} \coqdocvariable{x}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.ProofObjects.MyEquality.::type scope:x '==' x}{"}{"}x == y" := (\coqref{LF.ProofObjects.MyEquality.eq}{\coqdocinductive{eq}} \coqdocvar{x} \coqdocvar{y})\coqdoceol
\coqdocindent{10.00em}
(\coqdoctac{at} \coqdockw{level} 70, \coqdockw{no} \coqdockw{associativity})\coqdoceol
\coqdocindent{10.00em}
: \coqdocvar{type\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们可以这样理解这个定义，给定一个集合\coqref{LF.Imp.X}{\coqdocdefinition{X}}，它定义了由\coqref{LF.Imp.X}{\coqdocdefinition{X}}的一对值
    (\coqdocvariable{x}和\coqdocvariable{y})所索引的“\coqdocvariable{x}与\coqdocvariable{y}相等”的一\textit{'系列(Family)'}的命题。只有
    一种方式能够构造该系列中成员的证据：将构造子\coqref{LF.ProofObjects.MyEquality.eq refl}{\coqdocconstructor{eq\_refl}}应用到类型\coqref{LF.Imp.X}{\coqdocdefinition{X}}
    和值\coqdocvariable{x}:\coqref{LF.Imp.X}{\coqdocdefinition{X}}，产生一个\coqdocvariable{x}等于\coqdocvariable{x}的证据。


    其它形如 \coqref{LF.ProofObjects.MyEquality.eq}{\coqdocinductive{eq}} \coqdocvariable{x} \coqdocvariable{y} 的类型中的 \coqdocvariable{x} 和 \coqdocvariable{y} 并不相同，因此是非居留的。 

 我们可以使用\coqref{LF.ProofObjects.MyEquality.eq refl}{\coqdocconstructor{eq\_refl}}来构造证据，比如说，2 = 2。那么我们能否使用
    它来构造证据1 + 1 = 2呢？答案是肯定的。事实上，它就是同一个证据！


    原因是如果两个项能够通过一些简单的计算规则\textit{'可转换(convertible)'} ，
    那么Coq认为两者“相等”。


    这些计算规则，与\coqdockw{Compute}所使用的规则相似，包括函数应用的计算，定
    义的内联，\coqdockw{match}语句的化简。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.ProofObjects.MyEquality.four}{four}{\coqdoclemma{four}}: 2 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 2 \coqref{LF.ProofObjects.MyEquality.::type scope:x '==' x}{\coqdocnotation{==}} 1 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 3.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.ProofObjects.MyEquality.eq refl}{\coqdocconstructor{eq\_refl}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
至今为止我们所用来证据相等关系的\coqdoctac{reflexivity}策略本质上只是\coqdoctac{apply}
    \coqref{LF.ProofObjects.MyEquality.eq refl}{\coqdocconstructor{eq\_refl}}的简写。


    在基于策略的相等关系证明中，转换规则通常隐藏在\coqdoctac{simpl}的使用后面（在
    其他策略中或显式或隐式，例如\coqdoctac{reflexivity}）。


    而在如下的显式证明对象中，你可以直接看到它们： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ProofObjects.MyEquality.four'}{four'}{\coqdocdefinition{four'}} : 2 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 2 \coqref{LF.ProofObjects.MyEquality.::type scope:x '==' x}{\coqdocnotation{==}} 1 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 3 :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.ProofObjects.MyEquality.eq refl}{\coqdocconstructor{eq\_refl}} 4.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.ProofObjects.MyEquality.singleton}{singleton}{\coqdocdefinition{singleton}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{x}:\coqdocvariable{X}), \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}\coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{x}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.ProofObjects.MyEquality.::type scope:x '==' x}{\coqdocnotation{==}} \coqdocvariable{x}\coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}}\coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}  :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{x}:\coqdocvariable{X}) \ensuremath{\Rightarrow} \coqref{LF.ProofObjects.MyEquality.eq refl}{\coqdocconstructor{eq\_refl}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{x}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard (equality\_\_leibniz\_equality)}




    相等关系的归纳定义隐含了\textit{'Leibniz相等关系(Leibniz equality)'}：当我们
    说“\coqdocvariable{x}和\coqdocvariable{y}相等的时候”，我们意味着所有\coqdocvariable{x}满足的性质\coqdocvariable{P}，对于\coqdocvariable{y}
    来说也满足。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.ProofObjects.MyEquality.equality  leibniz equality}{equality\_\_leibniz\_equality}{\coqdoclemma{equality\_\_leibniz\_equality}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y}: \coqdocvariable{X}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{x} \coqref{LF.ProofObjects.MyEquality.::type scope:x '==' x}{\coqdocnotation{==}} \coqdocvariable{y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{\ensuremath{\forall}} \coqdocvar{P}:\coqdocvariable{X}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdockw{Prop}, \coqdocvariable{P} \coqdocvariable{x} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P} \coqdocvariable{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：5 星, standard, optional (leibniz\_equality\_\_equality)}




    请说明，事实上，相等关系的归纳定义和Leibniz相等关系是
    \textit{'等价的(equivalent)'}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.ProofObjects.MyEquality.leibniz equality  equality}{leibniz\_equality\_\_equality}{\coqdoclemma{leibniz\_equality\_\_equality}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y}: \coqdocvariable{X}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{P}:\coqdocvariable{X}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdockw{Prop}, \coqdocvariable{P} \coqdocvariable{x} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P} \coqdocvariable{y}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{x} \coqref{LF.ProofObjects.MyEquality.::type scope:x '==' x}{\coqdocnotation{==}} \coqdocvariable{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.ProofObjects.MyEquality}{\coqdocmodule{MyEquality}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{再论反演}



 我们曾经见过\coqdoctac{inversion}被同时用于相等关系前提，和关于被归纳定义的命
    题的前提。现在我们明白了实际上它们是同一件事情。那么我们现在可以细
    究一下\coqdoctac{inversion}是如何工作的。


    一般来说，\coqdoctac{inversion}策略...



\begin{itemize}
\item  接受一个前提\coqdocvariable{H}，该前提的类型\coqdocvariable{P}是通过归纳定义的，以及



\item  对于\coqdocvariable{P}的定义里的每一个构造子\coqdocvar{C}，



\begin{itemize}
\item  产生一个新的子目标，在该子目标中我们假设\coqdocvariable{H}是通过\coqdocvar{C}构造的，



\item  作为额外的假设，在子目标的上下文中增加\coqdocvar{C}的论据（前提），



\item  将\coqdocvar{C}的结论（结果类型）与当前的目标相匹配，计算出为了能够应用\coqdocvar{C}而必须成立的一些相等关系，



\item  将这些相等关系加入上下文中（以及，为了方便，在目标中替换它们），以及



\item  如果这些相等关系无法满足（例如，它们涉及到\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}}），那么立即解决这个子目标。 
\end{itemize}

\end{itemize}


 \textit{'例子'}：如果我们反演一个使用\coqref{LF.ProofObjects.Props.Or.or}{\coqdocinductive{or}}构造的前提，它有两个构
    造子，所以产生了两个子目标。构造子的结论（结果类型，即\coqdocvariable{P} \ensuremath{\lor} \coqdocvariable{Q}）
    并没有对于\coqdocvariable{P}和\coqdocvariable{Q}的形式有任何要求，所以在子目标的上下文中我们不会
    获得额外的相等关系。 

 \textit{'例子'}：如果我们反演一个使用\coqref{LF.ProofObjects.Props.And.and}{\coqdocinductive{and}}构造的前提，它只有一个构造子，
    所以只产生一个子目标。再一次地，构造子的结论（结果类型，即\coqdocvariable{P} \ensuremath{\land} \coqdocvariable{Q}）
    并没有对于\coqdocvariable{P}和\coqdocvariable{Q}的形式有任何要求，所以在子目标的上下文中我们不会
    获得额外的相等关系。不过，这个构造子有两个额外的参数，我们能够在子
    目标的上下文中看到它们。 

 \textit{'例子'}：如果我们反演一个使用\coqref{LF.ProofObjects.MyEquality.eq}{\coqdocinductive{eq}}构造的前提，它也只有一个构造子，
    所以只产生一个子目标。但是，现在\coqref{LF.ProofObjects.MyEquality.eq refl}{\coqdocconstructor{eq\_refl}}构造子的形式给我们带来
    的额外的信息：它告诉\coqref{LF.ProofObjects.MyEquality.eq}{\coqdocinductive{eq}}的两个参数必须是一样的。于是\coqdoctac{inversion}策
    略会将这个事实加入到上下文中。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.Maps}{Library }{LF.Maps}

\begin{coqdoccode}
\end{coqdoccode}
\section{Maps: 全映射与偏映射}



 \textit{'映射（Map）'}（或\textit{'字典（Dictionary）'}）是一种非常普遍的数据结构，
    在编程语言理论中尤甚，而之后的章节中我们会多次用到它。
    映射也适合运用之前学过的概念进行研究，包括如何在高阶函数之外构建数据结构
    （见 \coqdoclibrary{Basics} 和 \coqdoclibrary{Poly}）以及通过互映来精简证明（见 \coqdoclibrary{IndProp}）。


    我们会定义两种映射：在查找的键不存在时，\textit{'全映射'}会返回“默认”元素，
    而\textit{'偏映射'}则会返回一个 \coqref{LF.Poly.OptionPlayground.option}{\coqdocinductive{option}} 来指示成功还是失败。后者根据前者来定义，
    它使用 \coqref{LF.Lists.NatList.None}{\coqdocconstructor{None}} 默认元素。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Coq 标准库}



 开始前的小插话...


    和我们目前学过的章节不同，本章无需通过 \coqdockw{Require} \coqdockw{Import} 导入之前的章节
    （自然也就不会间接导入更早的章节）。从本章开始，我们我们将直接从
    Coq 标准库中导入需要的定义和定理。然而应该不会注意到多大差别，
    因为我们一直小心地将自己的定义和定理的命名与标准库中的部分保持一致，
    无论它们在哪里重复。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Arith.Arith}{\coqdoclibrary{Arith.Arith}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Bool.Bool}{\coqdoclibrary{Bool.Bool}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{Coq.Strings.String}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Logic.FunctionalExtensionality}{\coqdoclibrary{Logic.FunctionalExtensionality}}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List}{\coqdoclibrary{Lists.List}}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{ListNotations}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
标准库的文档见
    https://coq.inria.fr/library/。


    \coqdockw{Search} 指令可用于查找涉及具体类型对象的定理。我们花点时间来熟悉一下它。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{标识符}



 首先我们需要键的类型来对映射进行索引。在 \coqdocvar{Lists.v} 中，
    我们为类似的目的引入了 \coqref{LF.Lists.id}{\coqdocinductive{id}} 类型。而在\textit{'《软件基础》'}后面的部分，
    我们会使用 Coq 标准库中的 \coqref{LF.IndProp.string}{\coqdocdefinition{string}} 类型。 

 为了比较字符串，我们定义了 \coqref{LF.Maps.eqb string}{\coqdocdefinition{eqb\_string}} 函数，它在内部使用 Coq
    字符串库中的 \coqexternalref{string dec}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocdefinition{string\_dec}} 函数。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Maps.eqb string}{eqb\_string}{\coqdocdefinition{eqb\_string}} (\coqdocvar{x} \coqdocvar{y} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) : \coqexternalref{bool}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{if} \coqexternalref{string dec}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocdefinition{string\_dec}} \coqdocvariable{x} \coqdocvariable{y} \coqdockw{then} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqdockw{else} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（函数 \coqexternalref{string dec}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocdefinition{string\_dec}} 来自于 Coq 的字符串标准库。如果你查看
    \coqexternalref{string dec}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocdefinition{string\_dec}} 的结果类型，就会发现其返回值的类型并不是 \coqref{LF.Basics.bool}{\coqdocinductive{bool}}，
    而是一个形如 \{\coqdocvariable{x} = \coqdocvariable{y}\} + \{\coqdocvariable{x} \ensuremath{\not=} \coqdocvariable{y}\} 的类型，叫做 \coqexternalref{sumbool}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif}{\coqdocinductive{sumbool}} 类型，
    它可以看做“带有证据的布尔类型”。形式上来说，一个 \{\coqdocvariable{x} = \coqdocvariable{y}\} + \{\coqdocvariable{x} \ensuremath{\not=} \coqdocvariable{y}\}
    类型的元素要么是 \coqdocvariable{x} 和 \coqdocvariable{y} 的相等的证明，要么就是它们不相等的证明，
    与一个标签一起来指出具体是哪一个。不过就目前来说，你可以把它当做一个
    花哨的 \coqref{LF.Basics.bool}{\coqdocinductive{bool}}。） 

 现在我们需要一些关于字符串相等性的基本性质... \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Maps.eqb string refl}{eqb\_string\_refl}{\coqdoclemma{eqb\_string\_refl}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{s} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}, \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Maps.eqb string}{\coqdocdefinition{eqb\_string}} \coqdocvariable{s} \coqdocvariable{s}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{s}. \coqdoctac{unfold} \coqref{LF.Maps.eqb string}{\coqdocdefinition{eqb\_string}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqexternalref{string dec}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocdefinition{string\_dec}} \coqdocvar{s} \coqdocvar{s}) \coqdockw{as} [\coqdocvar{Hs\_eq} \ensuremath{|} \coqdocvar{Hs\_not\_eq}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} \coqdocvar{Hs\_not\_eq}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
两个字符串在 \coqref{LF.Maps.eqb string}{\coqdocdefinition{eqb\_string}} 的意义上相等，当且仅当它们在
    = 的意义上相等。因此 \coqref{LF.Maps.eqb string}{\coqdocdefinition{eqb\_string}} 中反映了 =，\coqdoclibrary{IndProp}
    一章中讨论了「互映」的意义。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Maps.eqb string true iff}{eqb\_string\_true\_iff}{\coqdoclemma{eqb\_string\_true\_iff}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}},\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Maps.eqb string}{\coqdocdefinition{eqb\_string}} \coqdocvariable{x} \coqdocvariable{y} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{unfold} \coqref{LF.Maps.eqb string}{\coqdocdefinition{eqb\_string}}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{destruct} (\coqexternalref{string dec}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocdefinition{string\_dec}} \coqdocvar{x} \coqdocvar{y}) \coqdockw{as} [\coqdocvar{Hs\_eq} \ensuremath{|} \coqdocvar{Hs\_not\_eq}].\coqdoceol
\coqdocindent{1.50em}
- \coqdoctac{rewrite} \coqdocvar{Hs\_eq}. \coqdoctac{split}. \coqdoctac{reflexivity}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.50em}
- \coqdoctac{split}.\coqdoceol
\coqdocindent{2.50em}
+ \coqdoctac{intros} \coqdocvar{contra}. \coqdoctac{discriminate} \coqdocvar{contra}.\coqdoceol
\coqdocindent{2.50em}
+ \coqdoctac{intros} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{Hs\_not\_eq}. \coqdoctac{destruct} \coqdocvar{Hs\_not\_eq}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
类似地： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Maps.eqb string false iff}{eqb\_string\_false\_iff}{\coqdoclemma{eqb\_string\_false\_iff}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}},\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Maps.eqb string}{\coqdocdefinition{eqb\_string}} \coqdocvariable{x} \coqdocvariable{y} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{x} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{y}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{LF.Maps.eqb string true iff}{\coqdoclemma{eqb\_string\_true\_iff}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqexternalref{not true iff false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Bool.Bool}{\coqdoclemma{not\_true\_iff\_false}}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
以下便于使用的变体只需通过改写就能得出： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Maps.false eqb string}{false\_eqb\_string}{\coqdoclemma{false\_eqb\_string}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}},\coqdoceol
\coqdocindent{1.50em}
\coqdocvariable{x} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Maps.eqb string}{\coqdocdefinition{eqb\_string}} \coqdocvariable{x} \coqdocvariable{y} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{y}. \coqdoctac{rewrite} \coqref{LF.Maps.eqb string false iff}{\coqdoclemma{eqb\_string\_false\_iff}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{H}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{全映射}



 在本章中，我们的主要任务就是构建一个偏映射的定义，其行为类似于我们之前在
    \coqdoclibrary{Lists} 一章中看到的那个，再加上伴随其行为的引理。


    不过这一次，我们将使用\textit{'函数'}而非“键-值”对的列表来构建映射。
    这种表示方法的优点在于它提供了映射更具\textit{'外延性'}的视角，
    即以相同方式回应查询的两个映射将被表示为完全相同的东西（即一模一样的函数），
    而非只是“等价”的数据结构。这反过来简化了使用映射的证明。 

 我们会分两步构建偏映射。首先，我们定义一个\textit{'全映射'}类型，
    它在某个映射中查找不存在的键时会返回默认值。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Maps.total map}{total\_map}{\coqdocdefinition{total\_map}} (\coqdocvar{A} : \coqdockw{Type}) := \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{A}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
直观上来说，一个元素类型为 \coqref{LF.Basics.A}{\coqdocconstructor{A}} 的全映射不过就是个根据 \coqref{LF.IndProp.string}{\coqdocdefinition{string}}
    来查找 \coqref{LF.Basics.A}{\coqdocconstructor{A}} 的函数。 

 给定函数 \coqref{LF.Maps.t empty}{\coqdocdefinition{t\_empty}} 一个默认元素，它会产生一个空的全映射。
    此映射在应用到任何字符串时都会返回默认元素。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Maps.t empty}{t\_empty}{\coqdocdefinition{t\_empty}} \{\coqdocvar{A} : \coqdockw{Type}\} (\coqdocvar{v} : \coqdocvariable{A}) : \coqref{LF.Maps.total map}{\coqdocdefinition{total\_map}} \coqdocvariable{A} :=\coqdoceol
\coqdocindent{1.00em}
(\coqdockw{fun} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdocvariable{v}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
更有趣的是 \coqref{LF.Lists.PartialMap.update}{\coqdocdefinition{update}} 函数，它和之前一样，接受一个映射 \coqdocvariable{m}、一个键 \coqdocvariable{x}
    以及一个值 \coqdocvariable{v}，并返回一个将 \coqdocvariable{x} 映射到 \coqdocvariable{v} 的新映射；其它键则与
    \coqdocvariable{m} 中原来的保持一致。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Maps.t update}{t\_update}{\coqdocdefinition{t\_update}} \{\coqdocvar{A} : \coqdockw{Type}\} (\coqdocvar{m} : \coqref{LF.Maps.total map}{\coqdocdefinition{total\_map}} \coqdocvariable{A})\coqdoceol
\coqdocindent{10.00em}
(\coqdocvar{x} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) (\coqdocvar{v} : \coqdocvariable{A}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} \coqdocvar{x'} \ensuremath{\Rightarrow} \coqdockw{if} \coqref{LF.Maps.eqb string}{\coqdocdefinition{eqb\_string}} \coqdocvariable{x} \coqdocvariable{x'} \coqdockw{then} \coqdocvariable{v} \coqdockw{else} \coqdocvariable{m} \coqdocvariable{x'}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
此定义是个高阶编程的好例子：\coqref{LF.Maps.t update}{\coqdocdefinition{t\_update}} 接受一个\textit{'函数'} \coqdocvariable{m}
    并产生一个新的函数 \coqdockw{fun} \coqdocvariable{x'} \ensuremath{\Rightarrow} ...，它的表现与所需的映射一致。 

 例如，我们可以构建一个从 \coqref{LF.IndProp.string}{\coqdocdefinition{string}} 到 \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 的映射，其中 "\coqref{LF.Tactics.foo}{\coqdocdefinition{foo}}"
    和 "\coqref{LF.Tactics.bar}{\coqdocdefinition{bar}}" 映射到 \coqref{LF.Basics.true}{\coqdocconstructor{true}}，其它键则映射到 \coqref{LF.Basics.false}{\coqdocconstructor{false}}，就像这样： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Maps.examplemap}{examplemap}{\coqdocdefinition{examplemap}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Maps.t update}{\coqdocdefinition{t\_update}} (\coqref{LF.Maps.t update}{\coqdocdefinition{t\_update}} (\coqref{LF.Maps.t empty}{\coqdocdefinition{t\_empty}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}) "foo" \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}})\coqdoceol
\coqdocindent{5.50em}
"bar" \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
接下来，我们引入一些新的记法来方便映射的使用。 

 首先，我们会使用以下记法，根据一个默认值来创建空的全映射。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Maps.:::''' ''' '!->' x}{"}{"}'\_' '!->' v" := (\coqref{LF.Maps.t empty}{\coqdocdefinition{t\_empty}} \coqdocvar{v})\coqdoceol
\coqdocindent{1.00em}
(\coqdoctac{at} \coqdockw{level} 100, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Maps.example empty}{example\_empty}{\coqdocdefinition{example\_empty}} := (\coqref{LF.Maps.:::''' ''' '!->' x}{\coqdocnotation{\_}} \coqref{LF.Maps.:::''' ''' '!->' x}{\coqdocnotation{!->}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
然后，我们引入一种方便的记法，通过一些绑定来扩展现有的映射。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Maps.:::x '!->' x ';' x}{"}{"}x '!->' v ';' m" := (\coqref{LF.Maps.t update}{\coqdocdefinition{t\_update}} \coqdocvar{m} \coqdocvar{x} \coqdocvar{v})\coqdoceol
\coqdocindent{15.00em}
(\coqdoctac{at} \coqdockw{level} 100, \coqdocvar{v} \coqdoctac{at} \coqdocvar{next} \coqdockw{level}, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
前面的 \coqref{LF.Maps.examplemap}{\coqdocdefinition{examplemap}} 现在可以定义如下： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Maps.examplemap'}{examplemap'}{\coqdocdefinition{examplemap'}} :=\coqdoceol
\coqdocindent{1.00em}
( "bar" \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}}\coqdoceol
\coqdocindent{2.00em}
"foo" \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}\coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Maps.:::''' ''' '!->' x}{\coqdocnotation{\_}}     \coqref{LF.Maps.:::''' ''' '!->' x}{\coqdocnotation{!->}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
到这里就完成了全映射的定义。注意我们无需定义 \coqref{LF.Lists.PartialMap.find}{\coqdocdefinition{find}} 操作，
    因为它不过就是个函数应用！ \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Maps.update example1}{update\_example1}{\coqdocdefinition{update\_example1}} : \coqref{LF.Maps.examplemap'}{\coqdocdefinition{examplemap'}} "baz" \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Maps.update example2}{update\_example2}{\coqdocdefinition{update\_example2}} : \coqref{LF.Maps.examplemap'}{\coqdocdefinition{examplemap'}} "foo" \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Maps.update example3}{update\_example3}{\coqdocdefinition{update\_example3}} : \coqref{LF.Maps.examplemap'}{\coqdocdefinition{examplemap'}} "quux" \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Maps.update example4}{update\_example4}{\coqdocdefinition{update\_example4}} : \coqref{LF.Maps.examplemap'}{\coqdocdefinition{examplemap'}} "bar" \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
为了在后面的章节中使用映射，我们需要一些关于其表现的基本事实。 

 即便你没有进行下面的练习，也要确保透彻地理解以下引理的陈述！ 

 （其中有些证明需要函数的外延性公理，我们在 \coqdoclibrary{Logic} 一节中讨论过它）。 

\paragraph{练习：1 星, standard, optional (t\_apply\_empty)}




    首先，空映射对于所有的键都会返回默认元素（即，空映射总是返回默认元素）： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Maps.t apply empty}{t\_apply\_empty}{\coqdoclemma{t\_apply\_empty}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{x} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) (\coqdocvar{v} : \coqdocvariable{A}),\coqdoceol
\coqdocindent{2.00em}
(\coqref{LF.Maps.:::''' ''' '!->' x}{\coqdocnotation{\_}} \coqref{LF.Maps.:::''' ''' '!->' x}{\coqdocnotation{!->}} \coqdocvariable{v}) \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{v}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, optional (t\_update\_eq)}




    接着，如果将映射 \coqdocvariable{m} 的键 \coqdocvariable{x} 关联的值更新为 \coqdocvariable{v}，然后在 \coqref{LF.Lists.PartialMap.update}{\coqdocdefinition{update}}
    产生的新映射中查找 \coqdocvariable{x}，就会得到 \coqdocvariable{v}（即，更新某个键的映射，
    查找它就会得到更新后的值）： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Maps.t update eq}{t\_update\_eq}{\coqdoclemma{t\_update\_eq}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{m} : \coqref{LF.Maps.total map}{\coqdocdefinition{total\_map}} \coqdocvariable{A}) \coqdocvar{x} \coqdocvar{v},\coqdoceol
\coqdocindent{2.00em}
(\coqdocvariable{x} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{v} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}) \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{v}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, optional (t\_update\_neq)}




    此外，如果将映射 \coqdocvariable{m} 的键 \coqdocvariable{x1} 更新后在返回的结果中查找\textit{'另一个'}键
    \coqdocvariable{x2}，那么得到的结果与在 \coqdocvariable{m} 中查找它的结果相同
    （即，更新某个键的映射，不影响其它键的映射）： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Maps.t update neq}{t\_update\_neq}{\coqdoclemma{t\_update\_neq}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{m} : \coqref{LF.Maps.total map}{\coqdocdefinition{total\_map}} \coqdocvariable{A}) \coqdocvar{x1} \coqdocvar{x2} \coqdocvar{v},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{x1} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{x2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
(\coqdocvariable{x1} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{v} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}) \coqdocvariable{x2} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqdocvariable{x2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, optional (t\_update\_shadow)}




    如果将映射 \coqdocvariable{m} 的键 \coqdocvariable{x} 关联的值更新为 \coqdocvariable{v1} 后，又将同一个键 \coqdocvariable{x}
    更新为另一个值 \coqdocvariable{v2}，那么产生的映射与仅将第二次 \coqref{LF.Lists.PartialMap.update}{\coqdocdefinition{update}} 应用于 \coqdocvariable{m}
    所得到的映射表现一致（即二者应用到同一键时产生的结果相同）： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Maps.t update shadow}{t\_update\_shadow}{\coqdoclemma{t\_update\_shadow}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{m} : \coqref{LF.Maps.total map}{\coqdocdefinition{total\_map}} \coqdocvariable{A}) \coqdocvar{x} \coqdocvar{v1} \coqdocvar{v2},\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{v2} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{x} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{v1} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{v2} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 对于最后两个全映射的引理而言，用 \coqdoclibrary{IndProp} 一章中引入的互映法
    （Reflection idioms）来证明会十分方便。我们首先通过证明基本的\textit{'互映引理'}，
    将字符串上的相等关系命题与布尔函数 \coqref{LF.Maps.eqb string}{\coqdocdefinition{eqb\_string}} 关联起来。

\paragraph{练习：2 星, standard, optional (eqb\_stringP)}




    请仿照 \coqdoclibrary{IndProp} 一章中对 \coqdocvar{eqb\_natP} 的证明来证明以下引理： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Maps.eqb stringP}{eqb\_stringP}{\coqdoclemma{eqb\_stringP}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}},\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{reflect}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Bool.Bool}{\coqdocinductive{reflect}} (\coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{y}) (\coqref{LF.Maps.eqb string}{\coqdocdefinition{eqb\_string}} \coqdocvariable{x} \coqdocvariable{y}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 现在，给定 \coqref{LF.IndProp.string}{\coqdocdefinition{string}} 类型的字符串 \coqdocvariable{x1} 和 \coqdocvariable{x2}，我们可以在使用策略
    \coqdoctac{destruct} (\coqref{LF.Maps.eqb stringP}{\coqdoclemma{eqb\_stringP}} \coqdocvariable{x1} \coqdocvariable{x2}) 对 \coqref{LF.Maps.eqb string}{\coqdocdefinition{eqb\_string}} \coqdocvariable{x1} \coqdocvariable{x2}
    的结果进行分类讨论的同时，生成关于 \coqdocvariable{x1} 和 \coqdocvariable{x2} （在 = 的意义上）
    的相等关系前提。 

\paragraph{练习：2 星, standard (t\_update\_same)}




    请仿照 \coqdoclibrary{IndProp} 一章中的示例，用 \coqref{LF.Maps.eqb stringP}{\coqdoclemma{eqb\_stringP}} 来证明以下定理，
    它陈述了：如果我们用映射 \coqdocvariable{m} 中已经与键 \coqdocvariable{x} 相关联的值更新了 \coqdocvariable{x}，
    那么其结果与 \coqdocvariable{m} 相等： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Maps.t update same}{t\_update\_same}{\coqdoclemma{t\_update\_same}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{m} : \coqref{LF.Maps.total map}{\coqdocdefinition{total\_map}} \coqdocvariable{A}) \coqdocvar{x},\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{m} \coqdocvariable{x} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard, recommended (t\_update\_permute)}




    使用 \coqref{LF.Maps.eqb stringP}{\coqdoclemma{eqb\_stringP}} 来证明最后一个 \coqref{LF.Lists.PartialMap.update}{\coqdocdefinition{update}} 函数的性质：
    如果我们更新了映射 \coqdocvariable{m} 中两个不同的键，那么更新的顺序无关紧要。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Maps.t update permute}{t\_update\_permute}{\coqdoclemma{t\_update\_permute}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{m} : \coqref{LF.Maps.total map}{\coqdocdefinition{total\_map}} \coqdocvariable{A})\coqdoceol
\coqdocindent{17.00em}
\coqdocvar{v1} \coqdocvar{v2} \coqdocvar{x1} \coqdocvar{x2},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{x2} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{x1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x1} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{v1} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{x2} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{v2} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x2} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{v2} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{x1} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqdocvariable{v1} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{偏映射}



 最后，我们在全映射之上定义\textit{'偏映射'}。元素类型为 \coqref{LF.Basics.A}{\coqdocconstructor{A}} 的偏映射不过就是个
    元素类型为 \coqref{LF.Poly.OptionPlayground.option}{\coqdocinductive{option}} \coqref{LF.Basics.A}{\coqdocconstructor{A}}，默认元素为 \coqref{LF.Lists.NatList.None}{\coqdocconstructor{None}} 的全映射。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Maps.partial map}{partial\_map}{\coqdocdefinition{partial\_map}} (\coqdocvar{A} : \coqdockw{Type}) := \coqref{LF.Maps.total map}{\coqdocdefinition{total\_map}} (\coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqdocvariable{A}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Maps.empty}{empty}{\coqdocdefinition{empty}} \{\coqdocvar{A} : \coqdockw{Type}\} : \coqref{LF.Maps.partial map}{\coqdocdefinition{partial\_map}} \coqdocvariable{A} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Maps.t empty}{\coqdocdefinition{t\_empty}} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Maps.update}{update}{\coqdocdefinition{update}} \{\coqdocvar{A} : \coqdockw{Type}\} (\coqdocvar{m} : \coqref{LF.Maps.partial map}{\coqdocdefinition{partial\_map}} \coqdocvariable{A})\coqdoceol
\coqdocindent{5.50em}
(\coqdocvar{x} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) (\coqdocvar{v} : \coqdocvariable{A}) :=\coqdoceol
\coqdocindent{1.00em}
(\coqdocvariable{x} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{!->}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{v} \coqref{LF.Maps.:::x '!->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们为偏映射引入类似的记法。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Maps.:::x '|->' x ';' x}{"}{"}x '|->' v ';' m" := (\coqref{LF.Maps.update}{\coqdocdefinition{update}} \coqdocvar{m} \coqdocvar{x} \coqdocvar{v})\coqdoceol
\coqdocindent{1.00em}
(\coqdoctac{at} \coqdockw{level} 100, \coqdocvar{v} \coqdoctac{at} \coqdocvar{next} \coqdockw{level}, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
当最后一种情况为空时，我们也可以隐藏它。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Maps.:::x '|->' x}{"}{"}x '|->' v" := (\coqref{LF.Maps.update}{\coqdocdefinition{update}} \coqref{LF.Maps.empty}{\coqdocdefinition{empty}} \coqdocvar{x} \coqdocvar{v})\coqdoceol
\coqdocindent{1.00em}
(\coqdoctac{at} \coqdockw{level} 100).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Maps.examplepmap}{examplepmap}{\coqdocdefinition{examplepmap}} :=\coqdoceol
\coqdocindent{1.00em}
("Church" \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{|->}} \coqexternalref{true}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{true}} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{;}} "Turing" \coqref{LF.Maps.:::x '|->' x}{\coqdocnotation{|->}} \coqexternalref{false}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{false}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在我们将所有关于全映射的基本引理直接转换成对应的偏映射引理。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Maps.apply empty}{apply\_empty}{\coqdoclemma{apply\_empty}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{x} : \coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}),\coqdoceol
\coqdocindent{2.00em}
@\coqref{LF.Maps.empty}{\coqdocdefinition{empty}} \coqdocvariable{A} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqref{LF.Maps.empty}{\coqdocdefinition{empty}}. \coqdoctac{rewrite} \coqref{LF.Maps.t apply empty}{\coqdocaxiom{t\_apply\_empty}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Maps.update eq}{update\_eq}{\coqdoclemma{update\_eq}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{m} : \coqref{LF.Maps.partial map}{\coqdocdefinition{partial\_map}} \coqdocvariable{A}) \coqdocvar{x} \coqdocvar{v},\coqdoceol
\coqdocindent{2.00em}
(\coqdocvariable{x} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{|->}} \coqdocvariable{v} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}) \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{v}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqref{LF.Maps.update}{\coqdocdefinition{update}}. \coqdoctac{rewrite} \coqref{LF.Maps.t update eq}{\coqdocaxiom{t\_update\_eq}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Maps.update neq}{update\_neq}{\coqdoclemma{update\_neq}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{m} : \coqref{LF.Maps.partial map}{\coqdocdefinition{partial\_map}} \coqdocvariable{A}) \coqdocvar{x1} \coqdocvar{x2} \coqdocvar{v},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{x2} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{x1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
(\coqdocvariable{x2} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{|->}} \coqdocvariable{v} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}) \coqdocvariable{x1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqdocvariable{x1}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{m} \coqdocvar{x1} \coqdocvar{x2} \coqdocvar{v} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{LF.Maps.update}{\coqdocdefinition{update}}. \coqdoctac{rewrite} \coqref{LF.Maps.t update neq}{\coqdocaxiom{t\_update\_neq}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Maps.update shadow}{update\_shadow}{\coqdoclemma{update\_shadow}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{m} : \coqref{LF.Maps.partial map}{\coqdocdefinition{partial\_map}} \coqdocvariable{A}) \coqdocvar{x} \coqdocvar{v1} \coqdocvar{v2},\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{|->}} \coqdocvariable{v2} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{x} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{|->}} \coqdocvariable{v1} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{|->}} \coqdocvariable{v2} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{m} \coqdocvar{x} \coqdocvar{v1} \coqdocvar{v2}. \coqdoctac{unfold} \coqref{LF.Maps.update}{\coqdocdefinition{update}}. \coqdoctac{rewrite} \coqref{LF.Maps.t update shadow}{\coqdocaxiom{t\_update\_shadow}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Maps.update same}{update\_same}{\coqdoclemma{update\_same}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{m} : \coqref{LF.Maps.partial map}{\coqdocdefinition{partial\_map}} \coqdocvariable{A}) \coqdocvar{x} \coqdocvar{v},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{m} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvariable{v} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{|->}} \coqdocvariable{v} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{m} \coqdocvar{x} \coqdocvar{v} \coqdocvar{H}. \coqdoctac{unfold} \coqref{LF.Maps.update}{\coqdocdefinition{update}}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.Maps.t update same}{\coqdocaxiom{t\_update\_same}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Maps.update permute}{update\_permute}{\coqdoclemma{update\_permute}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{m} : \coqref{LF.Maps.partial map}{\coqdocdefinition{partial\_map}} \coqdocvariable{A})\coqdoceol
\coqdocindent{16.00em}
\coqdocvar{x1} \coqdocvar{x2} \coqdocvar{v1} \coqdocvar{v2},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{x2} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{x1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x1} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{|->}} \coqdocvariable{v1} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{x2} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{|->}} \coqdocvariable{v2} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{x2} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{|->}} \coqdocvariable{v2} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{x1} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{|->}} \coqdocvariable{v1} \coqref{LF.Maps.:::x '|->' x ';' x}{\coqdocnotation{;}} \coqdocvariable{m}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{m} \coqdocvar{x1} \coqdocvar{x2} \coqdocvar{v1} \coqdocvar{v2}. \coqdoctac{unfold} \coqref{LF.Maps.update}{\coqdocdefinition{update}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.Maps.t update permute}{\coqdocaxiom{t\_update\_permute}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.IndProp}{Library }{LF.IndProp}

\begin{coqdoccode}
\end{coqdoccode}
\section{IndProp: 归纳定义的命题}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Export} \coqref{LF.Logic}{\coqdoclibrary{Logic}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.omega.Omega}{\coqdoclibrary{Coq.omega.Omega}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{归纳定义的命题}



 在 \coqdoclibrary{Logic} 一章中，我们学习了多种方式来书写命题，包括合取、析取和存在量词。
    在本章中，我们引入另一种新的方式：\textit{'归纳定义（Inductive Definitions）'}。


    \textit{'注意'}：为简单起见，本章中的大部分内容都用一个归纳定义的“偶数性”作为展示的例子。
    你可能会为此感到不解，因为我们已经有一种将偶数性定义为命题的完美方法了（若
    \coqdocvariable{n} 等于某个整数的二倍，那么它是是偶数）。尚若如此，那么请放心，
    在本章末尾和以后的章节中，我们会看到更多引人入胜的归纳定义的命题示例。 

 在前面的章节中，我们已经见过两种表述 \coqdocvariable{n} 为偶数的方式了：


      (1) \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvariable{n} = \coqref{LF.Basics.true}{\coqdocconstructor{true}}，以及


      (2) \coqdoctac{\ensuremath{\exists}} \coqdocvariable{k}, \coqdocvariable{n} = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{k}。


    然而还有一种方式是通过如下规则来建立 \coqdocvariable{n} 的偶数性质：



\begin{itemize}
\item  规则 \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}}: 0 是偶数。

\item  规则 \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}: 如果 \coqdocvariable{n} 是偶数, 那么 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}) 也是偶数。 
\end{itemize}


 为了理解这个新的偶数性质定义如何工作，我们可想象如何证明 4 是偶数。
    根据规则 \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}，需要证明 2 是偶数。这时，只要证明 0 是偶数，
    我们可继续通过规则 \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 确保它成立。而使用规则 \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}} 可直接证明 0 是偶数。

 接下来的课程中，我们会看到很多类似方式定义的命题。
    在非形式化的讨论中，使用简单的记法有助于阅读和书写。
    \textit{'推断规则（Inference Rules）'}就是其中的一种。
    （我们为此性质取名为 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}}，因为 \coqref{LF.Logic.even}{\coqdocdefinition{even}} 已经用过了。）
\par
\noindent\hrulefill\par
\noindent{}             (ev\_0)
                                 ev 0


                                 ev n
\par
\noindent\hrulefill\par
\noindent{}          (ev\_SS)
                             ev (S (S n))




    若将上面的规则重新排版成推断规则，我们可以这样阅读它，如果线上方的
    \textit{'前提（Premises）'}成立，那么线下方的\textit{'结论（Conclusion）'}成立。
    比如，规则 \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 读做如果 \coqdocvariable{n} 满足 \coqref{LF.Logic.even}{\coqdocdefinition{even}}，那么 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}) 也满足。
    如果一条规则在线上方没有前提，则结论直接成立。


    我们可以通过组合推断规则来展示证明。下面展示如何转译 4 是偶数的证明：
\par
\noindent\hrulefill\par
\noindent{}  (ev\_0)
                              ev 0
\par
\noindent\hrulefill\par
\noindent{} (ev\_SS)
                              ev 2
\par
\noindent\hrulefill\par
\noindent{} (ev\_SS)
                              ev 4


 （为什么我们把这样的证明称之为“树”而非其他，比如“栈”？
    因为一般来说推断规则可以有多个前提。我们很快就会看到一些例子。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{偶数性的归纳定义}




    基于上述，可将偶数性质的定义翻译为在 Coq 中使用 \coqdockw{Inductive} 声明的定义，
    声明中每一个构造子对应一个推断规则： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndProp.ev}{ev}{\coqdocinductive{ev}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.IndProp.ev 0}{ev\_0}{\coqdocconstructor{ev\_0}} : \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 0\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.IndProp.ev SS}{ev\_SS}{\coqdocconstructor{ev\_SS}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{H} : \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}) : \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这个定义与之前 \coqdockw{Inductive} 定义的用法有一个有趣的区别：一方面，
    我们定义的并不是一个 \coqdockw{Type}（如 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}），而是一个将 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 映射到 \coqdockw{Prop}
    的函数——即关于数的性质。然而真正要关注的是，由于 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 中的 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}
    参数出现在冒号\textit{'右侧'}，这允许在不同的构造子类型中使用不同的值：例如
    \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}} 类型中的 0 以及 \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 类型中的 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n})。与此相应，
    每个构造子的类型必须在冒号后显式指定，并且对于某个自然数 \coqdocvariable{n}
    来说，每个构造子的类型都必须有 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} 的形式。


    相反，回忆 \coqref{LF.Poly.list}{\coqdocinductive{list}} 的定义：


    Inductive list (X:Type) : Type :=
      | nil
      | cons (x : X) (l : list X).


    它以\textit{'全局的方式'}在冒号\textit{'左侧'}引入了参数 \coqref{LF.Imp.X}{\coqdocdefinition{X}}，
    强迫 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} 和 \coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 的结果为同一个类型（\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}}）。
    如果在定义 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 时将 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 置于冒号左侧，就会得到如下错误： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Fail} \coqdockw{Inductive} \coqdef{LF.IndProp.wrong ev}{wrong\_ev}{\coqdocinductive{wrong\_ev}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.IndProp.wrong ev 0}{wrong\_ev\_0}{\coqdocconstructor{wrong\_ev\_0}} : \coqref{LF.IndProp.wrong ev}{\coqdocinductive{wrong\_ev}} 0\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.IndProp.wrong ev SS}{wrong\_ev\_SS}{\coqdocconstructor{wrong\_ev\_SS}} (\coqdocvar{H}: \coqref{LF.IndProp.wrong ev}{\coqdocinductive{wrong\_ev}} \coqdocvariable{n}) : \coqref{LF.IndProp.wrong ev}{\coqdocinductive{wrong\_ev}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在 \coqdockw{Inductive} 定义中，类型构造子冒号左侧的参数叫做形参（Parameter），
    而右侧的叫做索引（Index）或注解（Annotation）。


    例如，在 \coqdockw{Inductive} \coqref{LF.Poly.list}{\coqdocinductive{list}} (\coqref{LF.Imp.X}{\coqdocdefinition{X}} : \coqdockw{Type}) := ... 中，\coqref{LF.Imp.X}{\coqdocdefinition{X}} 是一个形参；而在
    \coqdockw{Inductive} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} : \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} \ensuremath{\rightarrow} \coqdockw{Prop} := ... 中，未命名的 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 参数是一个索引。 

 在 Coq 中，我们可以认为 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 定义了一个性质 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} : \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} \ensuremath{\rightarrow} \coqdockw{Prop}，其包括
    “证据构造子” \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}} : \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 0 和 \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} : \coqdockw{\ensuremath{\forall}} \coqdocvariable{n}, \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \ensuremath{\rightarrow} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}))。 

 这些 “证据构造子” 等同于已经证明过的定理。
    具体来说，我们可以使用 Coq 中的 \coqdoctac{apply} 策略和规则名称来证明某个数的 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 性质…… \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.ev 4}{ev\_4}{\coqdoclemma{ev\_4}} : \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 4.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{apply} \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}. \coqdoctac{apply} \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}. \coqdoctac{apply} \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
……或使用函数应用的语法： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.ev 4'}{ev\_4'}{\coqdoclemma{ev\_4'}} : \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 4.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{apply} (\coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 2 (\coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 0 \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}})). \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们同样可以对前提中使用到 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 的定理进行证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.ev plus4}{ev\_plus4}{\coqdoclemma{ev\_plus4}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (4 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{Hn}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}. \coqdoctac{apply} \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}. \coqdoctac{apply} \coqdocvar{Hn}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
更一般地，我们可以证明以任意数乘 2 是偶数： 

\paragraph{练习：1 星, standard (ev\_double)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.ev double}{ev\_double}{\coqdoclemma{ev\_double}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{在证明中使用证据}



 除了\textit{'构造'}证据（evidence）来表示某个数是偶数，我们还可以\textit{'解构'}这样的证据，
    这等于对它的构造进行论证。


    对 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 而言，使用 \coqdockw{Inductive} 声明来引入 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 会告诉 Coq，
    \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}} 和 \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 构造子不仅是构造偶数证明证据的有效方式，
    还是构造一个数满足 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 的证据的\textit{'唯一'}方式。 

 换句话说，如果某人展示了对于 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} 的证据 \coqdocvar{E}，那么我们知道 \coqdocvar{E}
    必是二者其一：



\begin{itemize}
\item  \coqdocvar{E} 是 \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}}（且 \coqdocvariable{n} 为 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}}），或

\item  \coqdocvar{E} 是 \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} \coqdocvariable{n'} \coqdocvar{E'}（且 \coqdocvariable{n} 为 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'})，\coqdocvar{E'} 为
        \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n'} 的证据）. 
\end{itemize}


 这样的形式暗示着，我们可以像分析归纳定义的数据结构一样分析形如 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}
    的假设；特别地，对于这类证据使用\textit{'归纳（induction）'}和\textit{'分类讨论（case
    analysis）'}来进行论证也是可行的。让我们通过一些例子来学习实践中如何使用他们。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{对证据进行反演}



 Suppose we are proving some fact involving a number \coqdocvariable{n}, and
    we are given \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} as a hypothesis.  We already know how to
    perform case analysis on \coqdocvariable{n} using \coqdoctac{destruct} or \coqdoctac{induction},
    generating separate subgoals for the case where \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} and the
    case where \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'} for some \coqdocvariable{n'}.  But for some proofs we may
    instead want to analyze the evidence that \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \textit{directly}. As
    a tool, we can prove our characterization of evidence for
    \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}, using \coqdoctac{destruct}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.ev inversion}{ev\_inversion}{\coqdoclemma{ev\_inversion}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}), \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{n'}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n'}) \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n'}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{E}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{E} \coqdockw{as} [ \ensuremath{|} \coqdocvar{n'} \coqdocvar{E'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{left}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{right}. \coqdoctac{\ensuremath{\exists}} \coqdocvar{n'}. \coqdoctac{split}. \coqdoctac{reflexivity}. \coqdoctac{apply} \coqdocvar{E'}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
用 \coqdoctac{destruct} 解构证据即可证明下述定理： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.ev minus2}{ev\_minus2}{\coqdoclemma{ev\_minus2}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqexternalref{pred}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{pred}} (\coqexternalref{pred}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{pred}} \coqdocvariable{n})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{E}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{E} \coqdockw{as} [| \coqdocvar{n'} \coqdocvar{E'}].\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}. \coqdoctac{apply} \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}. \coqdoctac{apply} \coqdocvar{E'}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
However, this variation cannot easily be handled with just
    \coqdoctac{destruct}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.evSS ev}{evSS\_ev}{\coqdoclemma{evSS\_ev}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n})) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Logic.even}{\coqdocdefinition{even}} \coqdocvariable{n}.\coqdoceol
\end{coqdoccode}
直观来说，我们知道支撑前提的证据不会由 \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}} 组成，因为 0 和 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 是
    \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 类型不同的构造子；由此 \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} 是唯一需要应对的情况（译注：\coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}} 无条件成立）。
    不幸的是，\coqdoctac{destruct} 并没有如此智能，它仍然为我们生成两个子目标。
    更坏的是，于此同时最终目标没有改变，也无法为完成证明提供任何有用的信息。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{E}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{E} \coqdockw{as} [| \coqdocvar{n'} \coqdocvar{E'}] \coqdocvar{eqn}:\coqdocvar{EE}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
究竟发生了什么？应用 \coqdoctac{destruct} 把性质的参数替换为对应于构造子的值。
    这对于证明 \coqdocvar{ev\_minus2'} 是有帮助的，因为在最终目标中直接使用到了参数 \coqdocvariable{n}。
    然而，这对于 \coqref{LF.IndProp.evSS ev}{\coqdoclemma{evSS\_ev}} 并没有帮助，因为被替换掉的 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}) 并没有在其他地方被使用。

 If we \coqdocvar{remember} that term \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}), the proof goes
    through.  (We'll discuss \coqdocvar{remember} in more detail below.) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.evSS ev remember}{evSS\_ev\_remember}{\coqdoclemma{evSS\_ev\_remember}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n})) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{H}. \coqdocvar{remember} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n})) \coqdockw{as} \coqdocvar{k}. \coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [|\coqdocvar{n'} \coqdocvar{E'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{discriminate} \coqdocvar{Heqk}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{injection} \coqdocvar{Heqk} \coqdockw{as} \coqdocvar{Heq}. \coqdoctac{rewrite} \coqdocvar{Heq} \coqdoctac{in} \coqdocvar{E'}. \coqdoctac{apply} \coqdocvar{E'}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Alternatively, the proof is straightforward using our inversion
    lemma. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.evSS ev}{evSS\_ev}{\coqdoclemma{evSS\_ev}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n})) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{intros} \coqdocvar{n} \coqdocvar{H}. \coqdoctac{apply} \coqref{LF.IndProp.ev inversion}{\coqdoclemma{ev\_inversion}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{0.50em}
- \coqdoctac{discriminate} \coqdocvar{H}.\coqdoceol
\coqdocindent{0.50em}
- \coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{n'} [\coqdocvar{Hnm} \coqdocvar{Hev}]]. \coqdoctac{injection} \coqdocvar{Hnm} \coqdockw{as} \coqdocvar{Heq}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{rewrite} \coqdocvar{Heq}. \coqdoctac{apply} \coqdocvar{Hev}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Note how both proofs produce two subgoals, which correspond
    to the two ways of proving \coqref{LF.IndProp.ev}{\coqdocinductive{ev}}.  The first subgoal is a
    contradiction that is discharged with \coqdoctac{discriminate}.  The second
    subgoal makes use of \coqdoctac{injection} and \coqdoctac{rewrite}.  Coq provides a
    handy tactic called \coqdoctac{inversion} that factors out that common
    pattern.


    The \coqdoctac{inversion} tactic can detect (1) that the first case (\coqdocvariable{n} =
    0) does not apply and (2) that the \coqdocvariable{n'} that appears in the
    \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} case must be the same as \coqdocvariable{n}.  It has an ``\coqdockw{as}'' variant
    similar to \coqdoctac{destruct}, allowing us to assign names rather than
    have Coq choose them. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.evSS ev'}{evSS\_ev'}{\coqdoclemma{evSS\_ev'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n})) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{E}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{inversion} \coqdocvar{E} \coqdockw{as} [| \coqdocvar{n'} \coqdocvar{E'} \coqdocvar{EQ}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{E'}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqdoctac{inversion} tactic can apply the principle of explosion to
    ``obviously contradictory'' hypotheses involving inductively defined
    properties, something that takes a bit more work using our
    inversion lemma. For example: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.one not even}{one\_not\_even}{\coqdoclemma{one\_not\_even}} : \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 1.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H}. \coqdoctac{apply} \coqref{LF.IndProp.ev inversion}{\coqdoclemma{ev\_inversion}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [ \ensuremath{|} [\coqdocvar{m} [\coqdocvar{Hm} \coqdocvar{\_}]]].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{discriminate} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{discriminate} \coqdocvar{Hm}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.one not even'}{one\_not\_even'}{\coqdoclemma{one\_not\_even'}} : \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 1.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H}. \coqdoctac{inversion} \coqdocvar{H}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, standard (inversion\_practice)}




    利用 \coqdoctac{inversion} 策略证明以下结论。（如想进一步练习，请使用反演定理证明之。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.SSSSev  even}{SSSSev\_\_even}{\coqdoclemma{SSSSev\_\_even}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n})))) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：1 星, standard (ev5\_nonsense)}




    请使用 \coqdoctac{inversion} 策略证明以下结果。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.ev5 nonsense}{ev5\_nonsense}{\coqdoclemma{ev5\_nonsense}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 5 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} 2 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 9.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 The \coqdoctac{inversion} tactic does quite a bit of work. For
    example, when applied to an equality assumption, it does the work
    of both \coqdoctac{discriminate} and \coqdoctac{injection}. In addition, it carries
    out the \coqdoctac{intros} and \coqdoctac{rewrite}s that are typically necessary in
    the case of \coqdoctac{injection}. It can also be applied, more generally,
    to analyze evidence for inductively defined propositions.  As
    examples, we'll use it to reprove some theorems from chapter
    \coqdoclibrary{Tactics}.  (Here we are being a bit lazy by omitting the \coqdockw{as}
    clause from \coqdoctac{inversion}, thereby asking Coq to choose names for
    the variables and hypotheses that it introduces.) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.inversion ex1}{inversion\_ex1}{\coqdoclemma{inversion\_ex1}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} \coqdocvar{o} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} \coqdocvariable{m}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{o}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} \coqdocvariable{o}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{m}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{H}. \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.inversion ex2}{inversion\_ex2}{\coqdoclemma{inversion\_ex2}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
2 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 5.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{contra}. \coqdoctac{inversion} \coqdocvar{contra}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdoctac{inversion} 的工作原理大致如下：假设 \coqdocvariable{H} 指代上下文中的假设 \coqdocvariable{P}，
    且 \coqdocvariable{P} 由 \coqdockw{Inductive} 归纳定义，则对于 \coqdocvariable{P} 每一种可能的构造，\coqdoctac{inversion} \coqdocvariable{H}
    各为其生成子目标。子目标中自相矛盾者被忽略，证明其余子命题即可得证原命题。
    在证明子目标时，上下文中的 \coqdocvariable{H} 会替换为 \coqdocvariable{P} 的构造条件，
    即其构造子所需参数以及必要的等式关系。例如：倘若 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} 由 \coqdocvar{evSS} 构造，
    上下文中会引入参数 \coqdocvariable{n'}、\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n'}，以及等式 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}) = \coqdocvariable{n}。 

 上面的 \coqref{LF.IndProp.ev double}{\coqdoclemma{ev\_double}} 练习展示了偶数性质的一种新记法，其被之前的两种记法所蕴含。
    （因为，由  \coqdoclibrary{Logic} 一章中的 \coqref{LF.Logic.even bool prop}{\coqdoclemma{even\_bool\_prop}}，我们已经知道
    他们是互相等价的。）
    为了展示这三种方式的一致性，我们需要下面的引理： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.ev even firsttry}{ev\_even\_firsttry}{\coqdoclemma{ev\_even\_firsttry}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Logic.even}{\coqdocdefinition{even}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们可以尝试使用分类讨论或对 \coqdocvariable{n} 进行归纳。但由于 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}}
    在前提中出现，所以和前面章节的一些例子一样，这种策略行不通，
    因为如前面提到的，归纳法则会讨论 n-1，而它并不是偶数！
    如此我们似乎可以先试着对 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 的证据进行反演。
    确实，第一个分类可以被平凡地证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{E}. \coqdoctac{inversion} \coqdocvar{E} \coqdockw{as} [\coqdocvar{EQ'} \ensuremath{|} \coqdocvar{n'} \coqdocvar{E'} \coqdocvar{EQ'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{\ensuremath{\exists}} 0. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
然而第二个分类要困难一些。我们需要证明 \coqdoctac{\ensuremath{\exists}} \coqdocvariable{k}, \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}) = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{k}，
    但唯一可用的假设是 \coqdocvar{E'}，也即 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n'} 成立。但这对证明并没有帮助，
    我们似乎被卡住了，而对 \coqdocvar{E} 进行分类讨论是徒劳的。


    如果仔细观察第二个（子）目标，我们可以发现一些有意思的事情：
    对 \coqdocvar{E} 进行分类讨论，我们可以把要证明的原始目标归约到另一个上，
    其涉及到另一个 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 的证据： \coqdocvar{E'}。
    形式化地说，我们可以通过展示如下证据来完成证明：


        exists k', n' = double k',


    这同原始的命题是等价的，只是 \coqdocvariable{n'} 被替换为 n。确实，通过这个中间结果完成证明
    并不困难。  \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{I} : \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{k'}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvar{n'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{k'}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{8.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{k}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n'}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{k}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}).\coqdoceol
\coqdocindent{2.00em}
\{ \coqdoctac{intros} [\coqdocvar{k'} \coqdocvar{Hk'}]. \coqdoctac{rewrite} \coqdocvar{Hk'}. \coqdoctac{\ensuremath{\exists}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{k'}). \coqdoctac{reflexivity}. \}\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{I}. \coqdocemptyline
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{对证据进行归纳}



 上面的情形看起来似曾相识，但这并非巧合。在 \coqdockw{Induction}
    一章中，我们曾试着用分类讨论来证明其实需要归纳才能证明的命题。
    这一次，解决方法仍然是……使用归纳！ 

 对证据和对数据使用 \coqdoctac{induction} 具有同样的行为：它导致 Coq
    对每个可用于构造证据的构造子生成一个子目标，同时对递归出现的问题性质提供了归纳假设。


    To prove a property of \coqdocvariable{n} holds for all numbers for which \coqref{LF.IndProp.ev}{\coqdocinductive{ev}}
    \coqdocvariable{n} holds, we can use induction on \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}. This requires us to
    prove two things, corresponding to the two ways in which \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}
    could have been constructed. If it was constructed by \coqref{LF.IndProp.ev 0}{\coqdocconstructor{ev\_0}}, then
    \coqdocvariable{n}=0, and the property must hold of 0. If it was constructed by
    \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}}, then the evidence of \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} is of the form \coqref{LF.IndProp.ev SS}{\coqdocconstructor{ev\_SS}} \coqdocvariable{n'}
    \coqdocvar{E'}, where \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}) and \coqdocvar{E'} is evidence for \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n'}. In
    this case, the inductive hypothesis says that the property we are
    trying to prove holds for \coqdocvariable{n'}. 

 让我们再次尝试证明这个引理： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.ev even}{ev\_even}{\coqdoclemma{ev\_even}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Logic.even}{\coqdocdefinition{even}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{E}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{E} \coqdockw{as} [|\coqdocvar{n'} \coqdocvar{E'} \coqdocvar{IH}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{\ensuremath{\exists}} 0. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{IH} \coqdockw{as} [\coqdocvar{k'} \coqdocvar{Hk'}].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{Hk'}. \coqdoctac{\ensuremath{\exists}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{k'}). \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这里我们看到 Coq 对 \coqdocvar{E'} 产生了 \coqdocvar{IH}，而 \coqdocvar{E'} 是唯一递归出现的
    \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 命题。 由于 \coqdocvar{E'} 中涉及到 \coqdocvariable{n'}，这个归纳假设是关于 \coqdocvariable{n'} 的，
    而非关于 \coqdocvariable{n} 或其他数字的。  

 关于偶数性质的第二个和第三个定义的等价关系如下： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.ev even iff}{ev\_even\_iff}{\coqdoclemma{ev\_even\_iff}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{LF.Logic.even}{\coqdocdefinition{even}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{apply} \coqref{LF.IndProp.ev even}{\coqdoclemma{ev\_even}}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{intros} [\coqdocvar{k} \coqdocvar{Hk}]. \coqdoctac{rewrite} \coqdocvar{Hk}. \coqdoctac{apply} \coqref{LF.IndProp.ev double}{\coqdocaxiom{ev\_double}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们会在后面的章节中看到，对证据进行归纳在很多领域里是一种常用的技术，
    特别是在形式化程序语言的语义时，由于其中很多有趣的性质都是归纳定义的。 

 下面的练习提供了一些简单的例子，来帮助你熟悉这项技术。 

\paragraph{练习：2 星, standard (ev\_sum)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.ev sum}{ev\_sum}{\coqdoclemma{ev\_sum}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m}, \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：4 星, advanced, optional (ev'\_ev)}




    一般来说，有很多种方式来归纳地定义一个性质。比如说，下面是关于
    \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 的另一种（蹩脚的）定义：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndProp.ev'}{ev'}{\coqdocinductive{ev'}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.IndProp.ev' 0}{ev'\_0}{\coqdocconstructor{ev'\_0}} : \coqref{LF.IndProp.ev'}{\coqdocinductive{ev'}} 0\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.IndProp.ev' 2}{ev'\_2}{\coqdocconstructor{ev'\_2}} : \coqref{LF.IndProp.ev'}{\coqdocinductive{ev'}} 2\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.IndProp.ev' sum}{ev'\_sum}{\coqdocconstructor{ev'\_sum}} \coqdocvar{n} \coqdocvar{m} (\coqdocvar{Hn} : \coqref{LF.IndProp.ev'}{\coqdocinductive{ev'}} \coqdocvariable{n}) (\coqdocvar{Hm} : \coqref{LF.IndProp.ev'}{\coqdocinductive{ev'}} \coqdocvariable{m}) : \coqref{LF.IndProp.ev'}{\coqdocinductive{ev'}} (\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
请证明这个定义在逻辑上等同于前述定义。为了精简证明，请使用 \coqdoclibrary{Logic}
    一章中将定理应用到参数的技术，注意同样的技术也可用于归纳定义的命题的构造子。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.ev' ev}{ev'\_ev}{\coqdoclemma{ev'\_ev}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqref{LF.IndProp.ev'}{\coqdocinductive{ev'}} \coqdocvariable{n} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, advanced, recommended (ev\_ev\_\_ev)}




    这里有两个可以试着在其上进行归纳的证据，一个不行就换另一个。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.ev ev  ev}{ev\_ev\_\_ev}{\coqdoclemma{ev\_ev\_\_ev}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqdocvariable{n}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}}\coqdocvariable{m}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard, optional (ev\_plus\_plus)}




    本练习只需要使用前述引理，而无需使用归纳或分类讨论，
    虽然一些改写可能会比较乏味。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.ev plus plus}{ev\_plus\_plus}{\coqdoclemma{ev\_plus\_plus}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqdocvariable{n}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}}\coqdocvariable{m}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqdocvariable{n}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}}\coqdocvariable{p}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqdocvariable{m}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}}\coqdocvariable{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{归纳关系}



 我们可以认为被一个数所参数化的命题（比如 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}}）是一个\textit{'性质'}，也即，
    它定义了 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}　的一个子集，其中的数可以被证明满足此命题。
    以同样的方式，我们可认为有两个参数的命题是一个\textit{'关系'}，也即，它定义了一个
    可满足此命题的序对集合。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.IndProp.Playground}{Playground}{\coqdocmodule{Playground}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
和命题一样，关系也可以归纳地定义。一个很有用的例子是整数的“小于等于”关系。

 下面的定义应当是比较直观的。它提供了两种方法来描述一个数小于等于另一个数的证据：
    要么可观察到两个数相等，或提供证据显示第一个数小于等于第二个数的前继。　\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndProp.Playground.le}{le}{\coqdocinductive{le}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.Playground.le n}{le\_n}{\coqdocconstructor{le\_n}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})                : \coqref{LF.IndProp.le}{\coqdocinductive{le}} \coqdocvariable{n} \coqdocvariable{n}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.Playground.le S}{le\_S}{\coqdocconstructor{le\_S}} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{H} : \coqref{LF.IndProp.le}{\coqdocinductive{le}} \coqdocvariable{n} \coqdocvariable{m}) : \coqref{LF.IndProp.le}{\coqdocinductive{le}} \coqdocvariable{n} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{m}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.IndProp.Playground.:::x '<=' x}{"}{"}m <= n" := (\coqref{LF.IndProp.Playground.le}{\coqdocinductive{le}} \coqdocvar{m} \coqdocvar{n}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
类似于证明 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 这样的性质，使用 \coqref{LF.IndProp.Playground.le n}{\coqdocconstructor{le\_n}} 和 \coqref{LF.IndProp.Playground.le S}{\coqdocconstructor{le\_S}} 构造子来证明关于 \ensuremath{\le}
    的事实遵循了同样的模式。我们可以对构造子使用 \coqdoctac{apply} 策略来证明 \ensuremath{\le} 目标
    （比如证明 3<=3 或 3<=6），也可以使用 \coqdoctac{inversion} 策略来从上下文中 \ensuremath{\le}
    的假设里抽取信息（比如证明 (2<=1) \ensuremath{\rightarrow} 2+2=5）。 

 这里提供一些完备性检查。（请注意，尽管这同我们在开始课程时编写的
    函数“单元测试”类似，但我们在这里必须明确地写下他们的证明——\coqdoctac{simpl} 和
    \coqdoctac{reflexivity} 并不会有效果，因为这些证明不仅仅是对表达式进行简化。）  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.Playground.test le1}{test\_le1}{\coqdoclemma{test\_le1}} :\coqdoceol
\coqdocindent{1.00em}
3 \coqref{LF.IndProp.Playground.:::x '<=' x}{\coqdocnotation{\ensuremath{\le}}} 3.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.IndProp.Playground.le n}{\coqdocconstructor{le\_n}}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.Playground.test le2}{test\_le2}{\coqdoclemma{test\_le2}} :\coqdoceol
\coqdocindent{1.00em}
3 \coqref{LF.IndProp.Playground.:::x '<=' x}{\coqdocnotation{\ensuremath{\le}}} 6.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.IndProp.Playground.le S}{\coqdocconstructor{le\_S}}. \coqdoctac{apply} \coqref{LF.IndProp.Playground.le S}{\coqdocconstructor{le\_S}}. \coqdoctac{apply} \coqref{LF.IndProp.Playground.le S}{\coqdocconstructor{le\_S}}. \coqdoctac{apply} \coqref{LF.IndProp.Playground.le n}{\coqdocconstructor{le\_n}}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.Playground.test le3}{test\_le3}{\coqdoclemma{test\_le3}} :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}2 \coqref{LF.IndProp.Playground.:::x '<=' x}{\coqdocnotation{\ensuremath{\le}}} 1\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} 2 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 5.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H}. \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{inversion} \coqdocvar{H2}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在“严格小于”关系 \coqdocvariable{n} < \coqdocvariable{m} 可以使用 \coqref{LF.IndProp.Playground.le}{\coqdocinductive{le}} 来定义。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.IndProp.Playground}{\coqdocmodule{Playground}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.IndProp.lt}{lt}{\coqdocdefinition{lt}} (\coqdocvar{n} \coqdocvar{m}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) := \coqexternalref{le}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocinductive{le}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}) \coqdocvariable{m}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.IndProp.:::x '<' x}{"}{"}m < n" := (\coqref{LF.IndProp.lt}{\coqdocdefinition{lt}} \coqdocvar{m} \coqdocvar{n}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这里展示了一些定义于自然数上的关系：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndProp.square of}{square\_of}{\coqdocinductive{square\_of}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.sq}{sq}{\coqdocconstructor{sq}} \coqdocvar{n} : \coqref{LF.IndProp.square of}{\coqdocinductive{square\_of}} \coqdocvariable{n} (\coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{n}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndProp.next nat}{next\_nat}{\coqdocinductive{next\_nat}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.nn}{nn}{\coqdocconstructor{nn}} \coqdocvar{n} : \coqref{LF.IndProp.next nat}{\coqdocinductive{next\_nat}} \coqdocvariable{n} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndProp.next ev}{next\_ev}{\coqdocinductive{next\_ev}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.ne 1}{ne\_1}{\coqdocconstructor{ne\_1}} \coqdocvar{n} (\coqdocvar{H}: \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}))     : \coqref{LF.IndProp.next ev}{\coqdocinductive{next\_ev}} \coqdocvariable{n} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.ne 2}{ne\_2}{\coqdocconstructor{ne\_2}} \coqdocvar{n} (\coqdocvar{H}: \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}))) : \coqref{LF.IndProp.next ev}{\coqdocinductive{next\_ev}} \coqdocvariable{n} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard, optional (total\_relation)}




    请定一个二元归纳关系 \coqdocvar{total\_relation} 对每一个自然数的序对成立。 \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard, optional (empty\_relation)}




    请定一个二元归纳关系 \coqdocvar{empty\_relation} 对自然数永远为假。 \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
From the definition of \coqref{LF.IndProp.Playground.le}{\coqdocinductive{le}}, we can sketch the behaviors of
    \coqdoctac{destruct}, \coqdoctac{inversion}, and \coqdoctac{induction} on a hypothesis \coqdocvariable{H}
    providing evidence of the form \coqref{LF.IndProp.Playground.le}{\coqdocinductive{le}} \coqdocvariable{e1} \coqdocvariable{e2}.  Doing \coqdoctac{destruct} \coqdocvariable{H}
    will generate two cases. In the first case, \coqdocvariable{e1} = \coqdocvariable{e2}, and it
    will replace instances of \coqdocvariable{e2} with \coqdocvariable{e1} in the goal and context.
    In the second case, \coqdocvariable{e2} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'} for some \coqdocvariable{n'} for which \coqref{LF.IndProp.Playground.le}{\coqdocinductive{le}} \coqdocvariable{e1} \coqdocvariable{n'}
    holds, and it will replace instances of \coqdocvariable{e2} with \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}.
    Doing \coqdoctac{inversion} \coqdocvariable{H} will remove impossible cases and add generated
    equalities to the context for further use. Doing \coqdoctac{induction} \coqdocvariable{H}
    will, in the second case, add the induction hypothesis that the
    goal holds when \coqdocvariable{e2} is replaced with \coqdocvariable{n'}. 

\paragraph{练习：3 星, standard, optional (le\_exercises)}




    这里展示一些 \ensuremath{\le} 和 < 关系的事实，我们在接下来的课程中将会用到他们。
    证明他们将会是非常有益的练习。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.le trans}{le\_trans}{\coqdoclemma{le\_trans}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o}, \coqdocvariable{m} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{o} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{m} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{o}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.O le n}{O\_le\_n}{\coqdoclemma{O\_le\_n}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
0 \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.n le m  Sn le Sm}{n\_le\_m\_\_Sn\_le\_Sm}{\coqdoclemma{n\_le\_m\_\_Sn\_le\_Sm}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.Sn le Sm  n le m}{Sn\_le\_Sm\_\_n\_le\_m}{\coqdoclemma{Sn\_le\_Sm\_\_n\_le\_m}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.le plus l}{le\_plus\_l}{\coqdoclemma{le\_plus\_l}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{a} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{a} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.plus le}{plus\_le}{\coqdoclemma{plus\_le}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n1} \coqdocvar{n2} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n1} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n2} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n1} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{n2} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Hint: the next one may be easiest to prove by induction on \coqdocvariable{n}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.add le cases}{add\_le\_cases}{\coqdoclemma{add\_le\_cases}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} \coqdocvar{q},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{p} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{p} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{m} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.lt S}{lt\_S}{\coqdoclemma{lt\_S}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqref{LF.IndProp.:::x '<' x}{\coqdocnotation{<}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqref{LF.IndProp.:::x '<' x}{\coqdocnotation{<}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.plus lt}{plus\_lt}{\coqdoclemma{plus\_lt}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n1} \coqdocvar{n2} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n1} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n2} \coqref{LF.IndProp.:::x '<' x}{\coqdocnotation{<}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n1} \coqref{LF.IndProp.:::x '<' x}{\coqdocnotation{<}} \coqdocvariable{m} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{n2} \coqref{LF.IndProp.:::x '<' x}{\coqdocnotation{<}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.leb complete}{leb\_complete}{\coqdoclemma{leb\_complete}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
提示：在下面的问题中，对 \coqdocvariable{m} 进行归纳会使证明容易一些。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.leb correct}{leb\_correct}{\coqdoclemma{leb\_correct}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
提示：以下定理可以不使用 \coqdoctac{induction} 而证明。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.leb true trans}{leb\_true\_trans}{\coqdoclemma{leb\_true\_trans}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{m} \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} \coqdocvariable{o} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} \coqdocvariable{o} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, optional (leb\_iff)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.leb iff}{leb\_iff}{\coqdoclemma{leb\_iff}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.IndProp.R}{R}{\coqdocmodule{R}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：3 星, standard, recommended (R\_provability)}




    通过同样的方式，我们可以定义三元关系、四元关系等。例如，考虑以下定义在自然数上的三元关系： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndProp.R.R}{R}{\coqdocinductive{R}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.50em}
\ensuremath{|} \coqdef{LF.IndProp.R.c1}{c1}{\coqdocconstructor{c1}} : \coqref{LF.IndProp.R}{\coqdocinductive{R}} 0 0 0\coqdoceol
\coqdocindent{1.50em}
\ensuremath{|} \coqdef{LF.IndProp.R.c2}{c2}{\coqdocconstructor{c2}} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o} (\coqdocvar{H} : \coqref{LF.IndProp.R}{\coqdocinductive{R}} \coqdocvariable{m} \coqdocvariable{n} \coqdocvariable{o}) : \coqref{LF.IndProp.R}{\coqdocinductive{R}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{m}) \coqdocvariable{n} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{o})\coqdoceol
\coqdocindent{1.50em}
\ensuremath{|} \coqdef{LF.IndProp.R.c3}{c3}{\coqdocconstructor{c3}} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o} (\coqdocvar{H} : \coqref{LF.IndProp.R}{\coqdocinductive{R}} \coqdocvariable{m} \coqdocvariable{n} \coqdocvariable{o}) : \coqref{LF.IndProp.R}{\coqdocinductive{R}} \coqdocvariable{m} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}) (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{o})\coqdoceol
\coqdocindent{1.50em}
\ensuremath{|} \coqdef{LF.IndProp.R.c4}{c4}{\coqdocconstructor{c4}} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o} (\coqdocvar{H} : \coqref{LF.IndProp.R}{\coqdocinductive{R}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{m}) (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}) (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{o}))) : \coqref{LF.IndProp.R}{\coqdocinductive{R}} \coqdocvariable{m} \coqdocvariable{n} \coqdocvariable{o}\coqdoceol
\coqdocindent{1.50em}
\ensuremath{|} \coqdef{LF.IndProp.R.c5}{c5}{\coqdocconstructor{c5}} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o} (\coqdocvar{H} : \coqref{LF.IndProp.R}{\coqdocinductive{R}} \coqdocvariable{m} \coqdocvariable{n} \coqdocvariable{o}) : \coqref{LF.IndProp.R}{\coqdocinductive{R}} \coqdocvariable{n} \coqdocvariable{m} \coqdocvariable{o}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}

\begin{itemize}
\item  下列哪个命题是可以被证明的？

\begin{itemize}
\item  \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 1 1 2

\item  \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 2 2 6



\end{itemize}

\item  如果在 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 的定义中我们丢弃 \coqref{LF.IndProp.R.c5}{\coqdocconstructor{c5}} 构造子，可被证明的集合会发生变化吗？
      简要（一句话）解释你的答案。



\item  如果在 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 的定义中我们丢弃 \coqref{LF.IndProp.R.c4}{\coqdocconstructor{c4}} 构造子，可被证明的集合会发生变化吗？
      简要（一句话）解释你的答案。 
\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.IndProp.R.manual grade for R provability}{manual\_grade\_for\_R\_provability}{\coqdocdefinition{manual\_grade\_for\_R\_provability}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard, optional (R\_fact)}




    关系 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 其实编码了一个熟悉的函数。请找出这个函数，定义它并在 Coq 中证明他们等价。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.IndProp.R.fR}{fR}{\coqdocdefinition{fR}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.R.R equiv fR}{R\_equiv\_fR}{\coqdoclemma{R\_equiv\_fR}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o}, \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} \coqdocvariable{m} \coqdocvariable{n} \coqdocvariable{o} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{LF.IndProp.R.fR}{\coqdocaxiom{fR}} \coqdocvariable{m} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{o}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.IndProp.R}{\coqdocmodule{R}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, advanced (subsequence)}




    如果一个列表的所有元素以相同的顺序出现在另一个列表之中（但允许其中出现其他额外的元素），
    我们把第一个列表称作第二个列表的\textit{'子序列'}。 例如：


      1;2;3


    是以下所有列表的子序列


      1;2;3
      1;1;1;2;2;3
      1;2;7;3
      5;6;1;9;9;2;7;3;8


    但\textit{'不是'}以下列表的子序列


      1;2
      1;3
      5;6;2;1;7;3;8.



\begin{itemize}
\item  在 \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 上定一个归纳命题 \coqref{LF.IndProp.subseq}{\coqdocinductive{subseq}}，其表达了子序列的涵义。
      （提示：你需要三个分类。）



\item  证明子序列的自反关系 \coqref{LF.IndProp.subseq refl}{\coqdoclemma{subseq\_refl}}，也即任何列表是它自身的子序列。



\item  证明关系 \coqref{LF.IndProp.subseq app}{\coqdoclemma{subseq\_app}} 对任意列表 \coqdocvariable{l1}，\coqdocvariable{l2} 和 \coqdocvariable{l3}，如果 \coqdocvariable{l1} 是 \coqdocvariable{l2}
      的子序列，那么 \coqdocvariable{l1} 也是 \coqdocvariable{l2} ++ \coqdocvariable{l3} 的子序列。



\item  （可选的，困难）证明子序列的传递关系 \coqref{LF.IndProp.subseq trans}{\coqdoclemma{subseq\_trans}}——也即，如果 \coqdocvariable{l1} 是 \coqdocvariable{l2}
      的子序列，且 \coqdocvariable{l2} 是 \coqdocvariable{l3} 的子序列，那么 \coqdocvariable{l1} 是 \coqdocvariable{l3} 的子序列。
      （提示：仔细选择进行归纳的项！） 
\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndProp.subseq}{subseq}{\coqdocinductive{subseq}} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocnoindent
\coqdoceol
\coqdocnoindent
.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.subseq refl}{subseq\_refl}{\coqdoclemma{subseq\_refl}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}), \coqref{LF.IndProp.subseq}{\coqdocinductive{subseq}} \coqdocvariable{l} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.subseq app}{subseq\_app}{\coqdoclemma{subseq\_app}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{l1} \coqdocvar{l2} \coqdocvar{l3} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.subseq}{\coqdocinductive{subseq}} \coqdocvariable{l1} \coqdocvariable{l2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.subseq}{\coqdocinductive{subseq}} \coqdocvariable{l1} (\coqdocvariable{l2} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{l3}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.subseq trans}{subseq\_trans}{\coqdoclemma{subseq\_trans}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{l1} \coqdocvar{l2} \coqdocvar{l3} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.subseq}{\coqdocinductive{subseq}} \coqdocvariable{l1} \coqdocvariable{l2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.subseq}{\coqdocinductive{subseq}} \coqdocvariable{l2} \coqdocvariable{l3} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.subseq}{\coqdocinductive{subseq}} \coqdocvariable{l1} \coqdocvariable{l3}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, optional (R\_provability2)}




    假设我们在 Coq 中有如下定义：


    Inductive R : nat -> list nat -> Prop :=
      | c1 : R 0 \ensuremath{\Box}
      | c2 n l (H: R n l) : R (S n) (n :: l)
      | c3 n l (H: R (S n) l) : R n l.


    下列命题哪个是可被证明的？



\begin{itemize}
\item  \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 2 [1;0]

\item  \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 1 [1;2;1;0]

\item  \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 6 [3;2;1;0]  
\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\section{案例学习：正则表达式}



 性质 \coqref{LF.IndProp.ev}{\coqdocinductive{ev}} 提供了一个简单的例子来展示归纳定义和其基础的推理技巧，
    但这还不是什么激动人心的东西——毕竟，\coqref{LF.Logic.even}{\coqdocdefinition{even}} 等价于我们之前见过的两个非归纳的定义，
    而看起来归纳定义并没有提供什么好处。为了更好地展示归纳定义的表达能力，
    我们继续使用它来建模计算机科学中的一个经典概念——正则表达式。 

 正则表达式是用来描述字符串集合的一种简单语言，定义如下： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndProp.reg exp}{reg\_exp}{\coqdocinductive{reg\_exp}} (\coqdocvar{T} : \coqdockw{Type}) : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.EmptySet}{EmptySet}{\coqdocconstructor{EmptySet}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.EmptyStr}{EmptyStr}{\coqdocconstructor{EmptyStr}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.Char}{Char}{\coqdocconstructor{Char}} (\coqdocvar{t} : \coqdocvariable{T})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.App}{App}{\coqdocconstructor{App}} (\coqdocvar{r1} \coqdocvar{r2} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.Union}{Union}{\coqdocconstructor{Union}} (\coqdocvar{r1} \coqdocvar{r2} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.Star}{Star}{\coqdocconstructor{Star}} (\coqdocvar{r} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Arguments} \coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}} \{\coqdocvar{T}\}.\coqdoceol
\coqdocnoindent
\coqdocvar{Arguments} \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}} \{\coqdocvar{T}\}.\coqdoceol
\coqdocnoindent
\coqdocvar{Arguments} \coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \{\coqdocvar{T}\} \coqdocvar{\_}.\coqdoceol
\coqdocnoindent
\coqdocvar{Arguments} \coqref{LF.IndProp.App}{\coqdocconstructor{App}} \{\coqdocvar{T}\} \coqdocvar{\_} \coqdocvar{\_}.\coqdoceol
\coqdocnoindent
\coqdocvar{Arguments} \coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} \{\coqdocvar{T}\} \coqdocvar{\_} \coqdocvar{\_}.\coqdoceol
\coqdocnoindent
\coqdocvar{Arguments} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \{\coqdocvar{T}\} \coqdocvar{\_}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
请注意这个定义是\textit{'多态的'}：\coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T} 中的正则表达式描述了字符串，
    而其中的字符取自 \coqdocvariable{T}——也即，\coqdocvariable{T} 的元素构成的列表。


    （同一般的实践略有不同，我们不要求类型 \coqdocvariable{T} 是有限的。由此可形成一些不同的正则表达式
    理论，但对于我们在本章的目的而言并无不同。） 

 我们通过以下规则来构建正则表达式和字符串，这些规则定义了正则表达式何时匹配一个字符串：



\begin{itemize}
\item  表达式 \coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}} 不匹配任何字符串。



\item  表达式 \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}} 匹配空字符串 [].



\item  表达式 \coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqdocvariable{x} 匹配单个字符构成的字符串 [\coqdocvariable{x}].



\item  如果 \coqdocvariable{re1} 匹配 \coqdocvariable{s1}, 且 \coqdocvariable{re2} 匹配 \coqdocvariable{s2}, 那么 \coqref{LF.IndProp.App}{\coqdocconstructor{App}} \coqdocvariable{re1} \coqdocvariable{re2} 匹配 \coqdocvariable{s1} ++ \coqdocvariable{s2}.



\item  如果 \coqdocvariable{re1} 和 \coqdocvariable{re2} 中至少一个匹配 \coqdocvariable{s}, 那么 \coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} \coqdocvariable{re1} \coqdocvariable{re2} 匹配 \coqdocvariable{s}.



\item  最后，如果我们写下某个字符串 \coqdocvariable{s} 作为一个字符串序列的连接
        \coqdocvariable{s} = \coqdocvar{s\_1} ++ ... ++ \coqdocvar{s\_k}，且表达式 \coqdocvariable{re} 匹配其中每一个字符串 \coqdocvar{s\_i}，那么
        \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re} 匹配 \coqdocvariable{s}。


        特别来说，此字符串序列可能为空，因此无论 \coqdocvariable{re} 是什么 \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}
        总是匹配空字符串 []。
\end{itemize}


 容易把非形式化的定义翻译为使用 \coqdockw{Inductive} 的定义。我们用记法
    \coqdocvariable{s} =\~{} \coqdocvariable{re} 表示，通过把该记法用 \coqdocvar{Reserved} “预留”在 \coqdockw{Inductive}
    定义之前，我们就能在定义中使用它！ \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Reserved Notation} "s =\~{} re" (\coqdoctac{at} \coqdockw{level} 80).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndProp.exp match}{exp\_match}{\coqdocinductive{exp\_match}} \{\coqdocvar{T}\} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvar{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvar{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.MEmpty}{MEmpty}{\coqdocconstructor{MEmpty}} : \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.MChar}{MChar}{\coqdocconstructor{MChar}} \coqdocvar{x} : \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{x}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{(}}\coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqdocvariable{x}\coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.MApp}{MApp}{\coqdocconstructor{MApp}} \coqdocvar{s1} \coqdocvar{re1} \coqdocvar{s2} \coqdocvar{re2}\coqdoceol
\coqdocindent{6.50em}
(\coqdocvar{H1} : \coqdocvariable{s1} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re1})\coqdoceol
\coqdocindent{6.50em}
(\coqdocvar{H2} : \coqdocvariable{s2} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re2})\coqdoceol
\coqdocindent{5.50em}
: \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{(}}\coqdocvariable{s1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s2}\coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{)}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{(}}\coqref{LF.IndProp.App}{\coqdocconstructor{App}} \coqdocvariable{re1} \coqdocvariable{re2}\coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.MUnionL}{MUnionL}{\coqdocconstructor{MUnionL}} \coqdocvar{s1} \coqdocvar{re1} \coqdocvar{re2}\coqdoceol
\coqdocindent{8.00em}
(\coqdocvar{H1} : \coqdocvariable{s1} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re1})\coqdoceol
\coqdocindent{7.00em}
: \coqdocvariable{s1} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{(}}\coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} \coqdocvariable{re1} \coqdocvariable{re2}\coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.MUnionR}{MUnionR}{\coqdocconstructor{MUnionR}} \coqdocvar{re1} \coqdocvar{s2} \coqdocvar{re2}\coqdoceol
\coqdocindent{8.00em}
(\coqdocvar{H2} : \coqdocvariable{s2} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re2})\coqdoceol
\coqdocindent{7.00em}
: \coqdocvariable{s2} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{(}}\coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} \coqdocvariable{re1} \coqdocvariable{re2}\coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.MStar0}{MStar0}{\coqdocconstructor{MStar0}} \coqdocvar{re} : \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{(}}\coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}\coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.IndProp.MStarApp}{MStarApp}{\coqdocconstructor{MStarApp}} \coqdocvar{s1} \coqdocvar{s2} \coqdocvar{re}\coqdoceol
\coqdocindent{8.50em}
(\coqdocvar{H1} : \coqdocvariable{s1} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re})\coqdoceol
\coqdocindent{8.50em}
(\coqdocvar{H2} : \coqdocvariable{s2} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{(}}\coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}\coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{)}})\coqdoceol
\coqdocindent{7.50em}
: \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{(}}\coqdocvariable{s1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s2}\coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{)}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{(}}\coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}\coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{where} \coqdef{LF.IndProp.:::x '=x7E' x}{"}{"}s =\~{} re" := (\coqref{LF.IndProp.exp match}{\coqdocinductive{exp\_match}} \coqdocvar{s} \coqdocvar{re}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.quiz}{quiz}{\coqdoclemma{quiz}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{s}:\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}), \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\~{}(}}\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{intros} \coqdocvar{T} \coqdocvar{s} \coqdocvar{Hc}. \coqdoctac{inversion} \coqdocvar{Hc}. \coqdockw{Qed}.\coqdoceol
\end{coqdoccode}
出于可读性的考虑，在此我们也展示使用推断规则表示的定义。

\par
\noindent\hrulefill\par
\noindent{}                    (MEmpty)
                           \ensuremath{\Box} =\~{} EmptyStr
\par
\noindent\hrulefill\par
\noindent{}                      (MChar)
                           \coqdocvariable{x} =\~{} Char x


                       s1 =\~{} re1    s2 =\~{} re2
\par
\noindent\hrulefill\par
\noindent{}                 (MApp)
                       s1 ++ s2 =\~{} App re1 re2


                              s1 =\~{} re1
\par
\noindent\hrulefill\par
\noindent{}                (MUnionL)
                         s1 =\~{} Union re1 re2


                              s2 =\~{} re2
\par
\noindent\hrulefill\par
\noindent{}                (MUnionR)
                         s2 =\~{} Union re1 re2
\par
\noindent\hrulefill\par
\noindent{}                     (MStar0)
                           \ensuremath{\Box} =\~{} Star re


                      s1 =\~{} re    s2 =\~{} Star re
\par
\noindent\hrulefill\par
\noindent{}            (MStarApp)
                        s1 ++ s2 =\~{} Star re


 请注意这些规则不\textit{'完全'}等同于之前给出的非形式化定义。
    首先，我们并不需要一个规则来直接表述无字符串匹配 \coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}}；
    我们做的仅仅是不囊括任何可能导致有字符串被 \coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}} 所匹配的规则。
    （的确，归纳定义的语法并不\textit{'允许'}我们表达类似的“否定规则”（negative rule））。


    其次，非形式化定义中的 \coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} 和 \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} 各自对应了两个构造子：
    \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}} / \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}，和 \coqref{LF.IndProp.MStar0}{\coqdocconstructor{MStar0}} / \coqref{LF.IndProp.MStarApp}{\coqdocconstructor{MStarApp}}。这在逻辑上等价于
    原始的定义，但在 Coq 中这样更加方便，因为递归出现的 \coqref{LF.IndProp.exp match}{\coqdocinductive{exp\_match}}
    是作为构造子的直接参数给定的，这在对证据进行归纳时更简单。
    （练习 \coqdocvar{exp\_match\_ex1} 和 \coqdocvar{exp\_match\_ex2} 会要求你证明归纳定义中的构造子
    和从非形式化规则的表述中提炼的规则确实是等价的。）


    接下来我们对一些例子使用这些规则： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.reg exp ex1}{reg\_exp\_ex1}{\coqdocdefinition{reg\_exp\_ex1}} : \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} 1.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.IndProp.MChar}{\coqdocconstructor{MChar}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.reg exp ex2}{reg\_exp\_ex2}{\coqdocdefinition{reg\_exp\_ex2}} : \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.App}{\coqdocconstructor{App}} (\coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} 1) (\coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} 2).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqdocvar{\_} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{LF.IndProp.MChar}{\coqdocconstructor{MChar}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{LF.IndProp.MChar}{\coqdocconstructor{MChar}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（请注意，后一个例子对字符串 [1] 和 [2] 直接应用了 \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}}。
    由于目标的形式是 [1; 2] 而非 [1] ++ [2]，Coq 并不知道如何分解这个字符串。）


    使用 \coqdoctac{inversion}，我们还可以证明某些字符串\textit{'不'}匹配一个正则表达式： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.reg exp ex3}{reg\_exp\_ex3}{\coqdocdefinition{reg\_exp\_ex3}} : \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} 1\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H}. \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们可以定义一些辅助函数来简化正则表达式的书写。函数 \coqref{LF.IndProp.reg exp of list}{\coqdocdefinition{reg\_exp\_of\_list}}
    接受一个列表做参数，并构造一个正则表达式来精确地匹配这个列表：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.IndProp.reg exp of list}{reg\_exp\_of\_list}{\coqdocdefinition{reg\_exp\_of\_list}} \{\coqdocvar{T}\} (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{x} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{l'} \ensuremath{\Rightarrow} \coqref{LF.IndProp.App}{\coqdocconstructor{App}} (\coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqdocvar{x}) (\coqref{LF.IndProp.reg exp of list}{\coqdocdefinition{reg\_exp\_of\_list}} \coqdocvar{l'})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.reg exp ex4}{reg\_exp\_ex4}{\coqdocdefinition{reg\_exp\_ex4}} : \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.reg exp of list}{\coqdocdefinition{reg\_exp\_of\_list}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{apply} (\coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}).\coqdoceol
\coqdocindent{1.00em}
\{ \coqdoctac{apply} \coqref{LF.IndProp.MChar}{\coqdocconstructor{MChar}}. \}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}).\coqdoceol
\coqdocindent{1.00em}
\{ \coqdoctac{apply} \coqref{LF.IndProp.MChar}{\coqdocconstructor{MChar}}. \}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}).\coqdoceol
\coqdocindent{1.00em}
\{ \coqdoctac{apply} \coqref{LF.IndProp.MChar}{\coqdocconstructor{MChar}}. \}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.IndProp.MEmpty}{\coqdocconstructor{MEmpty}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们还可以证明一些关于 \coqref{LF.IndProp.exp match}{\coqdocinductive{exp\_match}} 的性质。比如，下面的引理显示
    任意一个匹配 \coqdocvariable{re} 的字符串 \coqdocvariable{s} 也匹配 \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.MStar1}{MStar1}{\coqdoclemma{MStar1}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{T} \coqdocvar{s} (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) ,\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{T} \coqdocvar{s} \coqdocvar{re} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} (\coqref{LF.Poly.app nil r}{\coqdocaxiom{app\_nil\_r}} \coqdocvar{\_} \coqdocvar{s}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{LF.IndProp.MStarApp}{\coqdocconstructor{MStarApp}} \coqdocvar{s} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \coqdocvar{re}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{LF.IndProp.MStar0}{\coqdocconstructor{MStar0}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（请注意对 \coqref{LF.Lists.NatList.app nil r}{\coqdoclemma{app\_nil\_r}} 的使用改变了目标，以此可匹配 \coqref{LF.IndProp.MStarApp}{\coqdocconstructor{MStarApp}} 所需要的形式。）

\paragraph{练习：3 星, standard (exp\_match\_ex1)}




    下面的引理显示从形式化的归纳定义中可以得到本章开始的非形式化匹配规则。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.empty is empty}{empty\_is\_empty}{\coqdoclemma{empty\_is\_empty}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{s} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.MUnion'}{MUnion'}{\coqdoclemma{MUnion'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{s} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}) (\coqdocvar{re1} \coqdocvar{re2} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re1} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re2} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} \coqdocvariable{re1} \coqdocvariable{re2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
接下来的引理使用了 \coqdoclibrary{Poly} 一章中出现的 \coqdoctac{fold} 函数：
    如果 \coqdocvariable{ss} : \coqref{LF.Poly.list}{\coqdocinductive{list}} (\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}) 表示一个字符串序列 \coqdocvariable{s1}, ..., \coqdocvar{sn}，那么
    \coqdoctac{fold} \coqref{LF.Lists.NatList.app}{\coqdocdefinition{app}} \coqdocvariable{ss} [] 是将所有字符串连接的结果。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.MStar'}{MStar'}{\coqdoclemma{MStar'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{ss} : \coqref{LF.Poly.list}{\coqdocinductive{list}} (\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T})) (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{s}, \coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{s} \coqdocvariable{ss} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.fold}{\coqdocdefinition{fold}} \coqref{LF.Poly.app}{\coqdocdefinition{app}} \coqdocvariable{ss} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：4 星, standard, optional (reg\_exp\_of\_list\_spec)}




    请证明 \coqref{LF.IndProp.reg exp of list}{\coqdocdefinition{reg\_exp\_of\_list}} 满足以下规范： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.reg exp of list spec}{reg\_exp\_of\_list\_spec}{\coqdoclemma{reg\_exp\_of\_list\_spec}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{s1} \coqdocvar{s2} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s1} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.reg exp of list}{\coqdocdefinition{reg\_exp\_of\_list}} \coqdocvariable{s2} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{s1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{s2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 由于 \coqref{LF.IndProp.exp match}{\coqdocinductive{exp\_match}} 以递归方式定义，我们可能会发现
    关于正则表达式的证明常常需要对证据进行归纳。

 比如，假设我们想要证明以下显然的结果：如果正则表达式 \coqdocvariable{re} 匹配某个字符串 \coqdocvariable{s}，
    那么 \coqdocvariable{s} 中的所有元素必在 \coqdocvariable{re} 中某处以字符字面量的形式出现。


    为了表达这个定理，我们首先定义函数 \coqref{LF.IndProp.re chars}{\coqdocdefinition{re\_chars}} 来列举一个正则表达式中出现的
    所有字符：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.IndProp.re chars}{re\_chars}{\coqdocdefinition{re\_chars}} \{\coqdocvar{T}\} (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{re} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}} \ensuremath{\Rightarrow} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}} \ensuremath{\Rightarrow} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqdocvar{x} \ensuremath{\Rightarrow} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvar{x}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.App}{\coqdocconstructor{App}} \coqdocvar{re1} \coqdocvar{re2} \ensuremath{\Rightarrow} \coqref{LF.IndProp.re chars}{\coqdocdefinition{re\_chars}} \coqdocvar{re1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.IndProp.re chars}{\coqdocdefinition{re\_chars}} \coqdocvar{re2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} \coqdocvar{re1} \coqdocvar{re2} \ensuremath{\Rightarrow} \coqref{LF.IndProp.re chars}{\coqdocdefinition{re\_chars}} \coqdocvar{re1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.IndProp.re chars}{\coqdocdefinition{re\_chars}} \coqdocvar{re2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvar{re} \ensuremath{\Rightarrow} \coqref{LF.IndProp.re chars}{\coqdocdefinition{re\_chars}} \coqdocvariable{re}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
接下来我们这样陈述此定理： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.in re match}{in\_re\_match}{\coqdoclemma{in\_re\_match}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{s} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}) (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) (\coqdocvar{x} : \coqdocvariable{T}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{x} (\coqref{LF.IndProp.re chars}{\coqdocdefinition{re\_chars}} \coqdocvariable{re}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{T} \coqdocvar{s} \coqdocvar{re} \coqdocvar{x} \coqdocvar{Hmatch} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{Hmatch}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{as} [| \coqdocvar{x'}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{s1} \coqdocvar{re1} \coqdocvar{s2} \coqdocvar{re2} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{s1} \coqdocvar{re1} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH} \ensuremath{|} \coqdocvar{re1} \coqdocvar{s2} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{re} \ensuremath{|} \coqdocvar{s1} \coqdocvar{s2} \coqdocvar{re} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hin}. \coqdoctac{destruct} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Something interesting happens in the \coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}} case.  We obtain
    \textit{two} induction hypotheses: One that applies when \coqdocvariable{x} occurs in
    \coqdocvariable{s1} (which matches \coqdocvariable{re1}), and a second one that applies when \coqdocvariable{x}
    occurs in \coqdocvariable{s2} (which matches \coqdocvariable{re2}). \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{LF.Logic.In app iff}{\coqdocaxiom{In\_app\_iff}} \coqdoctac{in} *.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{Hin} \coqdockw{as} [\coqdocvar{Hin} \ensuremath{|} \coqdocvar{Hin}].\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{left}. \coqdoctac{apply} (\coqdocvar{IH1} \coqdocvar{Hin}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{right}. \coqdoctac{apply} (\coqdocvar{IH2} \coqdocvar{Hin}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{LF.Logic.In app iff}{\coqdocaxiom{In\_app\_iff}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{left}. \coqdoctac{apply} (\coqdocvar{IH} \coqdocvar{Hin}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \coqref{LF.Logic.In app iff}{\coqdocaxiom{In\_app\_iff}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{right}. \coqdoctac{apply} (\coqdocvar{IH} \coqdocvar{Hin}).\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们再次得到了两个归纳假设，它们表明了为什么我们需要对 \coqref{LF.IndProp.exp match}{\coqdocinductive{exp\_match}}
    的证据而非 \coqdocvariable{re} 进行归纳：对后者的归纳仅仅提供匹配 \coqdocvariable{re}
    的字符串的归纳假设，却无法允许我们对 \coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{s2} 分类进行推理。 \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{LF.Logic.In app iff}{\coqdocaxiom{In\_app\_iff}} \coqdoctac{in} \coqdocvar{Hin}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{Hin} \coqdockw{as} [\coqdocvar{Hin} \ensuremath{|} \coqdocvar{Hin}].\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} (\coqdocvar{IH1} \coqdocvar{Hin}).\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} (\coqdocvar{IH2} \coqdocvar{Hin}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：4 星, standard (re\_not\_empty)}




    请编写一个递归函数 \coqref{LF.IndProp.re not empty}{\coqdocdefinition{re\_not\_empty}} 用来测试某个正则表达式是否会匹配一些字符串。
    并证明你的函数是正确的。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.IndProp.re not empty}{re\_not\_empty}{\coqdocdefinition{re\_not\_empty}} \{\coqdocvar{T} : \coqdockw{Type}\} (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.re not empty correct}{re\_not\_empty\_correct}{\coqdoclemma{re\_not\_empty\_correct}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{s}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{LF.IndProp.re not empty}{\coqdocaxiom{re\_not\_empty}} \coqdocvariable{re} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{\texorpdfstring{\protect}{remember}\coqdocvar{remember} 策略}



 \coqdoctac{induction} 策略让人困惑的一个特点是它会接受任意一个项并尝试归纳，
    即使这个项不够一般（general）。其副作用是会丢失掉一些信息（类似没有 \coqdocvar{eqn}:
    从句的 \coqdoctac{destruct}），并且使你无法完成证明。比如： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.star app}{star\_app}{\coqdoclemma{star\_app}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{s1} \coqdocvar{s2} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}) (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s1} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s2} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s2} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{T} \coqdocvar{s1} \coqdocvar{s2} \coqdocvar{re} \coqdocvar{H1}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
仅仅对 \coqdocvar{H1} 反演并不会对处理含有递归的分类有太多帮助。（尝试一下！）
    因此我们需要对证据进行归纳！下面是一个朴素的尝试：\begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{s2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{H1}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{as} [|\coqdocvar{x'}\ensuremath{|}\coqdocvar{s1} \coqdocvar{re1} \coqdocvar{s2'} \coqdocvar{re2} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|}\coqdocvar{s1} \coqdocvar{re1} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH}\ensuremath{|}\coqdocvar{re1} \coqdocvar{s2'} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|}\coqdocvar{re'{}'}\ensuremath{|}\coqdocvar{s1} \coqdocvar{s2'} \coqdocvar{re'{}'} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2}].\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在，尽管我们得到了七个分类（正由我们从 \coqref{LF.IndProp.exp match}{\coqdocinductive{exp\_match}} 的定义中期待的那样），
    但 \coqdocvar{H1} 还是丢失了一个非常重要的信息：\coqdocvariable{s1} 事实上匹配了某种形式的 \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}。
    这意味着对于\textit{'全部'}的七个构造子分类我们都需要给出证明，尽管除了其中两个（\coqref{LF.IndProp.MStar0}{\coqdocconstructor{MStar0}}
    和 \coqref{LF.IndProp.MStarApp}{\coqdocconstructor{MStarApp}}）之外，剩下的五个构造子分类是和前提矛盾的。
    我们仍然可以在一些构造子上继续证明，比如 \coqref{LF.IndProp.MEmpty}{\coqdocconstructor{MEmpty}}…… \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{s2} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
……但有一些分类我们却卡住了。比如，对于 \coqref{LF.IndProp.MChar}{\coqdocconstructor{MChar}} 我们需要证明


    s2 =\~{} Char x' -> x' :: s2 =\~{} Char x',


    这显然是不可能完成的。 \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
-  \coqdoctac{intros} \coqdocvar{s2} \coqdocvar{H}. \coqdoctac{simpl}. \coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
问题是，只有当 \coqdockw{Prop} 的假设是完全一般的时候，对其使用 \coqdoctac{induction} 的才会起作用，
    也即，我们需要其所有的参数都是变量，而非更复杂的表达式，比如 \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}。


    （由此，对证据使用 \coqdoctac{induction} 的行为更像是没有 \coqdocvar{eqn}: 的 \coqdoctac{destruct}
    而非 \coqdoctac{inversion}。）


    解决此问题的一种直接的方式是“手动推广”这个有问题的表达式，
    即为此引理添加一个显式的等式： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.star app}{star\_app}{\coqdoclemma{star\_app}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{s1} \coqdocvar{s2} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}) (\coqdocvar{re} \coqdocvar{re'} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{re'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s1} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s2} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s2} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们现在可以直接对证据进行归纳，因为第一个假设的参数已经足够一般，
    这意味着我们可以通过反演当前上下文中的 \coqdocvariable{re'} = \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re} 来消解掉多数分类。


    这在 Coq 中是一种常用的技巧，因此 Coq 提供了策略来自动生成这种等式，
    并且我们也不必改写定理的陈述。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在 Coq 中调用 \coqdocvar{remember} \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} \coqdockw{as} \coqdocvariable{x} 策略会（1）替换所有表达式 \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} 为变量 \coqdocvariable{x}，
    （2）在当前上下文中添加一个等式 \coqdocvariable{x} = \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}}。我们可以这样使用 \coqdocvar{remember}
    来证明上面的结果： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.star app}{star\_app}{\coqdoclemma{star\_app}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{s1} \coqdocvar{s2} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}) (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s1} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s2} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s2} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{T} \coqdocvar{s1} \coqdocvar{s2} \coqdocvar{re} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{remember} (\coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvar{re}) \coqdockw{as} \coqdocvar{re'}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们现在有 \coqdocvar{Heqre'} : \coqdocvariable{re'} = \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}. \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{s2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{H1}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{as} [|\coqdocvar{x'}\ensuremath{|}\coqdocvar{s1} \coqdocvar{re1} \coqdocvar{s2'} \coqdocvar{re2} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|}\coqdocvar{s1} \coqdocvar{re1} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH}\ensuremath{|}\coqdocvar{re1} \coqdocvar{s2'} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|}\coqdocvar{re'{}'}\ensuremath{|}\coqdocvar{s1} \coqdocvar{s2'} \coqdocvar{re'{}'} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2}].\coqdoceol
\coqdocemptyline
\end{coqdoccode}
 \coqdocvar{Heqre'} 与多数分类相互矛盾，因此我们可以直接结束这些分类。\begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
-   \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
-    \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
-     \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{discriminate}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{discriminate}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
值得注意的分类是 \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}}。请注意 \coqref{LF.IndProp.MStarApp}{\coqdocconstructor{MStarApp}} 分类的归纳假设 \coqdocvar{IH2}
    包含到一个额外的前提 \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvar{re'{}'} = \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}，这是由 \coqdocvar{remember}
    所添加的等式所产生的。\begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{injection} \coqdocvar{Heqre'}. \coqdoctac{intros} \coqdocvar{Heqre'{}'} \coqdocvar{s} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{injection} \coqdocvar{Heqre'}. \coqdoctac{intros} \coqdocvar{H0}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{s2} \coqdocvar{H1}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{LF.Poly.app assoc}{\coqdocaxiom{app\_assoc}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{LF.IndProp.MStarApp}{\coqdocconstructor{MStarApp}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{Hmatch1}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{IH2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{rewrite} \coqdocvar{H0}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{H1}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：4 星, standard, optional (exp\_match\_ex2)}



 下面的引理 \coqref{LF.IndProp.MStar''}{\coqdoclemma{MStar'{}'}}（以及它的逆，之前的练习题中的 \coqref{LF.IndProp.MStar'}{\coqdoclemma{MStar'}}）显示
    \coqref{LF.IndProp.exp match}{\coqdocinductive{exp\_match}} 中 \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} 的定义等价于前面给出的非形式化定义。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.MStar''}{MStar'{}'}{\coqdoclemma{MStar'{}'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{s} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}) (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{ss} : \coqref{LF.Poly.list}{\coqdocinductive{list}} (\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T})\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.fold}{\coqdocdefinition{fold}} \coqref{LF.Poly.app}{\coqdocdefinition{app}} \coqdocvariable{ss} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdockw{\ensuremath{\forall}} \coqdocvar{s'}, \coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{s'} \coqdocvariable{ss} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s'} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：5 星, advanced (weak\_pumping)}




    正则表达式中一个非常有趣的定理叫做\textit{'泵引理（Pumping Lemma）'}，
    非形式化地来讲，它陈述了任意某个足够长的字符串 \coqdocvariable{s} 若匹配一个正则表达式 \coqdocvariable{re}，
    则可以被抽取（pumped）——将 \coqdocvariable{s} 的某个中间部分重复任意次产生的新字符串
    仍然匹配 \coqdocvariable{re}。
    （为了简单起见，我们考虑一个比自动机理论课上陈述的定理稍微弱一点的定理。）


    我们首先定义什么是“足够长”。由于 Coq 中使用的是构造性逻辑，我们事实上需要计算
    对于任何一个正则表达式 \coqdocvariable{re} 其最小的“可被抽取（pumpability）”长度。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.IndProp.Pumping}{Pumping}{\coqdocmodule{Pumping}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.IndProp.Pumping.pumping constant}{pumping\_constant}{\coqdocdefinition{pumping\_constant}} \{\coqdocvar{T}\} (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{re} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}} \ensuremath{\Rightarrow} 1\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}} \ensuremath{\Rightarrow} 1\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqdocvar{\_} \ensuremath{\Rightarrow} 2\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.App}{\coqdocconstructor{App}} \coqdocvar{re1} \coqdocvar{re2} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.IndProp.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvar{re1} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqref{LF.IndProp.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvar{re2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} \coqdocvar{re1} \coqdocvar{re2} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqref{LF.IndProp.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvar{re1} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqref{LF.IndProp.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvar{re2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvar{r} \ensuremath{\Rightarrow} \coqref{LF.IndProp.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvar{r}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在证明后面的泵引理时，你会发现关于抽取常量的引理十分有用。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.Pumping.pumping constant ge 1}{pumping\_constant\_ge\_1}{\coqdoclemma{pumping\_constant\_ge\_1}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.IndProp.Pumping.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvariable{re} \coqexternalref{::nat scope:x '>=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\ge}}} 1.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{T} \coqdocvar{re}. \coqdoctac{induction} \coqdocvar{re}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{le n}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocconstructor{le\_n}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{le n}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocconstructor{le\_n}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqexternalref{le S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocconstructor{le\_S}}. \coqdoctac{apply} \coqexternalref{le n}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocconstructor{le\_n}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{LF.IndProp.le trans}{\coqdocaxiom{le\_trans}} \coqdockw{with} (\coqdocvar{n}:=\coqref{LF.IndProp.Pumping.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvar{re1}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{IHre1}. \coqdoctac{apply} \coqref{LF.IndProp.le plus l}{\coqdocaxiom{le\_plus\_l}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{LF.IndProp.le trans}{\coqdocaxiom{le\_trans}} \coqdockw{with} (\coqdocvar{n}:=\coqref{LF.IndProp.Pumping.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvar{re1}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{IHre1}. \coqdoctac{apply} \coqref{LF.IndProp.le plus l}{\coqdocaxiom{le\_plus\_l}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{apply} \coqdocvar{IHre}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.Pumping.pumping constant 0 false}{pumping\_constant\_0\_false}{\coqdoclemma{pumping\_constant\_0\_false}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.IndProp.Pumping.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvariable{re} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{T} \coqdocvar{re} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{Hp1} : \coqref{LF.IndProp.Pumping.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvar{re} \coqexternalref{::nat scope:x '>=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\ge}}} 1).\coqdoceol
\coqdocindent{1.00em}
\{ \coqdoctac{apply} \coqref{LF.IndProp.Pumping.pumping constant ge 1}{\coqdoclemma{pumping\_constant\_ge\_1}}. \}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{inversion} \coqdocvar{Hp1} \coqdockw{as} [\coqdocvar{Hp1'}\ensuremath{|} \coqdocvar{p} \coqdocvar{Hp1'} \coqdocvar{Hp1'{}'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{Hp1'}. \coqdoctac{discriminate} \coqdocvar{Hp1'}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{rewrite} \coqdocvar{H} \coqdoctac{in} \coqdocvar{Hp1'{}'}. \coqdoctac{discriminate} \coqdocvar{Hp1'{}'}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
接下来，定义辅助函数 \coqref{LF.IndProp.Pumping.napp}{\coqdocdefinition{napp}} 来重复（连接到它自己）一个字符串特定次数。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.IndProp.Pumping.napp}{napp}{\coqdocdefinition{napp}} \{\coqdocvar{T}\} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}) : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{n} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} 0 \ensuremath{\Rightarrow} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqdocvariable{l} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.IndProp.napp}{\coqdocdefinition{napp}} \coqdocvar{n'} \coqdocvariable{l}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这个辅助引理在你证明泵引理时也非常有用。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.Pumping.napp plus}{napp\_plus}{\coqdoclemma{napp\_plus}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.Pumping.napp}{\coqdocdefinition{napp}} (\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}) \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.IndProp.Pumping.napp}{\coqdocdefinition{napp}} \coqdocvariable{n} \coqdocvariable{l} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.IndProp.Pumping.napp}{\coqdocdefinition{napp}} \coqdocvariable{m} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{T} \coqdocvar{n} \coqdocvar{m} \coqdocvar{l}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [|\coqdocvar{n} \coqdocvar{IHn}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{IHn}, \coqref{LF.Poly.app assoc}{\coqdocaxiom{app\_assoc}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.Pumping.napp star}{napp\_star}{\coqdoclemma{napp\_star}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{T} \coqdocvar{m} \coqdocvar{s1} \coqdocvar{s2} (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s1} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{s2} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.IndProp.Pumping.napp}{\coqdocdefinition{napp}} \coqdocvariable{m} \coqdocvariable{s1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s2} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{T} \coqdocvar{m} \coqdocvar{s1} \coqdocvar{s2} \coqdocvar{re} \coqdocvar{Hs1} \coqdocvar{Hs2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{apply} \coqdocvar{Hs2}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{LF.Poly.app assoc}{\coqdocaxiom{app\_assoc}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{LF.IndProp.MStarApp}{\coqdocconstructor{MStarApp}}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{Hs1}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqdocvar{IHm}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（弱化的）泵引理是说，如果 \coqdocvariable{s} =\~{} \coqdocvariable{re} 且 \coqdocvariable{s} 的长度最小是 \coqdocvariable{re} 的抽取常数（pumping constant），
    那么 \coqdocvariable{s} 可分割成三个子字符串 \coqdocvariable{s1} ++ \coqdocvariable{s2} ++ \coqdocvariable{s3}，其中 \coqdocvariable{s2} 可被重复任意次，
    其结果同 \coqdocvariable{s1} 和 \coqdocvariable{s3} 合并后仍然匹配 \coqdocvariable{re}。由于 \coqdocvariable{s2} 必须为非空字符串，
    这是一种（构造性的）方式来以我们想要的长度生成匹配 \coqdocvariable{re} 的字符串。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.Pumping.weak pumping}{weak\_pumping}{\coqdoclemma{weak\_pumping}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.Pumping.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvariable{re} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{s1} \coqdocvar{s2} \coqdocvar{s3}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{s1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s2} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s3} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s2} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqdocvariable{s1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.IndProp.Pumping.napp}{\coqdocdefinition{napp}} \coqdocvariable{m} \coqdocvariable{s2} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s3} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
You are to fill in the proof. Several of the lemmas about
    \coqref{LF.IndProp.Playground.le}{\coqdocinductive{le}} that were in an optional exercise earlier in this chapter
    may be useful. \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{T} \coqdocvar{re} \coqdocvar{s} \coqdocvar{Hmatch}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{Hmatch}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{as} [ \ensuremath{|} \coqdocvar{x} \ensuremath{|} \coqdocvar{s1} \coqdocvar{re1} \coqdocvar{s2} \coqdocvar{re2} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2}\coqdoceol
\coqdocindent{3.50em}
\ensuremath{|} \coqdocvar{s1} \coqdocvar{re1} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH} \ensuremath{|} \coqdocvar{re1} \coqdocvar{s2} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH}\coqdoceol
\coqdocindent{3.50em}
\ensuremath{|} \coqdocvar{re} \ensuremath{|} \coqdocvar{s1} \coqdocvar{s2} \coqdocvar{re} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2} ].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{contra}. \coqdoctac{inversion} \coqdocvar{contra}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：5 星, advanced, optional (pumping)}




    Now here is the usual version of the pumping lemma. In addition to
    requiring that \coqdocvariable{s2} \ensuremath{\not=} [], it also requires that \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} \coqdocvariable{s1} +
    \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} \coqdocvariable{s2} \ensuremath{\le} \coqref{LF.IndProp.Pumping.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvariable{re}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.Pumping.pumping}{pumping}{\coqdoclemma{pumping}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqdocvariable{T}) \coqdocvar{s},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.Pumping.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvariable{re} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{s} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{s1} \coqdocvar{s2} \coqdocvar{s3}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{s1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s2} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s3} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s2} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{s1} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{s2} \coqexternalref{::nat scope:x '<=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\le}}} \coqref{LF.IndProp.Pumping.pumping constant}{\coqdocdefinition{pumping\_constant}} \coqdocvariable{re} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqdocvariable{s1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.IndProp.Pumping.napp}{\coqdocdefinition{napp}} \coqdocvariable{m} \coqdocvariable{s2} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s3} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
You may want to copy your proof of weak\_pumping below. \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{T} \coqdocvar{re} \coqdocvar{s} \coqdocvar{Hmatch}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{Hmatch}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{as} [ \ensuremath{|} \coqdocvar{x} \ensuremath{|} \coqdocvar{s1} \coqdocvar{re1} \coqdocvar{s2} \coqdocvar{re2} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2}\coqdoceol
\coqdocindent{3.50em}
\ensuremath{|} \coqdocvar{s1} \coqdocvar{re1} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH} \ensuremath{|} \coqdocvar{re1} \coqdocvar{s2} \coqdocvar{re2} \coqdocvar{Hmatch} \coqdocvar{IH}\coqdoceol
\coqdocindent{3.50em}
\ensuremath{|} \coqdocvar{re} \ensuremath{|} \coqdocvar{s1} \coqdocvar{s2} \coqdocvar{re} \coqdocvar{Hmatch1} \coqdocvar{IH1} \coqdocvar{Hmatch2} \coqdocvar{IH2} ].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{contra}. \coqdoctac{inversion} \coqdocvar{contra}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.IndProp.Pumping}{\coqdocmodule{Pumping}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{案例学习：改进互映}



 在 \coqdoclibrary{Logic} 一章中，我们经常需要关联起对布尔值的计算和 \coqdockw{Prop}
    中的陈述，然而进行这样的关联往往会导致冗长的证明。请考虑以下定理的证明：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.filter not empty In}{filter\_not\_empty\_In}{\coqdoclemma{filter\_not\_empty\_In}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.filter}{\coqdocdefinition{filter}} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{x}) \coqdocvariable{l} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{n} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{l}. \coqdoctac{induction} \coqdocvar{l} \coqdockw{as} [|\coqdocvar{m} \coqdocvar{l'} \coqdocvar{IHl'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{destruct} (\coqdocvar{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvar{m}) \coqdocvar{eqn}:\coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{intros} \coqdocvar{\_}. \coqdoctac{rewrite} \coqref{LF.Logic.eqb eq}{\coqdoclemma{eqb\_eq}} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{left}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{intros} \coqdocvar{H'}. \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{IHl'}. \coqdoctac{apply} \coqdocvar{H'}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在 \coqdoctac{destruct} 后的第一个分支中，我们解构 \coqdocvariable{n} =? \coqdocvariable{m}
    后生成的等式显式地使用了 \coqref{LF.Logic.eqb eq}{\coqdoclemma{eqb\_eq}} 引理，以此将假设
    \coqdocvariable{n} =? \coqdocvariable{m} 转换为假设 \coqdocvariable{n} = \coqdocvariable{m}；接着使用 \coqdoctac{rewrite}
    策略和这个假设来完成此分支的证明。

 为了简化这样的证明，我们可定义一个归纳命题，用于对 \coqdocvariable{n} =? \coqdocvariable{m}
    产生更好的分类讨论原理。
    它不会生成类似 (\coqdocvariable{n} =? \coqdocvariable{m}) = \coqref{LF.Basics.true}{\coqdocconstructor{true}}这样的等式，因为一般来说对证明并不直接有用，
    其生成的分类讨论原理正是我们所需要的假设: \coqdocvariable{n} = \coqdocvariable{m}。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndProp.reflect}{reflect}{\coqdocinductive{reflect}} (\coqdocvar{P} : \coqdockw{Prop}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.IndProp.ReflectT}{ReflectT}{\coqdocconstructor{ReflectT}} (\coqdocvar{H} :   \coqdocvariable{P}) : \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} \coqdocvariable{P} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.IndProp.ReflectF}{ReflectF}{\coqdocconstructor{ReflectF}} (\coqdocvar{H} : \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqdocvariable{P}) : \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} \coqdocvariable{P} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
性质 \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} 接受两个参数：一个命题 \coqdocvariable{P} 和一个布尔值 \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}}。
    直观地讲，它陈述了性质 \coqdocvariable{P} 在布尔值 \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} 中所\textit{'映现'}（也即，等价）：
    换句话说，\coqdocvariable{P} 成立当且仅当 \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} = \coqref{LF.Basics.true}{\coqdocconstructor{true}}。为了理解这一点，请注意定义，
    我们能够产生 \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} \coqdocvariable{P} \coqref{LF.Basics.true}{\coqdocconstructor{true}} 的证据的唯一方式是证明 \coqdocvariable{P} 为真并使用
    \coqref{LF.IndProp.ReflectT}{\coqdocconstructor{ReflectT}} 构造子。如果我们反转这个陈述，意味着从 \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} \coqdocvariable{P} \coqref{LF.Basics.true}{\coqdocconstructor{true}}
    的证明中抽取出 \coqdocvariable{P} 的证据也是可能的。与此类似，证明 \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} \coqdocvariable{P} \coqref{LF.Basics.false}{\coqdocconstructor{false}}
    的唯一方式是合并 \ensuremath{\lnot} \coqdocvariable{P} 的证据和 \coqref{LF.IndProp.ReflectF}{\coqdocconstructor{ReflectF}} 构造子。


    形式化这种直觉并证明 \coqdocvariable{P} \ensuremath{\leftrightarrow} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} = \coqref{LF.Basics.true}{\coqdocconstructor{true}} 和 \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} \coqdocvariable{P} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}}
    这两个表述确实等价是十分容易的。首先是从左到右的蕴含：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.iff reflect}{iff\_reflect}{\coqdoclemma{iff\_reflect}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{b}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} \coqdocvariable{P} \coqdocvariable{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{b} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{b}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{LF.IndProp.ReflectT}{\coqdocconstructor{ReflectT}}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{LF.IndProp.ReflectF}{\coqdocconstructor{ReflectF}}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{intros} \coqdocvar{H'}. \coqdoctac{discriminate}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now you prove the right-to-left implication: 

\paragraph{练习：2 星, standard, recommended (reflect\_iff)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.reflect iff}{reflect\_iff}{\coqdoclemma{reflect\_iff}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{b}, \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} \coqdocvariable{P} \coqdocvariable{b} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 使用 \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} 而非“当且仅当”连词的好处是，通过解构一个形如
    \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} \coqdocvariable{P} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} 的假设或引理，我们可以对 \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}}
    进行分类讨论，同时为两个分支（第一个子目标中的 \coqdocvariable{P}
    和第二个中的 \ensuremath{\lnot} \coqdocvariable{P}）生成适当的假设。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.eqbP}{eqbP}{\coqdoclemma{eqbP}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m}, \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} (\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}) (\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}. \coqdoctac{apply} \coqref{LF.IndProp.iff reflect}{\coqdoclemma{iff\_reflect}}. \coqdoctac{rewrite} \coqref{LF.Logic.eqb eq}{\coqdoclemma{eqb\_eq}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqref{LF.IndProp.filter not empty In}{\coqdoclemma{filter\_not\_empty\_In}} 的一种更流畅证明如下所示。请注意对 \coqdoctac{destruct} 和 \coqdoctac{rewrite}
    的使用是如何合并成一个 \coqdoctac{destruct} 的使用。 

 （为了更清晰地看到这点，使用 Coq 查看 \coqref{LF.IndProp.filter not empty In}{\coqdoclemma{filter\_not\_empty\_In}}
    的两个证明，并观察在 \coqdoctac{destruct} 的第一个分类开始时证明状态的区别。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.filter not empty In'}{filter\_not\_empty\_In'}{\coqdoclemma{filter\_not\_empty\_In'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.filter}{\coqdocdefinition{filter}} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{x}) \coqdocvariable{l} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{n} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{l}. \coqdoctac{induction} \coqdocvar{l} \coqdockw{as} [|\coqdocvar{m} \coqdocvar{l'} \coqdocvar{IHl'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{destruct} (\coqref{LF.IndProp.eqbP}{\coqdoclemma{eqbP}} \coqdocvar{n} \coqdocvar{m}) \coqdockw{as} [\coqdocvar{H} \ensuremath{|} \coqdocvar{H}].\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{intros} \coqdocvar{\_}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{left}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{intros} \coqdocvar{H'}. \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{IHl'}. \coqdoctac{apply} \coqdocvar{H'}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：3 星, standard, recommended (eqbP\_practice)}




    使用上面的 \coqref{LF.IndProp.eqbP}{\coqdoclemma{eqbP}} 证明以下定理：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.IndProp.count}{count}{\coqdocdefinition{count}} \coqdocvar{n} \coqdocvar{l} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} 0\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{m} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{l'} \ensuremath{\Rightarrow} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdockw{if} \coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvar{m} \coqdockw{then} 1 \coqdockw{else} 0\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqref{LF.IndProp.count}{\coqdocdefinition{count}} \coqdocvariable{n} \coqdocvar{l'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.eqbP practice}{eqbP\_practice}{\coqdoclemma{eqbP\_practice}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{l},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.count}{\coqdocdefinition{count}} \coqdocvariable{n} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\~{}(}}\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{n} \coqdocvariable{l}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 这个小例子展示了互映证明可以怎样为我们提供一些便利。在大型的开发中，
    使用 \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} 往往更容易写出清晰和简短的证明脚本。我们将会在后面的章节
    和\textit{'编程语言基础'}一卷中看到更多的例子。


    对 \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} 性质的使用已被 \textit{'SSReflect'} 推广开来，这是一个
    Coq 程序库，用于形式化一些数学上的重要结果，包括四色定理和法伊特－汤普森定理。
    SSReflect 的名字代表着 \textit{'small-scale reflection'}，也即，普遍性地使用
    互映来简化与布尔值计算有关的证明。\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{额外练习}



\paragraph{练习：3 星, standard, recommended (nostutter\_defn)}




    写出性质的归纳定义是本课程中你需要的重要技能。请尝试去独立解决以下的练习。


    列表连续地重复某元素称为 ``百叶窗式'' (stutter)。
    （此概念不同于不包含重复元素：1;4;1 虽然包含重复元素 1，
    但因其未连续出现，故不是百叶窗式列表）。
    \coqref{LF.IndProp.nostutter}{\coqdocinductive{nostutter}} \coqref{LF.Lists.NatList.mylist}{\coqdocdefinition{mylist}} 表示 \coqref{LF.Lists.NatList.mylist}{\coqdocdefinition{mylist}} 不是百叶窗式列表。
    请写出 \coqref{LF.IndProp.nostutter}{\coqdocinductive{nostutter}} 的归纳定义。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndProp.nostutter}{nostutter}{\coqdocinductive{nostutter}} \{\coqdocvar{X}:\coqdockw{Type}\} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvar{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{0.50em}
\coqdoceol
\coqdocnoindent
.\coqdoceol
\end{coqdoccode}
请确保以下测试成功，但如果你觉得我们建议的证明（在注释中）并不有效，也可随意更改他们。
    若你的定义与我们的不同，也可能仍然是正确的，但在这种情况下可能需要不同的证明。
    （你会注意到建议的证明中使用了一些我们尚未讨论过的策略，这可以让证明适用于不同的 \coqref{LF.IndProp.nostutter}{\coqdocinductive{nostutter}}
    定义方式。你可以取消注释并直接使用他们，也可以用基础的策略证明这些例子。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.test nostutter 1}{test\_nostutter\_1}{\coqdocdefinition{test\_nostutter\_1}}: \coqref{LF.IndProp.nostutter}{\coqdocinductive{nostutter}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.test nostutter 2}{test\_nostutter\_2}{\coqdocdefinition{test\_nostutter\_2}}:  \coqref{LF.IndProp.nostutter}{\coqdocinductive{nostutter}} (@\coqref{LF.Poly.nil}{\coqdocconstructor{nil}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}).\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.test nostutter 3}{test\_nostutter\_3}{\coqdocdefinition{test\_nostutter\_3}}:  \coqref{LF.IndProp.nostutter}{\coqdocinductive{nostutter}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.test nostutter 4}{test\_nostutter\_4}{\coqdocdefinition{test\_nostutter\_4}}:      \coqexternalref{not}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}} (\coqref{LF.IndProp.nostutter}{\coqdocinductive{nostutter}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}).\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.IndProp.manual grade for nostutter}{manual\_grade\_for\_nostutter}{\coqdocdefinition{manual\_grade\_for\_nostutter}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：4 星, advanced (filter\_challenge)}




    让我们证明在 \coqdoclibrary{Poly} 一章中 \coqref{LF.Poly.filter}{\coqdocdefinition{filter}} 的定义匹配某个抽象的规范。
    可以这样非形式化地描述这个规范：


    列表 \coqdocvariable{l} 是一个 \coqdocvariable{l1} 和 \coqdocvariable{l2} 的“顺序合并”（in-order merge），如果它以
    \coqdocvariable{l1} 和 \coqdocvariable{l2} 中元素的顺序包含 \coqdocvariable{l1} 和 \coqdocvariable{l2} 中的所有元素，尽管可能是交替的。比如：


    1;4;6;2;3


    是


    1;6;2


    和


    4;3.


    的顺序合并。


    现在，假设我们有集合 \coqref{LF.Imp.X}{\coqdocdefinition{X}}，函数 \coqdocvariable{test}: \coqref{LF.Imp.X}{\coqdocdefinition{X}}\ensuremath{\rightarrow}\coqref{LF.Basics.bool}{\coqdocinductive{bool}} 和一个类型为 \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} 的列表
    \coqdocvariable{l}。接着接设如果 \coqdocvariable{l} 是 \coqdocvariable{l1} 和 \coqdocvariable{l2} 的顺序合并，且 \coqdocvariable{l1} 中的每个元素满足 \coqdocvariable{test}，
    而 \coqdocvariable{l2} 中没有元素满足 \coqdocvariable{test}，那么 \coqref{LF.Poly.filter}{\coqdocdefinition{filter}} \coqdocvariable{test} \coqdocvariable{l} = \coqdocvariable{l1}。


    请将这段规范翻译为 Coq 中的定理并证明它。（你首先需要定义合并两个列表的含义是什么。
    请使用归纳关系而非 \coqdockw{Fixpoint} 来完成。）\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.IndProp.manual grade for filter challenge}{manual\_grade\_for\_filter\_challenge}{\coqdocdefinition{manual\_grade\_for\_filter\_challenge}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：5 星, advanced, optional (filter\_challenge\_2)}




    另一种刻画 \coqref{LF.Poly.filter}{\coqdocdefinition{filter}} 行为的方式是：在 \coqdocvariable{l} 的所有其元素满足 \coqdocvariable{test} 的子序列中，
    \coqref{LF.Poly.filter}{\coqdocdefinition{filter}} \coqdocvariable{test} \coqdocvariable{l} 是最长的那个。请形式化这个命题并证明它。\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：4 星, standard, optional (palindromes)}




    回文是倒序排列与正序排列相同的序列。



\begin{itemize}
\item  在 \coqdocvar{listX} 上定义一个归纳命题 \coqdocvar{pal} 来表达回文的含义。
      （提示：你需要三个分类。定义应当基于列表的结构；仅仅使用一个构造子，例如


        c : forall l, l = rev l -> pal l


      看起来十分显而易见，但并不会很好的工作。)



\item  证明（\coqdocvar{pal\_app\_rev}）


       forall l, pal (l ++ rev l).



\item  证明（\coqdocvar{pal\_rev} that）


       forall l, pal l -> l = rev l.

\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.IndProp.manual grade for pal pal app rev pal rev}{manual\_grade\_for\_pal\_pal\_app\_rev\_pal\_rev}{\coqdocdefinition{manual\_grade\_for\_pal\_pal\_app\_rev\_pal\_rev}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：5 星, standard, optional (palindrome\_converse)}




    由于缺乏证据，反方向的证明要困难许多。使用之前练习中定义的 \coqdocvar{pal} 来证明


     forall l, l = rev l -> pal l.
\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：4 星, advanced, optional (NoDup)}




    请回忆一下 \coqdoclibrary{Logic} 章节中性质 \coqref{LF.Logic.In}{\coqdocdefinition{In}} 的定义，其断言值 \coqdocvariable{x} 在列表 \coqdocvariable{l} 中至少出现一次：\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
你的第一个任务是使用 \coqref{LF.Logic.In}{\coqdocdefinition{In}} 来定义命题 \coqdocvar{disjoint} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqdocvariable{l1} \coqdocvariable{l2}：仅当列表 \coqdocvariable{l1}
    和 \coqdocvariable{l2}（元素的类型为 \coqref{LF.Imp.X}{\coqdocdefinition{X}}）不含有相同的元素时其可被证明。\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
接下来，使用 \coqref{LF.Logic.In}{\coqdocdefinition{In}}　定义归纳命题 \coqdocvar{NoDup} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqdocvariable{l}，其可被证明仅当列表 \coqdocvariable{l}
    （元素类型为 \coqref{LF.Imp.X}{\coqdocdefinition{X}}）的每个元素都不相同。比如，\coqdocvar{NoDup} \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} [1;2;3;4]
    和 \coqdocvar{NoDup} \coqref{LF.Basics.bool}{\coqdocinductive{bool}} [] 是可被证明的，然而 \coqdocvar{NoDup} \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} [1;2;1]
    和 \coqdocvar{NoDup} \coqref{LF.Basics.bool}{\coqdocinductive{bool}} [\coqref{LF.Basics.true}{\coqdocconstructor{true}};\coqref{LF.Basics.true}{\coqdocconstructor{true}}] 是不行的。\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
最后，使用 \coqdocvar{disjoint}，\coqdocvar{NoDup} 和 ++（列表连接）陈述并证明一个或多个有趣的定理。 \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.IndProp.manual grade for NoDup disjoint etc}{manual\_grade\_for\_NoDup\_disjoint\_etc}{\coqdocdefinition{manual\_grade\_for\_NoDup\_disjoint\_etc}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：4 星, advanced, optional (pigeonhole\_principle)}




    \_鸽笼原理（Pigeonhole Principle）'是一个关于计数的基本事实：
    将超过 \coqdocvariable{n} 个物体放进 \coqdocvariable{n} 个鸽笼，则必有鸽笼包含至少两个物体。
    与此前诸多情形相似，这一数学事实看似乏味，但其证明手段并不平凡，
    如下所述： 

 首先容易证明一个有用的引理。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.in split}{in\_split}{\coqdoclemma{in\_split}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{x}:\coqdocvariable{X}) (\coqdocvar{l}:\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{l1} \coqdocvar{l2}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{l1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{x} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{l2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在请定一个性质 \coqref{LF.IndProp.repeats}{\coqdocinductive{repeats}}，使 \coqref{LF.IndProp.repeats}{\coqdocinductive{repeats}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqdocvariable{l} 断言 \coqdocvariable{l}
    包含至少一个（类型为 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 的）重复的元素。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.IndProp.repeats}{repeats}{\coqdocinductive{repeats}} \{\coqdocvar{X}:\coqdockw{Type}\} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvar{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoceol
\coqdocnoindent
.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在，我们这样来形式化鸽笼原理。假设列表 \coqdocvariable{l2} 表示鸽笼标签的列表，列表 \coqdocvariable{l1}
    表示标签被指定给一个列表里的元素。如果元素的个数多于标签的个数，那么至少有两个
    元素被指定了同一个标签——也即，列表 \coqdocvariable{l1} 含有重复元素。


    如果使用 \coqdocvar{excluded\_middule} 假设并展示 \coqref{LF.Logic.In}{\coqdocdefinition{In}} 是可判定的（decidable），
    即 \coqdockw{\ensuremath{\forall}} \coqdocvariable{x} \coqdocvariable{l}, (\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l}) \ensuremath{\lor} \ensuremath{\lnot} (\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l})，那么这个证明会容易很多。
    然而，若\textit{'不'}假设 \coqref{LF.Logic.In}{\coqdocdefinition{In}} 的可判定性也同样可以证明它；在这样的情况下便不必使用
    \coqref{LF.Logic.excluded middle}{\coqdocdefinition{excluded\_middle}} 假设。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.pigeonhole principle}{pigeonhole\_principle}{\coqdoclemma{pigeonhole\_principle}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{l1}  \coqdocvar{l2}:\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{1.50em}
\coqref{LF.Logic.excluded middle}{\coqdocdefinition{excluded\_middle}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.50em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l2}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.50em}
\coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{l2} \coqref{LF.IndProp.:::x '<' x}{\coqdocnotation{<}} \coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{l1} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.50em}
\coqref{LF.IndProp.repeats}{\coqdocinductive{repeats}} \coqdocvariable{l1}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{l1}. \coqdoctac{induction} \coqdocvar{l1} \coqdockw{as} [|\coqdocvar{x} \coqdocvar{l1'} \coqdocvar{IHl1'}].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\subsection{扩展练习：经验证的正则表达式匹配器}



 我们现在已经定义了正则表达式的匹配关系和多态列表。我们可以使用这些定义来手动地证明
    给定的正则表达式是否匹配某个字符串，但这并不是一个可以自动地判断是否匹配的程序。


    有理由期待，用于构造匹配关系证据的归纳规则可以被翻译为一个递归函数，
    其在正则表达式上的递归对应于这种关系。然而，定义这样的函数并没有那么直接，
    由于给定的正则表达式会被 Coq 识别为递归变量，作为结果，Coq 并不会接受这个函数，
    即使它总是停机。


    重度优化的匹配器会将正则表达式翻译为一个状态机，并决定状态机是否接受
    某个字符串。然而，正则表达式匹配也可以通过一个算法来实现，其仅仅操作字符串和
    正则表达式，无需定义和维护额外的数据类型，例如状态机。我们将会实现这样的算法，
    并验证其值与匹配关系是互映的。 

 我们将要实现的正则表达式匹配器会匹配由 ASCII 字符构成的列表：\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdoclibrary{Coq.Strings.Ascii}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.IndProp.string}{string}{\coqdocdefinition{string}} := \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Coq 标准库中包含了一个不同的 ASCII 字符串的归纳定义。然而，为了应用
    之前定义的匹配关系，我们在此使用刚刚给出的 ASCII 字符列表作为定义。


    我们也可以定义工作在多态列表上的正则表达式匹配器，而非特定于 ASCII 字符列表。
    我们将要实现的匹配算法需要知道如何对列表中的元素判断相等，因此需要给定一个
    相等关系测试函数。一般化我们给出的定义、定理和证明有一点枯燥，但是可行的。 

 正则表达式匹配器的正确性证明会由匹配函数的性质和 \coqdockw{match} 关系的性质组成，
    \coqdockw{match} 关系并不依赖匹配函数。我们将会首先证明后一类性质。他们中的多数
    将会是很直接的证明，已经被直接给出；少部分关键的引理会留给你来证明。 

 每个可被证明的 \coqdockw{Prop} 等价于 \coqref{LF.ProofObjects.Props.True}{\coqdocinductive{True}}。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.provable equiv true}{provable\_equiv\_true}{\coqdoclemma{provable\_equiv\_true}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{P} : \coqdockw{Prop}), \coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{True}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocinductive{True}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{constructor}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{\_}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
其逆可被证明的 \coqdockw{Prop} 等价于 \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}}。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.not equiv false}{not\_equiv\_false}{\coqdoclemma{not\_equiv\_false}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{P} : \coqdockw{Prop}), \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}}\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{destruct} \coqdocvar{H0}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}} 不匹配字符串。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.null matches none}{null\_matches\_none}{\coqdoclemma{null\_matches\_none}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{s} : \coqref{LF.IndProp.string}{\coqdocdefinition{string}}), \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.IndProp.not equiv false}{\coqdoclemma{not\_equiv\_false}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}}. \coqdoctac{intros}. \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}} 仅匹配空字符串。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.empty matches eps}{empty\_matches\_eps}{\coqdoclemma{empty\_matches\_eps}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{s} : \coqref{LF.IndProp.string}{\coqdocdefinition{string}}), \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{s} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{apply} \coqref{LF.IndProp.MEmpty}{\coqdocconstructor{MEmpty}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}} 不匹配非空字符串。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.empty nomatch ne}{empty\_nomatch\_ne}{\coqdoclemma{empty\_nomatch\_ne}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{a} : \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) \coqdocvar{s}, \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{a} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.IndProp.not equiv false}{\coqdoclemma{not\_equiv\_false}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}}. \coqdoctac{intros}. \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 不匹配不以 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 字符开始的字符串。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.char nomatch char}{char\_nomatch\_char}{\coqdoclemma{char\_nomatch\_char}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{a} \coqdocvar{b} : \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) \coqdocvar{s}, \coqdocvariable{b} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{a} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{b} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqdocvariable{a} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.IndProp.not equiv false}{\coqdoclemma{not\_equiv\_false}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{inversion} \coqdocvar{H0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
如果 \coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 匹配一个非空字符串，那么这个字符串的尾（tail）为空。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.char eps suffix}{char\_eps\_suffix}{\coqdoclemma{char\_eps\_suffix}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{a} : \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) \coqdocvar{s}, \coqdocvariable{a} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqdocvariable{a} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{s} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{apply} \coqref{LF.IndProp.MChar}{\coqdocconstructor{MChar}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqref{LF.IndProp.App}{\coqdocconstructor{App}} \coqdocvariable{re0} \coqdocvariable{re1} 匹配字符串 \coqdocvariable{s} 当且仅当 \coqdocvariable{s} = \coqdocvariable{s0} ++ \coqdocvariable{s1}，其中 \coqdocvariable{s0}
    匹配 \coqdocvariable{re0} 且 \coqdocvariable{s1} 匹配 \coqdocvariable{re1}。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.app exists}{app\_exists}{\coqdoclemma{app\_exists}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{s} : \coqref{LF.IndProp.string}{\coqdocdefinition{string}}) \coqdocvar{re0} \coqdocvar{re1},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.App}{\coqdocconstructor{App}} \coqdocvariable{re0} \coqdocvariable{re1} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{s0} \coqdocvar{s1}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{s} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{s0} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s1} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{s0} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re0} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{s1} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re1}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{\ensuremath{\exists}} \coqdocvar{s1}, \coqdocvar{s2}. \coqdoctac{split}.\coqdoceol
\coqdocindent{2.00em}
\ensuremath{\times} \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
\ensuremath{\times} \coqdoctac{split}. \coqdoctac{apply} \coqdocvar{H3}. \coqdoctac{apply} \coqdocvar{H4}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} [ \coqdocvar{s0} [ \coqdocvar{s1} [ \coqdocvar{Happ} [ \coqdocvar{Hmat0} \coqdocvar{Hmat1} ] ] ] ].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{Happ}. \coqdoctac{apply} (\coqref{LF.IndProp.MApp}{\coqdocconstructor{MApp}} \coqdocvar{s0} \coqdocvar{\_} \coqdocvar{s1} \coqdocvar{\_} \coqdocvar{Hmat0} \coqdocvar{Hmat1}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：3 星, standard, optional (app\_ne)}




    \coqref{LF.IndProp.App}{\coqdocconstructor{App}} \coqdocvariable{re0} \coqdocvariable{re1} 匹配 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}}::\coqdocvariable{s} 当且仅当 \coqdocvariable{re0} 匹配空字符串
    且 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}}::\coqdocvariable{s} 匹配 \coqdocvariable{re1} 或 \coqdocvariable{s}=\coqdocvariable{s0}++\coqdocvariable{s1}，其中 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}}::\coqdocvariable{s0} 匹配 \coqdocvariable{re0}
    且 \coqdocvariable{s1} 匹配 \coqdocvariable{re1}。


    尽管这个性质由纯粹的匹配关系构成，它是隐藏在匹配器的设计背后的一个重要观察。
    因此（1）花一些时间理解它，（2）证明它，并且（3）留心后面你会如何使用它。\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.app ne}{app\_ne}{\coqdoclemma{app\_ne}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{a} : \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) \coqdocvar{s} \coqdocvar{re0} \coqdocvar{re1},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{a} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{(}}\coqref{LF.IndProp.App}{\coqdocconstructor{App}} \coqdocvariable{re0} \coqdocvariable{re1}\coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{]}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re0} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{a} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re1}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{s0} \coqdocvar{s1}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{s} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{s0} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s1} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{a} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{s0} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re0} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{s1} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re1}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 \coqdocvariable{s} 匹配 \coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} \coqdocvariable{re0} \coqdocvariable{re1} 当且仅当 \coqdocvariable{s} 匹配 \coqdocvariable{re0} 或 \coqdocvariable{s} 匹配 \coqdocvariable{re1}. \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.union disj}{union\_disj}{\coqdoclemma{union\_disj}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{s} : \coqref{LF.IndProp.string}{\coqdocdefinition{string}}) \coqdocvar{re0} \coqdocvar{re1},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} \coqdocvariable{re0} \coqdocvariable{re1} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re0} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re1}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros}. \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{left}. \coqdoctac{apply} \coqdocvar{H2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} [ \coqdocvar{H} \ensuremath{|} \coqdocvar{H} ].\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{LF.IndProp.MUnionL}{\coqdocconstructor{MUnionL}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{apply} \coqref{LF.IndProp.MUnionR}{\coqdocconstructor{MUnionR}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：3 星, standard, optional (star\_ne)}




    \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}}::\coqdocvariable{s} 匹配 \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re} 当且仅当 \coqdocvariable{s} = \coqdocvariable{s0} ++ \coqdocvariable{s1}，其中 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}}::\coqdocvariable{s0} 匹配
    \coqdocvariable{re} 且 \coqdocvariable{s1} 匹配 \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}。 同 \coqref{LF.IndProp.app ne}{\coqdoclemma{app\_ne}}一样，这个观察很重要，
    因此理解，证明并留意它。


    提示：你需要进行归纳。的确是有几个合理的候选 \coqdockw{Prop} 来进行归纳。
    但唯一其作用的方式是首先拆分 \coqref{LF.Logic.MyIff.iff}{\coqdocdefinition{iff}} 为两个蕴含式，然后在 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} :: \coqdocvariable{s} =\~{} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}
    的证据上进行归纳来证明其中一个。另一个蕴含式可以无需使用归纳来证明。


    为了在正确的性质上归纳，你需要使用 \coqdocvar{remember} 策略来重新表述 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} :: \coqdocvariable{s} =\~{} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}，
    使其成为一般变量上的 \coqdockw{Prop}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.star ne}{star\_ne}{\coqdoclemma{star\_ne}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{a} : \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) \coqdocvar{s} \coqdocvar{re},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{a} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{s0} \coqdocvar{s1}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{s} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{s0} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{s1} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{a} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{s0} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{s1} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} \coqdocvariable{re}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 我们的正则表达式匹配器定义包括两个不动点函数。第一个函数对给定的正则表达式 \coqdocvariable{re}
    进行求值，结果映射了 \coqdocvariable{re} 是否匹配空字符串。这个函数满足以下性质： \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.IndProp.refl matches eps}{refl\_matches\_eps}{\coqdocdefinition{refl\_matches\_eps}} \coqdocvar{m} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}, \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} (\coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{]}} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re}) (\coqdocvariable{m} \coqdocvariable{re}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard, optional (match\_eps)}




    完成 \coqref{LF.IndProp.match eps}{\coqdocdefinition{match\_eps}} 的定义，其测试给定的正则表达式是否匹配空字符串： \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.IndProp.match eps}{match\_eps}{\coqdocdefinition{match\_eps}} (\coqdocvar{re}: \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard, optional (match\_eps\_refl)}




    现在，请证明 \coqref{LF.IndProp.match eps}{\coqdocdefinition{match\_eps}} 确实测试了给定的正则表达式是否匹配空字符串。
    （提示：你会使用到互映引理 \coqref{LF.IndProp.ReflectT}{\coqdocconstructor{ReflectT}} 和 \coqref{LF.IndProp.ReflectF}{\coqdocconstructor{ReflectF}}。） \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.match eps refl}{match\_eps\_refl}{\coqdoclemma{match\_eps\_refl}} : \coqref{LF.IndProp.refl matches eps}{\coqdocdefinition{refl\_matches\_eps}} \coqref{LF.IndProp.match eps}{\coqdocaxiom{match\_eps}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 我们将会定义其他函数也使用到 \coqref{LF.IndProp.match eps}{\coqdocdefinition{match\_eps}}。然而，这些函数的证明中你唯一会用到的
    \coqref{LF.IndProp.match eps}{\coqdocdefinition{match\_eps}} 的性质是 \coqref{LF.IndProp.match eps refl}{\coqdoclemma{match\_eps\_refl}}。

 我们匹配器所进行的关键操作是迭代地构造一个正则表达式生成式的序列。
    对于字符 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 和正则表达式 \coqdocvariable{re}，\coqdocvariable{re} 在 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 上的生成式是一个正则表达式，
    其匹配所有匹配 \coqdocvariable{re} 且以 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 开始的字符串的后缀。也即，\coqdocvariable{re'}
    是 \coqdocvariable{re} 在 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 上的一个生成式如果他们满足以下关系：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.IndProp.is der}{is\_der}{\coqdocdefinition{is\_der}} \coqdocvar{re} (\coqdocvar{a} : \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) \coqdocvar{re'} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{s}, \coqdocvariable{a} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re'}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
函数 \coqref{LF.Poly.MumbleGrumble.d}{\coqdocconstructor{d}} 生成字符串如果对于给定的字符 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 和正则表达式 \coqdocvariable{re}，
    它求值为 \coqdocvariable{re} 在 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 上的生成式。也即，\coqref{LF.Poly.MumbleGrumble.d}{\coqdocconstructor{d}} 满足以下关系： \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.IndProp.derives}{derives}{\coqdocdefinition{derives}} \coqdocvar{d} := \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{re}, \coqref{LF.IndProp.is der}{\coqdocdefinition{is\_der}} \coqdocvariable{re} \coqdocvariable{a} (\coqdocvariable{d} \coqdocvariable{a} \coqdocvariable{re}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：3 星, standard, optional (derive)}




    请定义 \coqref{LF.IndProp.derive}{\coqdocdefinition{derive}} 使其生成字符串。一个自然的实现是在某些分类使用
    \coqref{LF.IndProp.match eps}{\coqdocdefinition{match\_eps}} 来判断正则表达式是否匹配空字符串。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.IndProp.derive}{derive}{\coqdocdefinition{derive}} (\coqdocvar{a} : \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 \coqref{LF.IndProp.derive}{\coqdocdefinition{derive}} 函数应当通过以下测试。每个测试都在将被匹配器所求值的表达式和
    最终被匹配器返回的结果之间确立一种相等关系。
    每个测试也被添加了它所反映的匹配事实的注解。\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.c}{c}{\coqdocdefinition{c}} := \coqexternalref{ascii of nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocdefinition{ascii\_of\_nat}} 99.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.d}{d}{\coqdocdefinition{d}} := \coqexternalref{ascii of nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocdefinition{ascii\_of\_nat}} 100.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
``c'' =\~{} EmptySet: \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.test der0}{test\_der0}{\coqdocdefinition{test\_der0}} : \coqref{LF.IndProp.match eps}{\coqdocaxiom{match\_eps}} (\coqref{LF.IndProp.derive}{\coqdocaxiom{derive}} \coqref{LF.IndProp.c}{\coqdocdefinition{c}} (\coqref{LF.IndProp.EmptySet}{\coqdocconstructor{EmptySet}})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
``c'' =\~{} Char c: \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.test der1}{test\_der1}{\coqdocdefinition{test\_der1}} : \coqref{LF.IndProp.match eps}{\coqdocaxiom{match\_eps}} (\coqref{LF.IndProp.derive}{\coqdocaxiom{derive}} \coqref{LF.IndProp.c}{\coqdocdefinition{c}} (\coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqref{LF.IndProp.c}{\coqdocdefinition{c}})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
``c'' =\~{} Char d: \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.test der2}{test\_der2}{\coqdocdefinition{test\_der2}} : \coqref{LF.IndProp.match eps}{\coqdocaxiom{match\_eps}} (\coqref{LF.IndProp.derive}{\coqdocaxiom{derive}} \coqref{LF.IndProp.c}{\coqdocdefinition{c}} (\coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqref{LF.IndProp.d}{\coqdocdefinition{d}})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
``c'' =\~{} App (Char c) EmptyStr: \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.test der3}{test\_der3}{\coqdocdefinition{test\_der3}} : \coqref{LF.IndProp.match eps}{\coqdocaxiom{match\_eps}} (\coqref{LF.IndProp.derive}{\coqdocaxiom{derive}} \coqref{LF.IndProp.c}{\coqdocdefinition{c}} (\coqref{LF.IndProp.App}{\coqdocconstructor{App}} (\coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqref{LF.IndProp.c}{\coqdocdefinition{c}}) \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
``c'' =\~{} App EmptyStr (Char c): \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.test der4}{test\_der4}{\coqdocdefinition{test\_der4}} : \coqref{LF.IndProp.match eps}{\coqdocaxiom{match\_eps}} (\coqref{LF.IndProp.derive}{\coqdocaxiom{derive}} \coqref{LF.IndProp.c}{\coqdocdefinition{c}} (\coqref{LF.IndProp.App}{\coqdocconstructor{App}} \coqref{LF.IndProp.EmptyStr}{\coqdocconstructor{EmptyStr}} (\coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqref{LF.IndProp.c}{\coqdocdefinition{c}}))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
``c'' =\~{} Star c: \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.test der5}{test\_der5}{\coqdocdefinition{test\_der5}} : \coqref{LF.IndProp.match eps}{\coqdocaxiom{match\_eps}} (\coqref{LF.IndProp.derive}{\coqdocaxiom{derive}} \coqref{LF.IndProp.c}{\coqdocdefinition{c}} (\coqref{LF.IndProp.Star}{\coqdocconstructor{Star}} (\coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqref{LF.IndProp.c}{\coqdocdefinition{c}}))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
``cd'' =\~{} App (Char c) (Char d): \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.test der6}{test\_der6}{\coqdocdefinition{test\_der6}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.match eps}{\coqdocaxiom{match\_eps}} (\coqref{LF.IndProp.derive}{\coqdocaxiom{derive}} \coqref{LF.IndProp.d}{\coqdocdefinition{d}} (\coqref{LF.IndProp.derive}{\coqdocaxiom{derive}} \coqref{LF.IndProp.c}{\coqdocdefinition{c}} (\coqref{LF.IndProp.App}{\coqdocconstructor{App}} (\coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqref{LF.IndProp.c}{\coqdocdefinition{c}}) (\coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqref{LF.IndProp.d}{\coqdocdefinition{d}})))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
``cd'' =\~{} App (Char d) (Char c): \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.IndProp.test der7}{test\_der7}{\coqdocdefinition{test\_der7}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.IndProp.match eps}{\coqdocaxiom{match\_eps}} (\coqref{LF.IndProp.derive}{\coqdocaxiom{derive}} \coqref{LF.IndProp.d}{\coqdocdefinition{d}} (\coqref{LF.IndProp.derive}{\coqdocaxiom{derive}} \coqref{LF.IndProp.c}{\coqdocdefinition{c}} (\coqref{LF.IndProp.App}{\coqdocconstructor{App}} (\coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqref{LF.IndProp.d}{\coqdocdefinition{d}}) (\coqref{LF.IndProp.Char}{\coqdocconstructor{Char}} \coqref{LF.IndProp.c}{\coqdocdefinition{c}})))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：4 星, standard, optional (derive\_corr)}




    请证明 \coqref{LF.IndProp.derive}{\coqdocdefinition{derive}} 确实总是会生成字符串。


    提示：一种证明方法是对 \coqdocvariable{re} 归纳，尽管你需要通过归纳和一般化合适的项来
    仔细选择要证明的性质。


    提示：如果你定义的 \coqref{LF.IndProp.derive}{\coqdocdefinition{derive}} 对某个正则表达式 \coqdocvariable{re} 使用了 \coqref{LF.IndProp.match eps}{\coqdocdefinition{match\_eps}}，
    那么可对 \coqdocvariable{re} 应用 \coqref{LF.IndProp.match eps refl}{\coqdoclemma{match\_eps\_refl}}，接着对结果解构并生成
    分类，其中你可以假设 \coqdocvariable{re} 匹配或不匹配空字符串。


    提示：通过使用之前证明过的引理可以帮助一点你的工作。特别是，在证明归纳的
    许多分类时，通过之前的引理，你可以用一个复杂的正则表达式（比如，
    \coqdocvariable{s} =\~{} \coqref{LF.IndProp.Union}{\coqdocconstructor{Union}} \coqdocvariable{re0} \coqdocvariable{re1}）来重写命题，得到一个简单正则表达式上的命
    题构成的布尔表达式（比如，\coqdocvariable{s} =\~{} \coqdocvariable{re0} \ensuremath{\lor} \coqdocvariable{s} =\~{} \coqdocvariable{re1}）。
    你可以使用 \coqdoctac{intro} 和 \coqdoctac{destruct} 来对这些命题进行推理。\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.IndProp.derive corr}{derive\_corr}{\coqdoclemma{derive\_corr}} : \coqref{LF.IndProp.derives}{\coqdocdefinition{derives}} \coqref{LF.IndProp.derive}{\coqdocaxiom{derive}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 我们将会使用 \coqref{LF.IndProp.derive}{\coqdocdefinition{derive}} 来定义正则表达式匹配器。然而，在匹配器的性质的证明中你唯一会用到
    的 \coqref{LF.IndProp.derive}{\coqdocdefinition{derive}} 的性质是 \coqref{LF.IndProp.derive corr}{\coqdoclemma{derive\_corr}}。 

 函数 \coqdocvariable{m} 匹配正则表达式如果对给定的字符串 \coqdocvariable{s} 和正则表达式 \coqdocvariable{re}，
    它求值的结果映射了 \coqdocvariable{s} 是否被 \coqdocvariable{re} 匹配。也即，\coqdocvariable{m} 满足以下性质：\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.IndProp.matches regex}{matches\_regex}{\coqdocdefinition{matches\_regex}} \coqdocvar{m} : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{s} : \coqref{LF.IndProp.string}{\coqdocdefinition{string}}) \coqdocvar{re}, \coqref{LF.IndProp.reflect}{\coqdocinductive{reflect}} (\coqdocvariable{s} \coqref{LF.IndProp.:::x '=x7E' x}{\coqdocnotation{=\~{}}} \coqdocvariable{re}) (\coqdocvariable{m} \coqdocvariable{s} \coqdocvariable{re}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard, optional (regex\_match)}




    完成 \coqref{LF.IndProp.regex match}{\coqdocdefinition{regex\_match}} 的定义，使其可以匹配正则表达式。\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.IndProp.regex match}{regex\_match}{\coqdocdefinition{regex\_match}} (\coqdocvar{s} : \coqref{LF.IndProp.string}{\coqdocdefinition{string}}) (\coqdocvar{re} : \coqref{LF.IndProp.reg exp}{\coqdocinductive{reg\_exp}} \coqexternalref{ascii}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.Ascii}{\coqdocinductive{ascii}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard, optional (regex\_refl)}




    最后，证明 \coqref{LF.IndProp.regex match}{\coqdocdefinition{regex\_match}} 确实可以匹配正则表达式。


    提示：如果你定义的 \coqref{LF.IndProp.regex match}{\coqdocdefinition{regex\_match}} 对正则表达式 \coqdocvariable{re} 使用了 \coqref{LF.IndProp.match eps}{\coqdocdefinition{match\_eps}}，
    那么可对 \coqdocvariable{re} 应用 \coqref{LF.IndProp.match eps refl}{\coqdoclemma{match\_eps\_refl}}，接着对结果解构并生成
    分类，其中你可以假设 \coqdocvariable{re} 匹配或不匹配空字符串。


    提示：如果你定义的 \coqref{LF.IndProp.regex match}{\coqdocdefinition{regex\_match}} 对字符 \coqdocvariable{x} 和正则表达式 \coqdocvariable{re} 使用了 \coqref{LF.IndProp.derive}{\coqdocdefinition{derive}}，
    那么可对 \coqdocvariable{x} 和 \coqdocvariable{re} 应用 \coqref{LF.IndProp.derive corr}{\coqdoclemma{derive\_corr}}，以此证明 \coqdocvariable{x} :: \coqdocvariable{s} =\~{} \coqdocvariable{re} 当给定
    \coqdocvariable{s} =\~{} \coqref{LF.IndProp.derive}{\coqdocdefinition{derive}} \coqdocvariable{x} \coqdocvariable{re} 时，反之亦然。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.IndProp.regex refl}{regex\_refl}{\coqdoclemma{regex\_refl}} : \coqref{LF.IndProp.matches regex}{\coqdocdefinition{matches\_regex}} \coqref{LF.IndProp.regex match}{\coqdocaxiom{regex\_match}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.Logic}{Library }{LF.Logic}

\begin{coqdoccode}
\end{coqdoccode}
\section{Logic: Coq 中的逻辑系统}

\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Export} \coqref{LF.Tactics}{\coqdoclibrary{Tactics}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们已经见过很多对事实的断言（即\textit{'命题'}）
    以及如何用证据展示其正确性（即\textit{'证明'}）的例子了。特别是，
    我们证明了大量的\textit{'相等性命题'}（\coqdocvariable{e1} = \coqdocvariable{e2}）、蕴含式（\coqdocvariable{P} \ensuremath{\rightarrow} \coqdocvariable{Q}）和量化命题
    （\coqdockw{\ensuremath{\forall}} \coqdocvariable{x}, \coqdocvariable{P} \coqdocvariable{x}）。在本章中，我们将会看到如何用 Coq 解决类似形式的逻辑推理。


    在深入细节之前，我们先来探讨一下 Coq 中数学表达式的地位。
    回忆一下，Coq 是一门拥有\textit{'类型'}的语言，也就是说，一切有意义的
    表达式都具有一个相应的类型。逻辑表达也不例外，我们试图在 Coq
    中证明的一切语句都有名为 \coqdockw{Prop} 的类型，即\textit{'命题类型'}。我们
    可以用 \coqdockw{Check} 指令来查看： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} 3 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 3 : \coqdockw{Prop}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n} : \coqdockw{Prop}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
注意：\textit{'所有'}语法形式良好的命题，无论是否为真，其类型均为 \coqdockw{Prop}。 

 简单来说，\textit{'是'}一个命题与该命题\textit{'可以证明'}是两回事。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 2 : \coqdockw{Prop}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} 3 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 2 : \coqdockw{Prop}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 2 : \coqdockw{Prop}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
除了拥有类型之外，命题还是\textit{'一等的（First-Class）'}实体，
    即在 Coq 的世界中，我们可以像操作其它实体那样操作命题。 

 到目前为止，我们已经知道命题可以出现在 \coqdockw{Theorem}（还有 \coqdockw{Lemma} 以及
    \coqdockw{Example}）的声明中了。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.plus 2 2 is 4}{plus\_2\_2\_is\_4}{\coqdoclemma{plus\_2\_2\_is\_4}} :\coqdoceol
\coqdocindent{1.00em}
2 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 4.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
不过命题还可以用在其它地方。例如，我们可以用 \coqdockw{Definition}
    为命题取名，就像为其它表达式取名一样。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Logic.plus claim}{plus\_claim}{\coqdocdefinition{plus\_claim}} : \coqdockw{Prop} := 2 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 4.\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqref{LF.Logic.plus claim}{\coqdocdefinition{plus\_claim}} : \coqdockw{Prop}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
之后我们可以在任何需要此命题的地方使用它们名字——例如，作为一个
    \coqdockw{Theorem} 声明中的断言： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.plus claim is true}{plus\_claim\_is\_true}{\coqdoclemma{plus\_claim\_is\_true}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Logic.plus claim}{\coqdocdefinition{plus\_claim}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们也可以写出\textit{'参数化'}的命题 -- 也就是一个接受某些类型的参数，
    然后返回一个命题的函数。 

 例如，以下函数接受某个数字，返回一个命题断言该数字等于 3： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Logic.is three}{is\_three}{\coqdocdefinition{is\_three}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 3.\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqref{LF.Logic.is three}{\coqdocdefinition{is\_three}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在 Coq 中，返回命题的函数可以说是定义了其参数的\textit{'性质'}。 
    例如，以下（多态的）性质定义了常见的 \textit{'单射函数'} 的概念。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Logic.injective}{injective}{\coqdocdefinition{injective}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{f} : \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{B}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} : \coqdocvariable{A}, \coqdocvariable{f} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{f} \coqdocvariable{y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{y}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.succ inj}{succ\_inj}{\coqdoclemma{succ\_inj}} : \coqref{LF.Logic.injective}{\coqdocdefinition{injective}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{injection} \coqdocvar{H} \coqdockw{as} \coqdocvar{H1}. \coqdoctac{apply} \coqdocvar{H1}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
相等关系运算符 = 也是一个返回 \coqdockw{Prop} 的函数。


    表达式 \coqdocvariable{n} = \coqdocvariable{m} 只是 \coqref{LF.ProofObjects.MyEquality.eq}{\coqdocinductive{eq}} \coqdocvariable{n} \coqdocvariable{m} 的语法糖（它使用 \coqdockw{Notation}
    机制定义在 Coq 标准库中）。由于 \coqref{LF.ProofObjects.MyEquality.eq}{\coqdocinductive{eq}} 可被用于任何类型的元素，因此它也是多态的： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} @\coqexternalref{eq}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocinductive{eq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} : \coqdockw{Type}, \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（注意我们写的是 @\coqref{LF.ProofObjects.MyEquality.eq}{\coqdocinductive{eq}} 而非 \coqref{LF.ProofObjects.MyEquality.eq}{\coqdocinductive{eq}}：\coqref{LF.ProofObjects.MyEquality.eq}{\coqdocinductive{eq}} 的类型参数 \coqref{LF.Basics.A}{\coqdocconstructor{A}}
    是隐式声明的，因此我们需要关掉隐式参数的类型推断以便看到 \coqref{LF.ProofObjects.MyEquality.eq}{\coqdocinductive{eq}} 的完整类型。） \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{逻辑联结词}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{合取}



 命题 \coqref{LF.Basics.A}{\coqdocconstructor{A}} 与 \coqref{LF.Basics.B}{\coqdocconstructor{B}} 的\textit{'合取'}（即\textit{'逻辑与'}）写作 \coqref{LF.Basics.A}{\coqdocconstructor{A}} \ensuremath{\land} \coqref{LF.Basics.B}{\coqdocconstructor{B}}，表示一个
    \coqref{LF.Basics.A}{\coqdocconstructor{A}} 与 \coqref{LF.Basics.B}{\coqdocconstructor{B}} 均为真的断言。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Logic.and example}{and\_example}{\coqdocdefinition{and\_example}} : 3 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 4 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 7 \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} 2 \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 4.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
证明合取的命题通常使用 \coqdoctac{split} 策略。它会分别为语句的两部分生成两个子目标： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
对于任意命题 \coqref{LF.Basics.A}{\coqdocconstructor{A}} 和 \coqref{LF.Basics.B}{\coqdocconstructor{B}}，如果我们假设 \coqref{LF.Basics.A}{\coqdocconstructor{A}} 为真且 \coqref{LF.Basics.B}{\coqdocconstructor{B}} 为真，
    那么就能得出 \coqref{LF.Basics.A}{\coqdocconstructor{A}} \ensuremath{\land} \coqref{LF.Basics.B}{\coqdocconstructor{B}} 也为真的结论。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.and intro}{and\_intro}{\coqdoclemma{and\_intro}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{B} : \coqdockw{Prop}, \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{B} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{A} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{B}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{HA} \coqdocvar{HB}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{HA}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqdocvar{HB}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
由于按照前提对某个目标应用定理会产生与该定理的前提一样多的子目标。
    因此我们可以应用 \coqref{LF.Logic.and intro}{\coqdoclemma{and\_intro}} 来达到和 \coqdoctac{split} 一样的效果。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Logic.and example'}{and\_example'}{\coqdocdefinition{and\_example'}} : 3 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 4 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 7 \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} 2 \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 4.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.Logic.and intro}{\coqdoclemma{and\_intro}}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard (and\_exercise)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Logic.and exercise}{and\_exercise}{\coqdocdefinition{and\_exercise}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 以上就是证明合取语句的方法。要反过来使用，即\textit{'使用'}合取前提来帮助证明时，
    我们会采用 \coqdoctac{destruct} 策略。


    如果当前证明上下文中存在形如 \coqref{LF.Basics.A}{\coqdocconstructor{A}} \ensuremath{\land} \coqref{LF.Basics.B}{\coqdocconstructor{B}} 的前提 \coqdocvariable{H}，那么
    \coqdoctac{destruct} \coqdocvariable{H} \coqdockw{as} [\coqdocvar{HA} \coqdocvar{HB}] 将会从上下文中移除 \coqdocvariable{H} 并增加 \coqdocvar{HA} 和 \coqdocvar{HB}
    两个新的前提，前者断言 \coqref{LF.Basics.A}{\coqdocconstructor{A}} 为真，而后者断言 \coqref{LF.Basics.B}{\coqdocconstructor{B}} 为真。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.and example2}{and\_example2}{\coqdoclemma{and\_example2}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{Hn} \coqdocvar{Hm}] \coqdocvar{eqn}:\coqdocvar{HE}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{Hn}. \coqdoctac{rewrite} \coqdocvar{Hm}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
和往常一样，我们也可以在引入 \coqdocvariable{H} 的同时对其进行解构，
    而不必先引入然后再解构： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.and example2'}{and\_example2'}{\coqdoclemma{and\_example2'}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} [\coqdocvar{Hn} \coqdocvar{Hm}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{Hn}. \coqdoctac{rewrite} \coqdocvar{Hm}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
为什么我们要麻烦地将 \coqdocvariable{n} = 0 和 \coqdocvariable{m} = 0 这两个前提放一条合取语句中呢？
    完全可以用两条独立的前提来陈述此定理啊： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.and example2''}{and\_example2'{}'}{\coqdoclemma{and\_example2'{}'}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{Hn} \coqdocvar{Hm}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{Hn}. \coqdoctac{rewrite} \coqdocvar{Hm}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
就此定理而言，两种方式都可以。不过理解如何证明合取前提非常重要，
    因为合取语句通常会在证明的中间步骤中出现，特别是在做大型开发的时候。
    下面是个简单的例子： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.and example3}{and\_example3}{\coqdoclemma{and\_example3}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{H'} : \coqdocvar{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvar{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0).\coqdoceol
\coqdocindent{1.00em}
\{ \coqdoctac{apply} \coqref{LF.Logic.and exercise}{\coqdocaxiom{and\_exercise}}. \coqdoctac{apply} \coqdocvar{H}. \}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H'} \coqdockw{as} [\coqdocvar{Hn} \coqdocvar{Hm}] \coqdocvar{eqn}:\coqdocvar{HE}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{Hn}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
另一种经常遇到合取语句的场景是，我们已经知道了 \coqref{LF.Basics.A}{\coqdocconstructor{A}} \ensuremath{\land} \coqref{LF.Basics.B}{\coqdocconstructor{B}}，
    但在某些上下文中只需要 \coqref{LF.Basics.A}{\coqdocconstructor{A}} 或者 \coqref{LF.Basics.B}{\coqdocconstructor{B}}。此时我们可以用 \coqdoctac{destruct}
    进行解构（或许是作为 \coqdoctac{intros} 的一部分）并用下划线模式
    \coqdocvar{\_} 来丢弃不需要的合取分式。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.proj1}{proj1}{\coqdoclemma{proj1}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{P} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{HPQ}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{HPQ} \coqdockw{as} [\coqdocvar{HP} \coqdocvar{\_}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{HP}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, standard, optional (proj2)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.proj2}{proj2}{\coqdoclemma{proj2}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{P} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 最后，我们有时需要重新排列合取语句的顺序，或者对多部分的合取语句进行分组。
    此时使用下面的交换律和结合律会很方便。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.and commut}{and\_commut}{\coqdoclemma{and\_commut}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{P} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} [\coqdocvar{HP} \coqdocvar{HQ}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{2.00em}
-  \coqdoctac{apply} \coqdocvar{HQ}.\coqdoceol
\coqdocindent{2.00em}
-  \coqdoctac{apply} \coqdocvar{HP}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard (and\_assoc)}




    （在以下结合律的证明中，注意\textit{'嵌套'}的 \coqdoctac{intros} 模式是如何将
    \coqdocvariable{H} : \coqdocvariable{P} \ensuremath{\land} (\coqdocvariable{Q} \ensuremath{\land} \coqref{LF.IndProp.R.R}{\coqdocinductive{R}}) 拆分为 \coqdocvar{HP} : \coqdocvariable{P}、\coqdocvar{HQ} : \coqdocvariable{Q} 和 \coqdocvar{HR} : \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 的。
    请从那里开始完成证明。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.and assoc}{and\_assoc}{\coqdoclemma{and\_assoc}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{P} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Q} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{R}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{R}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} [\coqdocvar{HP} [\coqdocvar{HQ} \coqdocvar{HR}]].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 顺便一提，中缀记法 \ensuremath{\land} 只是 \coqref{LF.ProofObjects.Props.And.and}{\coqdocinductive{and}} \coqref{LF.Basics.A}{\coqdocconstructor{A}} \coqref{LF.Basics.B}{\coqdocconstructor{B}} 的语法糖而已；
    \coqref{LF.ProofObjects.Props.And.and}{\coqdocinductive{and}} 是 Coq 中将两个命题合并成一个命题的运算符。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqexternalref{and}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocinductive{and}} : \coqdockw{Prop} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{析取}



 另一个重要的联结词是\textit{'析取'}，即两个命题的\textit{'逻辑或'}：若 \coqref{LF.Basics.A}{\coqdocconstructor{A}} 或 \coqref{LF.Basics.B}{\coqdocconstructor{B}}
    二者之一为真，则 \coqref{LF.Basics.A}{\coqdocconstructor{A}} \ensuremath{\lor} \coqref{LF.Basics.B}{\coqdocconstructor{B}} 为真。（这种中缀记法表示 \coqref{LF.ProofObjects.Props.Or.or}{\coqdocinductive{or}} \coqref{LF.Basics.A}{\coqdocconstructor{A}} \coqref{LF.Basics.B}{\coqdocconstructor{B}}，其中
    \coqref{LF.ProofObjects.Props.Or.or}{\coqdocinductive{or}} : \coqdockw{Prop} \ensuremath{\rightarrow} \coqdockw{Prop} \ensuremath{\rightarrow} \coqdockw{Prop}。） 

 为了在证明中使用析取前提，我们需要分类讨论（它与 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}
    之类的数据类型一样，都可以显式地通过 \coqdoctac{destruct} 或隐式地通过 \coqdoctac{intros}
    模式来拆分： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.eq mult 0}{eq\_mult\_0}{\coqdoclemma{eq\_mult\_0}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} [\coqdocvar{Hn} \ensuremath{|} \coqdocvar{Hm}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{Hn}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{Hm}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{mult n O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdoclemma{mult\_n\_O}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
相应地，要证明某个析取命题成立，只需证明其任意一边的命题成立就够了。
    我们可以用 \coqdoctac{left} 和 \coqdoctac{right} 策略来选取命题。顾名思义，\coqdoctac{left}
    会选取待析取证命题的左边，而 \coqdoctac{right} 则会选取它的右边。
    下面是一种平凡的用法... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.or intro l}{or\_intro\_l}{\coqdoclemma{or\_intro\_l}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{B} : \coqdockw{Prop}, \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{A} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{B}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{HA}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{left}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{HA}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
...而这个更有趣的例子则同时需要 \coqdoctac{left} 和 \coqdoctac{right}： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.zero or succ}{zero\_or\_succ}{\coqdoclemma{zero\_or\_succ}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{pred}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{pred}} \coqdocvariable{n}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} [|\coqdocvar{n'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{left}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{right}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, standard (mult\_eq\_0)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.mult eq 0}{mult\_eq\_0}{\coqdoclemma{mult\_eq\_0}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m}, \coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：1 星, standard (or\_commut)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.or commut}{or\_commut}{\coqdoclemma{or\_commut}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{Q}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{假命题与否定}




    目前为止，我们主要都在证明某些东西是\textit{'真'}的：加法满足结合律，
    列表的连接满足结合律，等等。当然，我们也关心\textit{'否定'}的结果，
    即证明某些给定的命题\textit{'不是'}真的。在 Coq 中，这样的否定语句使用逻辑否定运算符
    \ensuremath{\lnot} 来表达。 

 为了理解否定背后的原理，我们需要回想一下\coqdoclibrary{Tactics}一章中的\textit{'爆炸原理'}。
    爆炸原理断言，当我们假设了矛盾存在时，就能推出任何命题。 
    遵循这一直觉，我们可以可以将 \ensuremath{\lnot} \coqdocvariable{P}（即非 \coqdocvariable{P}）定义为 \coqdockw{\ensuremath{\forall}} \coqdocvariable{Q}, \coqdocvariable{P} \ensuremath{\rightarrow} \coqdocvariable{Q}。


    不过 Coq 选择了稍有些不同（但等价）的做法，它将 \ensuremath{\lnot} \coqdocvariable{P} 定义为 \coqdocvariable{P} \ensuremath{\rightarrow} \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}}，而
    \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}} 是在标准库中特别定义的矛盾性命题。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Logic.MyNot}{MyNot}{\coqdocmodule{MyNot}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Logic.MyNot.not}{not}{\coqdocdefinition{not}} (\coqdocvar{P}:\coqdockw{Prop}) := \coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Logic.MyNot.::type scope:'x7E' x}{"}{"}\~{} x" := (\coqref{LF.Logic.MyNot.not}{\coqdocdefinition{not}} \coqdocvar{x}) : \coqdocvar{type\_scope}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.Logic.MyNot.not}{\coqdocdefinition{not}} : \coqdockw{Prop} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.Logic.MyNot}{\coqdocmodule{MyNot}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
由于 \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}} 是个矛盾性命题，因此爆炸原理对它也适用。如果我们让 \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}}
    进入到了证明的上下文中，可以对它使用 \coqdoctac{destruct} 来完成任何待证目标。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.ex falso quodlibet}{ex\_falso\_quodlibet}{\coqdoclemma{ex\_falso\_quodlibet}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{P}:\coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocinductive{False}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{contra}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{contra}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
拉丁文 \textit{'ex falso quodlibet'} 的字面意思是“从谬误出发，
    你能够证明任何你想要的”，这也是爆炸原理的另一个广为人知的名字。 

\paragraph{练习：2 星, standard, optional (not\_implies\_our\_not)}




    证明 Coq 对否定的定义蕴含前面提到的直觉上的定义： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fact} \coqdef{LF.Logic.not implies our not}{not\_implies\_our\_not}{\coqdoclemma{not\_implies\_our\_not}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{P}:\coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} (\coqdocvar{Q}:\coqdockw{Prop}), \coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 不等性是十分常见的否定句的例子，，它有一个特别的记法 \coqdocvariable{x} \ensuremath{\not=} \coqdocvariable{y}：


      Notation ``x <> y'' := (\~{}(x = y)).


 我们可以用 \coqref{LF.Logic.MyNot.not}{\coqdocdefinition{not}} 来陈述 0 和 1 是不同的 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 元素： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.zero not one}{zero\_not\_one}{\coqdoclemma{zero\_not\_one}} : 0 \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} 1.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\end{coqdoccode}
性质 0 \ensuremath{\not=} 1 就是 \~{}(0 = 1)，即 \coqref{LF.Logic.MyNot.not}{\coqdocdefinition{not}} (0 = 1)，
      它会展开为 (0 = 1) \ensuremath{\rightarrow} \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}}。（这里显式地用 \coqdoctac{unfold} \coqref{LF.Logic.MyNot.not}{\coqdocdefinition{not}}
      展示了这一点，不过一般可以忽略。 \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
要证明不等性，我们可以反过来假设其相等... \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{contra}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
... 然后从中推出矛盾。在这里，等式 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} 与构造子 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} 和 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}}
      的不交性相矛盾，因此用 \coqdoctac{discriminate} 就能解决它。 \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{discriminate} \coqdocvar{contra}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
为了习惯用 Coq 处理否定命题，我们需要一些练习。
    即便你十分清楚为什么某个否定命题成立，但能让 Coq 一下就理解则需要点小技巧。
    以下常见事实的证明留给你热身。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.not False}{not\_False}{\coqdoclemma{not\_False}} :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}}. \coqdoctac{intros} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.contradiction implies anything}{contradiction\_implies\_anything}{\coqdoclemma{contradiction\_implies\_anything}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}}\coqdocvariable{P}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} [\coqdocvar{HP} \coqdocvar{HNA}]. \coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}} \coqdoctac{in} \coqdocvar{HNA}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{HNA} \coqdoctac{in} \coqdocvar{HP}. \coqdoctac{destruct} \coqdocvar{HP}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.double neg}{double\_neg}{\coqdoclemma{double\_neg}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\~{}\~{}}}\coqdocvariable{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{H}. \coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}}. \coqdoctac{intros} \coqdocvar{G}. \coqdoctac{apply} \coqdocvar{G}. \coqdoctac{apply} \coqdocvar{H}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, advanced (double\_neg\_inf)}




    请写出 \coqref{LF.Logic.double neg}{\coqdoclemma{double\_neg}} 的非形式化证明：


   \textit{'定理'}：对于任何命题 \coqdocvariable{P} 而言，\coqdocvariable{P} 蕴含 \~{}\~{}\coqdocvariable{P}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Logic.manual grade for double neg inf}{manual\_grade\_for\_double\_neg\_inf}{\coqdocdefinition{manual\_grade\_for\_double\_neg\_inf}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, recommended (contrapositive)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.contrapositive}{contrapositive}{\coqdoclemma{contrapositive}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}}\coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}}\coqdocvariable{P}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：1 星, standard (not\_both\_true\_and\_false)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.not both true and false}{not\_both\_true\_and\_false}{\coqdoclemma{not\_both\_true\_and\_false}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}}\coqdocvariable{P}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：1 星, advanced (informal\_not\_PNP)}




    请写出 \coqdockw{\ensuremath{\forall}} \coqdocvariable{P} : \coqdockw{Prop}, \~{}(\coqdocvariable{P} \ensuremath{\land} \ensuremath{\lnot}\coqdocvariable{P}) 的非形式化证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Logic.manual grade for informal not PNP}{manual\_grade\_for\_informal\_not\_PNP}{\coqdocdefinition{manual\_grade\_for\_informal\_not\_PNP}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 由于不等性包含一个否定，因此在能够熟练地使用它前还需要一些练习。
    这里有个有用的技巧：如果你需要证明某个目标不可能时（例如当前的目标陈述为
    \coqref{LF.Basics.false}{\coqdocconstructor{false}} = \coqref{LF.Basics.true}{\coqdocconstructor{true}}），请使用 \coqref{LF.Logic.ex falso quodlibet}{\coqdoclemma{ex\_falso\_quodlibet}} 将该目标转换为 \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}}。
    如果在当前上下文中存在形如 \ensuremath{\lnot}\coqdocvariable{P} 的假设（特别是形如 \coqdocvariable{x}\ensuremath{\not=}\coqdocvariable{y} 的假设），
    那么此技巧会让这些假设用起来更容易些。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.not true is false}{not\_true\_is\_false}{\coqdoclemma{not\_true\_is\_false}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{b} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{b} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{b} \coqdocvar{eqn}:\coqdocvar{HE}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{LF.Logic.ex falso quodlibet}{\coqdoclemma{ex\_falso\_quodlibet}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
由于用 \coqref{LF.Logic.ex falso quodlibet}{\coqdoclemma{ex\_falso\_quodlibet}} 推理十分常用，因此 Coq 提供了内建的策略
    \coqdocvar{exfalso}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.not true is false'}{not\_true\_is\_false'}{\coqdoclemma{not\_true\_is\_false'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{b} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} [] \coqdocvar{H}. \coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{exfalso}. \coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{真值}



 除 \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}} 外，Coq 的标准库中还定义了 \coqref{LF.ProofObjects.Props.True}{\coqdocinductive{True}}，一个明显真的命题。
    为了证明它，我们使用了预定义的常量 \coqref{LF.ProofObjects.Props.I}{\coqdocconstructor{I}} : \coqref{LF.ProofObjects.Props.True}{\coqdocinductive{True}}： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.True is true}{True\_is\_true}{\coqdoclemma{True\_is\_true}} : \coqexternalref{True}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocinductive{True}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{apply} \coqexternalref{I}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocconstructor{I}}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
与经常使用的 \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}} 不同，\coqref{LF.ProofObjects.Props.True}{\coqdocinductive{True}} 很少使用，因为它作为证明目标来说过于平凡，
    而作为前提又不携带任何有用的信息。


    然而在使用条件从句定义复杂的 \coqdockw{Prop}，或者作为高阶 \coqdockw{Prop} 的参数时，
    它还是挺有用的。之后我们会看到一些例子。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{逻辑等价}



 联结词“当且仅当”用起来十分方便，它是两个蕴含式的合取，
    断言了两个命题拥有同样的真值。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Logic.MyIff}{MyIff}{\coqdocmodule{MyIff}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Logic.MyIff.iff}{iff}{\coqdocdefinition{iff}} (\coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop}) := \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Q} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Logic.MyIff.::type scope:x '<->' x}{"}{"}P <-> Q" := (\coqref{LF.Logic.MyIff.iff}{\coqdocdefinition{iff}} \coqdocvar{P} \coqdocvar{Q})\coqdoceol
\coqdocindent{11.00em}
(\coqdoctac{at} \coqdockw{level} 95, \coqdockw{no} \coqdockw{associativity})\coqdoceol
\coqdocindent{11.00em}
: \coqdocvar{type\_scope}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.Logic.MyIff}{\coqdocmodule{MyIff}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.iff sym}{iff\_sym}{\coqdoclemma{iff\_sym}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Q} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{P}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} [\coqdocvar{HAB} \coqdocvar{HBA}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{apply} \coqdocvar{HBA}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{apply} \coqdocvar{HAB}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.not true iff false}{not\_true\_iff\_false}{\coqdoclemma{not\_true\_iff\_false}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{b} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{b}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{apply} \coqref{LF.Logic.not true is false}{\coqdoclemma{not\_true\_is\_false}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{intros} \coqdocvar{H'}. \coqdoctac{discriminate} \coqdocvar{H'}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, standard, optional (iff\_properties)}




    参照上面对 \ensuremath{\leftrightarrow} 对称性（\coqref{LF.Logic.iff sym}{\coqdoclemma{iff\_sym}}）的证明，
    请证明它同时也有自反性和传递性。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.iff refl}{iff\_refl}{\coqdoclemma{iff\_refl}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{P} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.iff trans}{iff\_trans}{\coqdoclemma{iff\_trans}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Q} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{R}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{R}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard (or\_distributes\_over\_and)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.or distributes over and}{or\_distributes\_over\_and}{\coqdoclemma{or\_distributes\_over\_and}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Q} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{R}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{Q}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{R}\coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{广集与逻辑等价}



 Coq 的某些策略会特殊对待 \coqref{LF.Logic.MyIff.iff}{\coqdocdefinition{iff}} 语句，以此来避免操作某些底层的证明状态。
    特别来说，\coqdoctac{rewrite} 和 \coqdoctac{reflexivity} 不仅可以用于相等关系，还可用于
    \coqref{LF.Logic.MyIff.iff}{\coqdocdefinition{iff}} 语句。为了开启此行为，我们需要导入 Coq 库来支持它： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Import} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Setoids.Setoid}{\coqdoclibrary{Setoids.Setoid}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
“广集（Setoid）”指配备了等价关系的集合，即满足自反性、对称性和传递性的关系。
    当一个集合中的两个元素在这种关系上等价时，可以用 \coqdoctac{rewrite}
    将其中一个元素替换为另一个。我们已经在 Coq 中见过相等性关系 = 了：
    当 \coqdocvariable{x} = \coqdocvariable{y} 时，我们可以用 \coqdoctac{rewrite} 将 \coqdocvariable{x} 替换为 \coqdocvariable{y}，反之亦可。


    同样，逻辑等价关系 \ensuremath{\leftrightarrow} 也满足自反性、对称性和传递性，
    因此我们可以用它将替换命题中的一部分替换为另一部分：若
    \coqdocvariable{P} \ensuremath{\leftrightarrow} \coqdocvariable{Q}，那么我们可以用 \coqdoctac{rewrite} 将 \coqdocvariable{P} 替换为 \coqdocvariable{Q}，反之亦可。 

 下面是一个简单的例子，它展示了这些策略如何使用 \coqref{LF.Logic.MyIff.iff}{\coqdocdefinition{iff}}。
    首先，我们来证明一些基本的 \coqref{LF.Logic.MyIff.iff}{\coqdocdefinition{iff}} 等价关系命题... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.mult 0}{mult\_0}{\coqdoclemma{mult\_0}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m}, \coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{LF.Logic.mult eq 0}{\coqdocaxiom{mult\_eq\_0}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{LF.Logic.eq mult 0}{\coqdoclemma{eq\_mult\_0}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.or assoc}{or\_assoc}{\coqdoclemma{or\_assoc}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} : \coqdockw{Prop}, \coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{Q} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{R}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{Q}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{R}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} [\coqdocvar{H} \ensuremath{|} [\coqdocvar{H} \ensuremath{|} \coqdocvar{H}]].\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{left}. \coqdoctac{left}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{left}. \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} [[\coqdocvar{H} \ensuremath{|} \coqdocvar{H}] \ensuremath{|} \coqdocvar{H}].\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{left}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{right}. \coqdoctac{left}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{right}. \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在我们可以用这些事实配合 \coqdoctac{rewrite} 与 \coqdoctac{reflexivity}
    对涉及等价关系的陈述给出流畅的证明了。以下是之前 \coqref{LF.Logic.mult 0}{\coqdoclemma{mult\_0}}
    包含三个变量的版本： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.mult 0 3}{mult\_0\_3}{\coqdoclemma{mult\_0\_3}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p}, \coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{m} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{LF.Logic.mult 0}{\coqdoclemma{mult\_0}}. \coqdoctac{rewrite} \coqref{LF.Logic.mult 0}{\coqdoclemma{mult\_0}}. \coqdoctac{rewrite} \coqref{LF.Logic.or assoc}{\coqdoclemma{or\_assoc}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdoctac{apply} 策略也可以用在 \ensuremath{\leftrightarrow} 上。当给定一个等价关系命题作为
    \coqdoctac{apply} 的参数时，它会试图猜出正确的方向。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.apply iff example}{apply\_iff\_example}{\coqdoclemma{apply\_iff\_example}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0 \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{apply} \coqref{LF.Logic.mult 0}{\coqdoclemma{mult\_0}}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{存在量化}



 \textit{'存在量化'}也是十分重要的逻辑联结词。我们说存在某个类型为 \coqdocvariable{T}
    的 \coqdocvariable{x}，使得某些性质 \coqdocvariable{P} 对于 \coqdocvariable{x} 成立，写作 \coqdoctac{\ensuremath{\exists}} \coqdocvariable{x} : \coqdocvariable{T}, \coqdocvariable{P}。
    和 \coqdockw{\ensuremath{\forall}} 一样，如果 Coq 能从上下文中推断出 \coqdocvariable{x} 的类型，那么类型标注
    : \coqdocvariable{T} 就可以省略。

 为了证明形如 \coqdoctac{\ensuremath{\exists}} \coqdocvariable{x}, \coqdocvariable{P} 的语句，我们必须证明 \coqdocvariable{P} 对于某些特定的
    \coqdocvariable{x} 成立，这些特定的 \coqdocvariable{x} 被称作存在性的\textit{'例证'}。证明分为两步：
    首先，我们调用 \coqdoctac{\ensuremath{\exists}} \coqdocvariable{t} 策略向 Coq 指出已经知道了使 \coqdocvariable{P}
    成立的例证 \coqdocvariable{t}，然后证明将所有出现的 \coqdocvariable{x} 替换成 \coqdocvariable{t} 的命题 \coqdocvariable{P}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Logic.even}{even}{\coqdocdefinition{even}} \coqdocvar{x} := \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.four is even}{four\_is\_even}{\coqdoclemma{four\_is\_even}} : \coqref{LF.Logic.even}{\coqdocdefinition{even}} 4.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{LF.Logic.even}{\coqdocdefinition{even}}. \coqdoctac{\ensuremath{\exists}} 2. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
反之，如果我们的的上下文中有形如 \coqdoctac{\ensuremath{\exists}} \coqdocvariable{x}, \coqdocvariable{P} 的存在前提，
    可以将其解构得到一个例证 \coqdocvariable{x} 和一个陈述 \coqdocvariable{P} 对于 \coqdocvariable{x} 成立的前提。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.exists example 2}{exists\_example\_2}{\coqdoclemma{exists\_example\_2}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{m}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 4 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{o}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 2 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{o}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} [\coqdocvar{m} \coqdocvar{Hm}]. \coqdocindent{1.00em}
\coqdoctac{\ensuremath{\exists}} (2 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvar{m}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{Hm}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, standard, recommended (dist\_not\_exists)}




    请证明“\coqdocvariable{P} 对所有 \coqdocvariable{x} 成立”蕴含“不存在 \coqdocvariable{x} 使 \coqdocvariable{P} 不成立。”
    （提示：\coqdoctac{destruct} \coqdocvariable{H} \coqdockw{as} [\coqdocvariable{x} \coqdocvar{E}] 可以用于存在假设！） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.dist not exists}{dist\_not\_exists}{\coqdoclemma{dist\_not\_exists}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{P} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvariable{P} \coqdocvariable{x}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqdocvariable{P} \coqdocvariable{x}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard (dist\_exists\_or)}




    请证明存在量化对析取满足分配律。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.dist exists or}{dist\_exists\_or}{\coqdoclemma{dist\_exists\_or}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{P} \coqdocvar{Q} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{P} \coqdocvariable{x} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{Q} \coqdocvariable{x}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{P} \coqdocvariable{x}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{Q} \coqdocvariable{x}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{使用命题编程}



 我们学过的逻辑联结词为我们提供了丰富的用简单命题构造复杂命题的词汇。
    为了说明，我们来看一下如何表达“元素 \coqdocvariable{x} 出现在列表 \coqdocvariable{l} 中”这一断言。
    注意此性质有着简单的递归结构：



\begin{itemize}
\item  若 \coqdocvariable{l} 为空列表，则 \coqdocvariable{x} 无法在其中出现，因此性质“\coqdocvariable{x} 出现在 \coqdocvariable{l} 中”
         为假。



\item  否则，若 \coqdocvariable{l} 的形式为 \coqdocvariable{x'} :: \coqdocvariable{l'}，此时 \coqdocvariable{x} 是否出现在 \coqdocvariable{l} 中，
         取决于它是否等于 \coqdocvariable{x'} 或出现在 \coqdocvariable{l'} 中。 
\end{itemize}


 我们可以将此定义直接翻译成递归函数，它接受一个元素和一个列表，
    返回一个命题！： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Logic.In}{In}{\coqdocdefinition{In}} \{\coqdocvar{A} : \coqdockw{Type}\} (\coqdocvar{x} : \coqdocvariable{A}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{A}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqexternalref{False}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocinductive{False}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{x'} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{l'} \ensuremath{\Rightarrow} \coqdocvar{x'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{x} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvar{l'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
当 \coqref{LF.Logic.In}{\coqdocdefinition{In}} 应用于具体的列表时，它会被展开为一系列具体的析取式。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Logic.In example 1}{In\_example\_1}{\coqdocdefinition{In\_example\_1}} : \coqref{LF.Logic.In}{\coqdocdefinition{In}} 4 \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{right}. \coqdoctac{right}. \coqdoctac{right}. \coqdoctac{left}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Logic.In example 2}{In\_example\_2}{\coqdocdefinition{In\_example\_2}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{n} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{n'}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 2 \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{n'}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} [\coqdocvar{H} \ensuremath{|} [\coqdocvar{H} \ensuremath{|} []]].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{\ensuremath{\exists}} 1. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{\ensuremath{\exists}} 2. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\end{coqdoccode}
（注意我们用空模式\textit{'无视'}了最后一种情况。） 

 我们也可证明关于 \coqref{LF.Logic.In}{\coqdocdefinition{In}} 的更一般，更高阶的引理。


    注意，首先 \coqref{LF.Logic.In}{\coqdocdefinition{In}} 会被应用到一个变量上，只有当我们对它进行分类讨论时，
    它才会被展开： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.In map}{In\_map}{\coqdoclemma{In\_map}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{A} \coqdocvar{B} : \coqdockw{Type}) (\coqdocvar{f} : \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{B}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{A}) (\coqdocvar{x} : \coqdocvariable{A}),\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Logic.In}{\coqdocdefinition{In}} (\coqdocvariable{f} \coqdocvariable{x}) (\coqref{LF.Poly.map}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{f} \coqdocvar{l} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{l} \coqdockw{as} [|\coqdocvar{x'} \coqdocvar{l'} \coqdocvar{IHl'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{intros} [].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{intros} [\coqdocvar{H} \ensuremath{|} \coqdocvar{H}].\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{left}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{IHl'}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
虽然递归定义命题在某些情况下会很方便，但这种方式也有其劣势。特别是，
    这类命题会受到 Coq 对递归函数要求的限制，例如，在 Coq 中递归函数必须是
    “明显会终止”的。在下一章中，我们会了解如何\textit{'归纳地'}定义命题，
    这是一种与之不同的技巧，有着其独特的优势和限制。 

\paragraph{练习：3 星, standard (In\_map\_iff)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.In map iff}{In\_map\_iff}{\coqdoclemma{In\_map\_iff}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{A} \coqdocvar{B} : \coqdockw{Type}) (\coqdocvar{f} : \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{B}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{A}) (\coqdocvar{y} : \coqdocvariable{B}),\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{y} (\coqref{LF.Poly.map}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{l}) \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqdocvariable{f} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{y} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{f} \coqdocvar{l} \coqdocvar{y}. \coqdoctac{split}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard (In\_app\_iff)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.In app iff}{In\_app\_iff}{\coqdoclemma{In\_app\_iff}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{l} \coqdocvar{l'} (\coqdocvar{a}:\coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{a} (\coqdocvariable{l}\coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}}\coqdocvariable{l'}) \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{l} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{a} \coqdocvariable{l'}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{l}. \coqdoctac{induction} \coqdocvar{l} \coqdockw{as} [|\coqdocvar{a'} \coqdocvar{l'} \coqdocvar{IH}].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard, recommended (All)}




    回忆一下，返回命题的函数可以视作对其参数\textit{'性质'}的定义。例如，若
    \coqdocvariable{P} 的类型为 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} \ensuremath{\rightarrow} \coqdockw{Prop}，那么 \coqdocvariable{P} \coqdocvariable{n} 就陈述了性质 \coqdocvariable{P} 对 \coqdocvariable{n} 成立。


    以 \coqref{LF.Logic.In}{\coqdocdefinition{In}} 作为参考，请写出递归函数 \coqdockw{All}，它陈述某个 \coqdocvariable{P} 对列表 \coqdocvariable{l}
    中的所有元素成立。为了确定你的定义是正确的，请在下方证明 \coqref{LF.Logic.All In}{\coqdoclemma{All\_In}} 引理。
    （当然，你的定义\textit{'不应该'}为了通过测试就把 \coqref{LF.Logic.All In}{\coqdoclemma{All\_In}} 的左边复述一遍。 ） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Logic.All}{All}{\coqdocdefinition{All}} \{\coqdocvar{T} : \coqdockw{Type}\} (\coqdocvar{P} : \coqdocvariable{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}) : \coqdockw{Prop}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.All In}{All\_In}{\coqdoclemma{All\_In}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{T} (\coqdocvar{P} : \coqdocvariable{T} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{T}),\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P} \coqdocvariable{x}\coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Logic.All}{\coqdocaxiom{All}} \coqdocvariable{P} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard (combine\_odd\_even)}




    完成以下 \coqref{LF.Logic.combine odd even}{\coqdocdefinition{combine\_odd\_even}} 函数的定义。它接受两个对数字成立的性质
    \coqdocvariable{Podd} 与 \coqdocvariable{Peven}，返回性质 \coqdocvariable{P} 使得当 \coqdocvariable{n} 为奇数时 \coqdocvariable{P} \coqdocvariable{n} 等价于 \coqdocvariable{Podd} \coqdocvariable{n}，
    否则等价于 \coqdocvariable{Peven} \coqdocvariable{n}。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Logic.combine odd even}{combine\_odd\_even}{\coqdocdefinition{combine\_odd\_even}} (\coqdocvar{Podd} \coqdocvar{Peven} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
为了测试你的定义，请证明以下事实： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.combine odd even intro}{combine\_odd\_even\_intro}{\coqdoclemma{combine\_odd\_even\_intro}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{Podd} \coqdocvar{Peven} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Podd} \coqdocvariable{n}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Peven} \coqdocvariable{n}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Logic.combine odd even}{\coqdocaxiom{combine\_odd\_even}} \coqdocvariable{Podd} \coqdocvariable{Peven} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.combine odd even elim odd}{combine\_odd\_even\_elim\_odd}{\coqdoclemma{combine\_odd\_even\_elim\_odd}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{Podd} \coqdocvar{Peven} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Logic.combine odd even}{\coqdocaxiom{combine\_odd\_even}} \coqdocvariable{Podd} \coqdocvariable{Peven} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{Podd} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.combine odd even elim even}{combine\_odd\_even\_elim\_even}{\coqdoclemma{combine\_odd\_even\_elim\_even}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{Podd} \coqdocvar{Peven} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}) (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Logic.combine odd even}{\coqdocaxiom{combine\_odd\_even}} \coqdocvariable{Podd} \coqdocvariable{Peven} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{Peven} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{对参数应用定理}



 Coq 不同于其它证明助理（如 ACL2 和 Isabelle）的一个特性是，
    它将\textit{'证明'}本身也作为一等对象。


    关于这一点有很多地方值得着墨，不过了解所有的细节对于使用 Coq 来说不是必须的。
    本节点到为止，深入的探讨参见 \coqdoclibrary{ProofObjects} 和 \coqdoclibrary{IndPrinciples}。 

 我们已经知道 \coqdockw{Check} 命令可以用来显式表达式的类型了，
    不过它还可以用来查找某个标识符所指代的定理。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.Induction.plus comm}{\coqdocaxiom{plus\_comm}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在检查定理 \coqref{LF.Induction.plus comm}{\coqdoclemma{plus\_comm}} 的\textit{'陈述'}时，Coq 使用了与检查某项的\textit{'类型'}一样的方式
    （如果我们保留以冒号开始的部分，那么它会被打印出来）。这是为什么？ 

 原因在于标识符 \coqref{LF.Induction.plus comm}{\coqdoclemma{plus\_comm}} 其实指代的是被称作\textit{'证明对象'}的数据结构，
    它表示在命题 \coqdockw{\ensuremath{\forall}} \coqdocvariable{n} \coqdocvariable{m} : \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}, \coqdocvariable{n} + \coqdocvariable{m} = \coqdocvariable{m} + \coqdocvariable{n} 的真实性上建立的逻辑推导。
    此对象的类型\textit{'就是'}其所证命题的陈述。 

 从直觉上来说，这很有道理，因为对定理的陈述说明了该定理可用来做什么，
    正如可计算对象的类型告诉了我们可以对它做什么。例如，若我们有一个类型为
    \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} \ensuremath{\rightarrow} \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} \ensuremath{\rightarrow} \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 的项，就可以给它两个 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 作为参数并得到一个 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}。 
    类似地，如果我们有一个类型为 \coqdocvariable{n} = \coqdocvariable{m} \ensuremath{\rightarrow} \coqdocvariable{n} + \coqdocvariable{n} = \coqdocvariable{m} + \coqdocvariable{m} 的对象，
    就能为它提供一个类型为 \coqdocvariable{n} = \coqdocvariable{m} 的“参数”并推导出 \coqdocvariable{n} + \coqdocvariable{n} = \coqdocvariable{m} + \coqdocvariable{m}。 

 从操作上来说，这种类比可以更进一步：由于定理可以作为函数，
    被应用到对应类型的前提上，因此我们可以直接产生结论而不必在途中使用断言。
    例如，假设我们想要证明以下结论： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.plus comm3}{plus\_comm3}{\coqdoclemma{plus\_comm3}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}, \coqdocvariable{x} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{y} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{z}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{z} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{y}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{x}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
乍看起来，我们似乎可以用 \coqref{LF.Induction.plus comm}{\coqdoclemma{plus\_comm}} 改写两次使两边匹配来证明它。
    然而问题是，第二次 \coqdoctac{rewrite} 会抵消第一次的效果。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{LF.Induction.plus comm}{\coqdocaxiom{plus\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{LF.Induction.plus comm}{\coqdocaxiom{plus\_comm}}.\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们之前在 \coqdockw{Induction} 一章中见过类似的问题，绕过它的一种简单方法是使用
    \coqdoctac{assert} 导出 \coqref{LF.Induction.plus comm}{\coqdoclemma{plus\_comm}} 的特殊版本，这样我们就能用它按照预期来改写。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.plus comm3 take2}{plus\_comm3\_take2}{\coqdoclemma{plus\_comm3\_take2}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}, \coqdocvariable{x} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{y} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{z}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{z} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{y}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{LF.Induction.plus comm}{\coqdocaxiom{plus\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{H} : \coqdocvar{y} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvar{z} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{z} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvar{y}).\coqdoceol
\coqdocindent{1.00em}
\{ \coqdoctac{rewrite} \coqref{LF.Induction.plus comm}{\coqdocaxiom{plus\_comm}}. \coqdoctac{reflexivity}. \}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
一种更优雅的方式是直接把我们想要实例化的参数应用到 \coqref{LF.Induction.plus comm}{\coqdoclemma{plus\_comm}} 上，
    就像我们将一个多态函数应用到类型参数上那样。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.plus comm3 take3}{plus\_comm3\_take3}{\coqdoclemma{plus\_comm3\_take3}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}, \coqdocvariable{x} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{y} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{z}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{z} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{y}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{LF.Induction.plus comm}{\coqdocaxiom{plus\_comm}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqref{LF.Induction.plus comm}{\coqdocaxiom{plus\_comm}} \coqdocvar{y} \coqdocvar{z}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们来看看另一个像函数那样使用定理或引理的例子。 
    以下定理说明：任何包含元素的列表 \coqdocvariable{l} 一定非空。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.in not nil}{in\_not\_nil}{\coqdoclemma{in\_not\_nil}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{A} (\coqdocvar{x} : \coqdocvariable{A}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{A}), \coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{x} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{l} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{l} \coqdocvar{H}. \coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}}. \coqdoctac{intro} \coqdocvar{Hl}. \coqdoctac{destruct} \coqdocvar{l} \coqdocvar{eqn}:\coqdocvar{HE}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{discriminate} \coqdocvar{Hl}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
有趣的地方是一个量化的变量（\coqdocvariable{x}）没有出现在结论（\coqdocvariable{l} \ensuremath{\not=} []）中。 

 我们可以用此引理来证明 \coqdocvariable{x} 为 42 的特殊情况。直接用 \coqdoctac{apply} \coqref{LF.Logic.in not nil}{\coqdoclemma{in\_not\_nil}}
    会失败，因为它无法推出 \coqdocvariable{x} 的值。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.in not nil 42}{in\_not\_nil\_42}{\coqdoclemma{in\_not\_nil\_42}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqref{LF.Logic.In}{\coqdocdefinition{In}} 42 \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{l} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Fail} \coqdoctac{apply} \coqref{LF.Logic.in not nil}{\coqdoclemma{in\_not\_nil}}.\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
有一些方法可以绕开它： 

 Use \coqdoctac{apply} ... \coqdockw{with} ... \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.in not nil 42 take2}{in\_not\_nil\_42\_take2}{\coqdoclemma{in\_not\_nil\_42\_take2}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqref{LF.Logic.In}{\coqdocdefinition{In}} 42 \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{l} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.Logic.in not nil}{\coqdoclemma{in\_not\_nil}} \coqdockw{with} (\coqdocvar{x} := 42).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Use \coqdoctac{apply} ... \coqdoctac{in} ... \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.in not nil 42 take3}{in\_not\_nil\_42\_take3}{\coqdoclemma{in\_not\_nil\_42\_take3}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqref{LF.Logic.In}{\coqdocdefinition{In}} 42 \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{l} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.Logic.in not nil}{\coqdoclemma{in\_not\_nil}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
显式地对 \coqdocvariable{x} 的值应用引理。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.in not nil 42 take4}{in\_not\_nil\_42\_take4}{\coqdoclemma{in\_not\_nil\_42\_take4}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqref{LF.Logic.In}{\coqdocdefinition{In}} 42 \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{l} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{LF.Logic.in not nil}{\coqdoclemma{in\_not\_nil}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} 42).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
显式地对假设应用引理。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.in not nil 42 take5}{in\_not\_nil\_42\_take5}{\coqdoclemma{in\_not\_nil\_42\_take5}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqref{LF.Logic.In}{\coqdocdefinition{In}} 42 \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{l} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{LF.Logic.in not nil}{\coqdoclemma{in\_not\_nil}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{H}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
对于几乎所有将定理名作为参数的策略而言，你都可以“将定理作为函数”来使用。
    注意，定理应用与函数应用使用了同样的类型推导机制，所以你可以将通配符作为定理的参数，
    或者为定理声明默认的隐式前提。这些特性在以下证明中展示。（此证明如何工作的细节
    不必关心，这里的目标只是为了展示它的用途。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Logic.lemma application ex}{lemma\_application\_ex}{\coqdocdefinition{lemma\_application\_ex}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \{\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\} \{\coqdocvar{ns} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\},\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Logic.In}{\coqdocdefinition{In}} \coqdocvariable{n} (\coqref{LF.Poly.map}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{m} \ensuremath{\Rightarrow} \coqdocvariable{m} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} 0) \coqdocvariable{ns}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{ns} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqref{LF.Logic.proj1}{\coqdoclemma{proj1}} \coqdocvar{\_} \coqdocvar{\_} (\coqref{LF.Logic.In map iff}{\coqdocaxiom{In\_map\_iff}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_}) \coqdocvar{H})\coqdoceol
\coqdocindent{5.50em}
\coqdockw{as} [\coqdocvar{m} [\coqdocvar{Hm} \coqdocvar{\_}]].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{LF.Induction.mult 0 r}{\coqdocaxiom{mult\_0\_r}} \coqdoctac{in} \coqdocvar{Hm}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{Hm}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在以后的章节中我们将会看到更多这方面的例子。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Coq vs. 集合论}



 Coq 的逻辑核心，即\textit{'归纳构造演算（Calculus of Inductive Constructions）'}系统，
    在很多重要的方面不同于数学家用来写下精确而严谨的定义和证明的形式化系统。
    例如，在主流的纸笔数学家中使用最普遍的\textit{'策梅洛-弗兰克尔集合论（ZFC）'}中，
    一个数学对象可同时属于不同的集合；而在 Coq 的逻辑中，一个项最多只属于一个类型。
    这些不同之处需要人们用稍微不同的方式来描述非形式化的数学概念，但总的来说，
    它们都是非常自然而易于使用的。例如，在 Coq 中我们一般不说某个自然数 \coqdocvariable{n}
    属于偶数集合，而是说 \coqref{LF.Logic.even}{\coqdocdefinition{even}} \coqdocvariable{n} 成立，其中的 \coqref{LF.Logic.even}{\coqdocdefinition{even}} : \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} \ensuremath{\rightarrow} \coqdockw{Prop} 描述了偶数的性质。


    然而在某些情况下，将标准的数学论证翻译到 Coq 中会十分繁琐甚至是不可能的，
    除非我们引入新的公理来丰富其逻辑核心。作为本章的结尾，
    我们将探讨这两个世界之间最显著的区别。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{函数的外延性}



 目前为止我们所看见的相等关系断言基本上都只考虑了归纳类型的元素
    （如 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}、\coqref{LF.Basics.bool}{\coqdocinductive{bool}} 等等）。然而由于 Coq 的相等关系运算符是多态的，
    因此我们可以在\textit{'任何'}类型上使用它。特别是，我们可以写出断言\textit{'两个函数相等'}的命题： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Logic.function equality ex1}{function\_equality\_ex1}{\coqdocdefinition{function\_equality\_ex1}} :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} 3 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{x}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqexternalref{pred}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{pred}} 4\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{x}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在一般的数学研究中，对于任意两个函数 \coqdocvariable{f} 和 \coqdocvariable{g}，
    只要它们对相同的输入产生相等的结果，那么它们就被认为相等：


    (forall x, f x = g x) -> f = g


    这被称作\textit{'函数的外延性原理'}。 

 不甚严谨地说，所谓“外延性”是指某个对象可观察到的行为。
    因此，函数的外延性就是指函数的标识完全由其行为来决定。
    用 Coq 的术语来说，就是函数的身份视其被应用后的结果而定。 

 然而，函数的外延性并不在 Coq 的基本公理之内，因此某些“合理”的命题是不可证明的： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Logic.function equality ex2}{function\_equality\_ex2}{\coqdocdefinition{function\_equality\_ex2}} :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqexternalref{plus}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{plus}} \coqdocvariable{x} 1\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqexternalref{plus}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{plus}} 1 \coqdocvariable{x}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
不过我们可以用 \coqdockw{Axiom} 指令将函数的外延性添加到 Coq 的核心逻辑系统中。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{LF.Logic.functional extensionality}{functional\_extensionality}{\coqdocaxiom{functional\_extensionality}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{X} \coqdocvar{Y}: \coqdockw{Type}\}\coqdoceol
\coqdocindent{18.00em}
\{\coqdocvar{f} \coqdocvar{g} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y}\},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} (\coqdocvar{x}:\coqdocvariable{X}), \coqdocvariable{f} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{g} \coqdocvariable{x}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{f} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{g}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
将某个东西用 \coqdockw{Axiom} 定义为公理的效果与陈述一个定理并用 \coqdocvar{Admitted} 跳过其证明相同，
    不过它会提醒读者这是一个公理，我们无需证明！

 现在我们可以在证明中调用函数的外延性了： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Logic.function equality ex2}{function\_equality\_ex2}{\coqdocdefinition{function\_equality\_ex2}} :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqexternalref{plus}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{plus}} \coqdocvariable{x} 1\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqexternalref{plus}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{plus}} 1 \coqdocvariable{x}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.Logic.functional extensionality}{\coqdocaxiom{functional\_extensionality}}. \coqdoctac{intros} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.Induction.plus comm}{\coqdocaxiom{plus\_comm}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
当然，在为 Coq 添加公理时必须十分小心，因为这有可能会导致系统
    \textit{'不一致'}，而当系统不一致的，任何命题都能在其中证明，包括 \coqref{LF.ProofObjects.Props.False}{\coqdocinductive{False}}
    和 2+2=5！


    不幸的是，并没有一种简单的方式能够判断添加某条公理是否安全：
    一般来说，确认任何一组公理的一致性都需要训练有素的数学家付出艰辛的努力。


    然而，我们已经知道了添加函数外延性后的公理系统\textit{'确实是'}一致的。 

 我们可以用 \coqdockw{Print} \coqdockw{Assumptions} 指令查看某个证明依赖的所有附加公理。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqdockw{Assumptions} \coqref{LF.Logic.function equality ex2}{\coqdocdefinition{function\_equality\_ex2}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：4 星, standard (tr\_rev\_correct)}




    列表反转函数 \coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} 的定义有一个问题，它会在每一步都执行一次 \coqref{LF.Lists.NatList.app}{\coqdocdefinition{app}}
    调用，而运行 \coqref{LF.Lists.NatList.app}{\coqdocdefinition{app}} 所需时间与列表的大小线性渐近，也就是说 \coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}}
    的时间复杂度与列表长度呈渐进平方关系。我们可以用以下定义来改进它： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Logic.rev append}{rev\_append}{\coqdocdefinition{rev\_append}} \{\coqdocvar{X}\} (\coqdocvar{l1} \coqdocvar{l2} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l1} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqdocvariable{l2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{x} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{l1'} \ensuremath{\Rightarrow} \coqref{LF.Logic.rev append}{\coqdocdefinition{rev\_append}} \coqdocvar{l1'} (\coqdocvar{x} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{l2})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Logic.tr rev}{tr\_rev}{\coqdocdefinition{tr\_rev}} \{\coqdocvar{X}\} (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Logic.rev append}{\coqdocdefinition{rev\_append}} \coqdocvariable{l} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
此版本的 \coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} 是\textit{'尾递归（tail-recursive）'}的，
    因为对函数自身的递归调用是需要执行的最后一步操作
    （即，在递归调用之后我们并不执行  ++ ）。
    一个足够好的编译器会为此生成十分高效的代码。


    请证明以下两个定义等价。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.tr rev correct}{tr\_rev\_correct}{\coqdoclemma{tr\_rev\_correct}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X}, @\coqref{LF.Logic.tr rev}{\coqdocdefinition{tr\_rev}} \coqdocvariable{X} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} @\coqref{LF.Poly.rev}{\coqdocdefinition{rev}} \coqdocvariable{X}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{命题 vs. 布尔值}



 我们已经知道在 Coq 中有两种编码逻辑事实的方式了，即使用\textit{'布尔值'}
    （类型为 \coqref{LF.Basics.bool}{\coqdocinductive{bool}}）和\textit{'命题'}（类型为 \coqdockw{Prop}）。


    例如，我们可以通过以下两种方式来断言 \coqdocvariable{n} 为偶数： 

 \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvariable{n} 求值为 \coqref{LF.Basics.true}{\coqdocconstructor{true}}： \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Logic.even 42 bool}{even\_42\_bool}{\coqdocdefinition{even\_42\_bool}} : \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} 42 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
或者存在某个 \coqdocvariable{k} 使得 \coqdocvariable{n} = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{k}： \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Logic.even 42 prop}{even\_42\_prop}{\coqdocdefinition{even\_42\_prop}} : \coqref{LF.Logic.even}{\coqdocdefinition{even}} 42.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{unfold} \coqref{LF.Logic.even}{\coqdocdefinition{even}}. \coqdoctac{\ensuremath{\exists}} 21. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
当然，如果二者刻画的偶数性描述的不是同一个自然数集合，那么会非常奇怪！
    幸运的是，我们确实可以证明二者相同... 

 首先我们需要两个辅助引理。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.evenb double}{evenb\_double}{\coqdoclemma{evenb\_double}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{k}, \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} (\coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{k}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{k}. \coqdoctac{induction} \coqdocvar{k} \coqdockw{as} [|\coqdocvar{k'} \coqdocvar{IHk'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{apply} \coqdocvar{IHk'}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：3 星, standard (evenb\_double\_conv)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.evenb double conv}{evenb\_double\_conv}{\coqdoclemma{evenb\_double\_conv}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{k}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdockw{if} \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvariable{n} \coqdockw{then} \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{k} \coqdockw{else} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{k}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 Now the main theorem: \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.even bool prop}{even\_bool\_prop}{\coqdoclemma{even\_bool\_prop}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{LF.Logic.even}{\coqdocdefinition{even}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{H}. \coqdoctac{destruct} (\coqref{LF.Logic.evenb double conv}{\coqdocaxiom{evenb\_double\_conv}} \coqdocvar{n}) \coqdockw{as} [\coqdocvar{k} \coqdocvar{Hk}].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{Hk}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{\ensuremath{\exists}} \coqdocvar{k}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} [\coqdocvar{k} \coqdocvar{Hk}]. \coqdoctac{rewrite} \coqdocvar{Hk}. \coqdoctac{apply} \coqref{LF.Logic.evenb double}{\coqdoclemma{evenb\_double}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
此定理说明，布尔计算 \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvariable{n} 的真假会从命题 \coqdoctac{\ensuremath{\exists}} \coqdocvariable{k}, \coqdocvariable{n} = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{k}
    的真假中\textit{'反映（reflected）'}出来。 

 类似地，以下两种 \coqdocvariable{n} 与 \coqdocvariable{m} 相等的表述等价：

\begin{itemize}
\item  (1) \coqdocvariable{n} =? \coqdocvariable{m} 值为 \coqref{LF.Basics.true}{\coqdocconstructor{true}}；

\item  (2) \coqdocvariable{n} = \coqdocvariable{m}。

\end{itemize}
    同样，二者的记法也等价。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.eqb eq}{eqb\_eq}{\coqdoclemma{eqb\_eq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n1} \coqdocvar{n2} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n1} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{n2} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{n1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n1} \coqdocvar{n2}. \coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{apply} \coqref{LF.Tactics.eqb true}{\coqdocaxiom{eqb\_true}}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{intros} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{LF.Induction.eqb refl}{\coqdocaxiom{eqb\_refl}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
然而，即便布尔值和命题式在逻辑上是等价的，
    但它们的方便性从某些特定的目上来看并不一样。 

 在前面的偶数例子中，证明 \coqref{LF.Logic.even bool prop}{\coqdoclemma{even\_bool\_prop}} 的反向部分（即
    \coqref{LF.Logic.evenb double}{\coqdoclemma{evenb\_double}}，从命题到布尔表达式的方向）时，我们对
    \coqdocvariable{k} 进行了简单的归纳。而反方向的证明（即练习 \coqref{LF.Logic.evenb double conv}{\coqdoclemma{evenb\_double\_conv}}）
    则需要一种聪明的一般化方法，因为我们无法直接证明
    (\coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvariable{n} = \coqref{LF.Basics.true}{\coqdocconstructor{true}}) \ensuremath{\rightarrow} \coqref{LF.Logic.even}{\coqdocdefinition{even}} \coqdocvariable{n}。 

 对于这些例子来说，命题式的声明比与之对应的布尔表达式要更为有用，
    但并非总是如此。例如，我们无法在函数的定义中测试一般的命题是否为真，
    因此以下代码片段会被拒绝： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Fail}\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Logic.is even prime}{is\_even\_prime}{\coqdocdefinition{is\_even\_prime}} \coqdocvar{n} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{if} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 2 \coqdockw{then} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{else} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Coq 会抱怨 \coqdocvariable{n} = 2 的类型是 \coqdockw{Prop}，而它想要一个 \coqref{LF.Basics.bool}{\coqdocinductive{bool}}
    类型的元素（或其它带有两个元素的归纳类型）。原因与 Coq
    核心语言的\textit{'可计算性'}特质有关，即它能表达的所有函数都是可计算且完全的。
    这样设计的的原因之一是为了能从 Coq 开发的代码中提取出可执行程序。
    因此，在 Coq 中 \coqdockw{Prop} \textit{'并没有'}一种通用的情况分析操作来确定
    任意给定的命题是否为真，一旦存在这种操作，我们就能写出不可计算的函数。


    尽管一般的不可计算性质无法表述为布尔计算，但值得注意的是，很多
    \textit{'可计算的'}性质更容易通过 \coqdockw{Prop} 而非 \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 来表达，因为在 Coq
    中定义递归函数中会受到很大的限制。例如，下一章会展示如何用 \coqdockw{Prop}
    来定义“某个正则表达式可以匹配给定的字符串”这一性质。如果使用
    \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 来定义，就需要写一个真正的正则表达式匹配器了，比起该性质的简单定义
    （即非算法的定义）来说，这样会更加复杂，更难以理解，也更难以对它进行推理。


    另一方面，通过布尔值来陈述事实会带来一点重要的优势，即通过对 Coq
    中的项进行计算可以实现一些自动推理，这种技术被称为\textit{'互映证明（Proof
    by Reflection）'}。考虑以下陈述： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Logic.even 1000}{even\_1000}{\coqdocdefinition{even\_1000}} : \coqref{LF.Logic.even}{\coqdocdefinition{even}} 1000.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
对此命题而言，最直接的证明方式就是直接给出 \coqdocvariable{k} 的值。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{unfold} \coqref{LF.Logic.even}{\coqdocdefinition{even}}. \coqdoctac{\ensuremath{\exists}} 500. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
而使用与之对应的布尔语句的证明则更加简单（因为我们不必给出证据，Coq
    的计算机制会帮我们搞定它！） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Logic.even 1000'}{even\_1000'}{\coqdocdefinition{even\_1000'}} : \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} 1000 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
有趣的是，由于这两种定义是等价的，因此我们无需显式地给出 500，
    而是使用布尔等价式来证明彼此： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Logic.even 1000''}{even\_1000'{}'}{\coqdocdefinition{even\_1000'{}'}} : \coqref{LF.Logic.even}{\coqdocdefinition{even}} 1000.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{apply} \coqref{LF.Logic.even bool prop}{\coqdoclemma{even\_bool\_prop}}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
尽管此例的证明脚本的长度并未因此而减少，然而更大的证明通常可通过
    这种互映的方式来显著化简。举一个极端的例子，在用 Coq 证明著名的
    \textit{'四色定理'}时，人们使用互映技巧将几百种不同的情况归约成了一个布尔计算。 

 另一点明显的不同是“布尔事实”的否定可以被直白地陈述并证明，
    只需翻转预期的布尔值结果即可。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Logic.not even 1001}{not\_even\_1001}{\coqdocdefinition{not\_even\_1001}} : \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} 1001 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
相反，命题的否定形式可能更难以直接证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Logic.not even 1001'}{not\_even\_1001'}{\coqdocdefinition{not\_even\_1001'}} : \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\~{}(}}\coqref{LF.Logic.even}{\coqdocdefinition{even}} 1001\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqref{LF.Logic.even bool prop}{\coqdoclemma{even\_bool\_prop}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqexternalref{not}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocdefinition{not}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{discriminate} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
相等性提供了另一个互补的例子，在命题的世界中它有时更容易处理。 
    在涉及 \coqdocvariable{n} 和 \coqdocvariable{m} 的证明中，知道 \coqdocvariable{n} =? \coqdocvariable{m} = \coqref{LF.Basics.true}{\coqdocconstructor{true}}
    通常没什么直接的帮助。然而如果我们将该语句转换为等价的 \coqdocvariable{n} = \coqdocvariable{m} 形式，
    则可利用该等式改写证明目标。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.plus eqb example}{plus\_eqb\_example}{\coqdoclemma{plus\_eqb\_example}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \coqref{LF.Logic.eqb eq}{\coqdoclemma{eqb\_eq}} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{LF.Logic.eqb eq}{\coqdoclemma{eqb\_eq}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们不会在这里详细讨论互映技巧，然而对于展示布尔计算与一般命题的互补优势而言，
    它是个很好的例子，在后面的章节中，能够在布尔和命题的世界之间来回穿梭通常会非常方便。 

\paragraph{练习：2 星, standard (logical\_connectives)}




    以下引理将本章中讨论的命题联结词与对应的布尔操作关联了起来。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.andb true iff}{andb\_true\_iff}{\coqdoclemma{andb\_true\_iff}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b1} \coqdocvar{b2}:\coqref{LF.Basics.bool}{\coqdocinductive{bool}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{b1} \coqref{LF.Basics.:::x 'x26x26' x}{\coqdocnotation{\&\&}} \coqdocvariable{b2} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{b1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqdocvariable{b2} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.orb true iff}{orb\_true\_iff}{\coqdoclemma{orb\_true\_iff}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b1} \coqdocvar{b2},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{b1} \coqref{LF.Basics.:::x '||' x}{\coqdocnotation{||}} \coqdocvariable{b2} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{b1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{b2} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：1 星, standard (eqb\_neq)}




    以下定理为等价式 \coqref{LF.Logic.eqb eq}{\coqdoclemma{eqb\_eq}} 的“否定”版本，
    在某些场景中使用它会更方便些（后面的章节中会讲到这方面的例子）。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.eqb neq}{eqb\_neq}{\coqdoclemma{eqb\_neq}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{x} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{y} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{x} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard (eqb\_list)}




    给定一个用于测试类型为 \coqref{LF.Basics.A}{\coqdocconstructor{A}} 的元素相等关系的布尔操作符 \coqref{LF.Basics.eqb}{\coqdocdefinition{eqb}}，
    我们可以定义函数 \coqref{LF.Logic.eqb list}{\coqdocdefinition{eqb\_list}} 来测试元素类型为 \coqref{LF.Basics.A}{\coqdocconstructor{A}} 的列表的相等关系。
    请完成以下 \coqref{LF.Logic.eqb list}{\coqdocdefinition{eqb\_list}} 函数的定义。要确定你的定义是否正确，请证明引理
    \coqref{LF.Logic.eqb list true iff}{\coqdoclemma{eqb\_list\_true\_iff}}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Logic.eqb list}{eqb\_list}{\coqdocdefinition{eqb\_list}} \{\coqdocvar{A} : \coqdockw{Type}\} (\coqdocvar{eqb} : \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}})\coqdoceol
\coqdocindent{9.00em}
(\coqdocvar{l1} \coqdocvar{l2} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{A}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Logic.eqb list true iff}{eqb\_list\_true\_iff}{\coqdoclemma{eqb\_list\_true\_iff}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{A} (\coqdocvar{eqb} : \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}),\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{a1} \coqdocvar{a2}, \coqdocvariable{eqb} \coqdocvariable{a1} \coqdocvariable{a2} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{a1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{a2}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{l1} \coqdocvar{l2}, \coqref{LF.Logic.eqb list}{\coqdocaxiom{eqb\_list}} \coqdocvariable{eqb} \coqdocvariable{l1} \coqdocvariable{l2} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{l1} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{l2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, recommended (All\_forallb)}




    回忆一下\coqdoclibrary{Tactics}一章中练习 \coqdocvar{forall\_exists\_challenge} 的函数
    \coqref{LF.Tactics.forallb}{\coqdocdefinition{forallb}}： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Logic.forallb}{forallb}{\coqdocdefinition{forallb}} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{test} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{x} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{l'} \ensuremath{\Rightarrow} \coqref{LF.Basics.andb}{\coqdocdefinition{andb}} (\coqdocvariable{test} \coqdocvar{x}) (\coqref{LF.Logic.forallb}{\coqdocdefinition{forallb}} \coqdocvariable{test} \coqdocvar{l'})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
请证明以下定理，它将 \coqref{LF.Tactics.forallb}{\coqdocdefinition{forallb}} 与之前的定义中 \coqdockw{All} 的性质联系了起来。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.forallb true iff}{forallb\_true\_iff}{\coqdoclemma{forallb\_true\_iff}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X} \coqdocvar{test} (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{1.50em}
\coqref{LF.Logic.forallb}{\coqdocdefinition{forallb}} \coqdocvariable{test} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{LF.Logic.All}{\coqdocaxiom{All}} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvariable{test} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}) \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（未分级的思考题）函数 \coqref{LF.Tactics.forallb}{\coqdocdefinition{forallb}} 是否还存在尚未被此规范刻画到的重要性质？ \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\subsection{经典逻辑 vs. 构造逻辑}



 我们已经知道了，在定义 Coq 函数时是无法判断命题 \coqdocvariable{P} 是否成立。
    然而\textit{'证明'}也存在类似的限制！换句话说，以下推理原则即便符合直觉，
    不过在 Coq 中它是不可证明的： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Logic.excluded middle}{excluded\_middle}{\coqdocdefinition{excluded\_middle}} := \coqdockw{\ensuremath{\forall}} \coqdocvar{P} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqdocvariable{P}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
为了在操作上理解为何如此, 回忆一下，在证明形如 \coqdocvariable{P} \ensuremath{\lor} \coqdocvariable{Q}
    的陈述时，我们使用了 \coqdoctac{left} 与 \coqdoctac{right} 策略，它们能够有效地知道析取的哪边成立。
    然而在 \coqref{LF.Logic.excluded middle}{\coqdocdefinition{excluded\_middle}} 中，\coqdocvariable{P} 是被全称量化的\textit{'任意'}命题，我们对它一无所知。
    我们没有足够的信息来选择使用 \coqdoctac{left} 或 \coqdoctac{right} 中的哪一个。就像 Coq
    因为缺乏信息而无法在函数内部机械地确定 \coqdocvariable{P} 是否成立一样。 

 然而，如果我们恰好知道 \coqdocvariable{P} 与某个布尔项互映，那么就能很轻易地知道它是否成立了：
    我们只需检查 \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} 的值即可。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.restricted excluded middle}{restricted\_excluded\_middle}{\coqdoclemma{restricted\_excluded\_middle}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{b},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqdocvariable{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} [] \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{left}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{right}. \coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{intros} \coqdocvar{contra}. \coqdoctac{discriminate} \coqdocvar{contra}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
特别来说，对于自然数 \coqdocvariable{n} 和 \coqdocvariable{m} 的 \coqdocvariable{n} = \coqdocvariable{m} 而言，排中律是成立的。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.restricted excluded middle eq}{restricted\_excluded\_middle\_eq}{\coqdoclemma{restricted\_excluded\_middle\_eq}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqdocvariable{n} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{LF.Logic.restricted excluded middle}{\coqdoclemma{restricted\_excluded\_middle}} (\coqdocvar{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{m}) (\coqdocvar{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvar{m})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{symmetry}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.Logic.eqb eq}{\coqdoclemma{eqb\_eq}}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
一般的排中律在 Coq 中默认并不可用，因为它是常见的逻辑系统（如
    ZFC）中的标准特性。尽管如此，不假设排中律的成立仍有其独特的优点：
    Coq 中的陈述可以构造出比标准数学中同样陈述更强的断言。特别是，
    当存在 \coqdoctac{\ensuremath{\exists}} \coqdocvariable{x}, \coqdocvariable{P} \coqdocvariable{x} 的 Coq 证明时，我们可以直接给出一个使 \coqdocvariable{P} \coqdocvariable{x}
    得证的值 \coqdocvariable{x}。换言之，任何关于存在性的证明必定是\textit{'构造性'}的。 

 像 Coq 一样不假设排中律成立的逻辑系统被称作\textit{'构造逻辑'}。


    像 ZFC 这样更加传统的，排中律对于任何命题都成立的逻辑系统则被称作\textit{'经典逻辑'}。 

 以下示例展示了为何假设排中律成立会导致非构造性证明：


    \textit{'命题'}：存在无理数 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 和 \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} 使得 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} \^{} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}}（\coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 的 \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} 次方）为有理数。


    \textit{'证明'}：易知 \coqdocvar{sqrt} 2 为无理数。若 \coqdocvar{sqrt} 2 \^{} \coqdocvar{sqrt} 2 为有理数，
    那么可以取 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} = \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} = \coqdocvar{sqrt} 2 证明结束；否则 \coqdocvar{sqrt} 2 \^{} \coqdocvar{sqrt} 2 为无理数。
    此时，我们可以取 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} = \coqdocvar{sqrt} 2 \^{} \coqdocvar{sqrt} 2 和 \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} = \coqdocvar{sqrt} 2，因为
    \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} \^{} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} = \coqdocvar{sqrt} 2 \^{} (\coqdocvar{sqrt} 2 \ensuremath{\times} \coqdocvar{sqrt} 2) = \coqdocvar{sqrt} 2 \^{} 2 = 2.  \ensuremath{\Box}


    看到发生什么了吗？我们使用排中律在不知道 \coqdocvar{sqrt} 2 \^{} \coqdocvar{sqrt} 2
    是否为有理数的情况下就分别考虑了这两种情况！因此，我们通过证明知道了这样的
    \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 和 \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} 存在，但却无法确切知道它们的值（至少无法从此论据中获知）。


    即便构造逻辑很有用，它也有自身的限制：存在很多容易用经典逻辑证明的命题，
    用构造证明只会更加复杂，而对于某些已知的命题而言这样的构造性证明甚至不存在！
    幸运的是，排中律和函数外延性一样都是与 Coq 的逻辑系统兼容的，
    我们可以安全地将它作为公理添加到 Coq 中。然而，在本书中我们不必如此：
    我们所涉及的结构都可以完全用构造逻辑得到，所需的额外代价则微不足道。


    我们需要一定的实践才能理解哪些证明技巧不应在构造推理中使用，
    而其中的反证法尤为臭名昭著，因为它会导向非构造性证明。这里有个典型的例子：
    假设我们想要证明存在 \coqdocvariable{x} 具有某种性质 \coqdocvariable{P}，即存在 \coqdocvariable{P} \coqdocvariable{x}。我们先假设结论为假，
    也就是说 \ensuremath{\lnot} \coqdoctac{\ensuremath{\exists}} \coqdocvariable{x}, \coqdocvariable{P} \coqdocvariable{x}。根据此前提，不难推出 \coqdockw{\ensuremath{\forall}} \coqdocvariable{x}, \ensuremath{\lnot} \coqdocvariable{P} \coqdocvariable{x}。
    如果我们能够根据此中间事实得到矛盾，就能得到一个存在性证明而完全不必指出一个
    \coqdocvariable{x} 的值使得 \coqdocvariable{P} \coqdocvariable{x} 成立！


    从构造性的角度来看，这里存在着技术上的瑕疵，即我们试图通过对
    \ensuremath{\lnot} \ensuremath{\lnot} (\coqdoctac{\ensuremath{\exists}} \coqdocvariable{x}, \coqdocvariable{P} \coqdocvariable{x}) 的证明来证明 \coqdoctac{\ensuremath{\exists}} \coqdocvariable{x}, \coqdocvariable{P} \coqdocvariable{x}。从以下练习中我们会看到，
    允许自己从任意陈述中去掉双重否定等价于引入排中律。因此，只要我们不引入排中律，
    就无法在 Coq 中编码此推理。 

\paragraph{练习：3 星, standard (excluded\_middle\_irrefutable)}




    证明通用排中律公理与 Coq 的一致性需要复杂的推理，而且并不能在 Coq
    自身中进行。然而，以下定理蕴含了假设可判定性公理（即排中律的一个特例）
    成立对于任何\textit{'具体的'}命题 \coqdocvariable{P} 而言总是安全的。之所以如此，
    是因为我们无法证明这类公理的否定命题。假如我们可以的话，就会同时有
    \ensuremath{\lnot} (\coqdocvariable{P} \ensuremath{\lor} \ensuremath{\lnot}\coqdocvariable{P}) 和 \ensuremath{\lnot} \ensuremath{\lnot} (\coqdocvariable{P} \ensuremath{\lor} \ensuremath{\lnot}\coqdocvariable{P})（因为根据引理 \coqref{LF.Logic.double neg}{\coqdoclemma{double\_neg}}，\coqdocvariable{P} 蕴含 \ensuremath{\lnot} \ensuremath{\lnot} \coqdocvariable{P}），
    而这会产生矛盾。但因为我们不能，所以将 \coqdocvariable{P} \ensuremath{\lor} \ensuremath{\lnot}\coqdocvariable{P} 作为公理加入是安全的。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.excluded middle irrefutable}{excluded\_middle\_irrefutable}{\coqdoclemma{excluded\_middle\_irrefutable}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{P}:\coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P} \coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqdocvariable{P}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, advanced (not\_exists\_dist)}




    在经典逻辑中有这样一条定理，它断言以下两条命题是等价的：


    \~{} (exists x, \~{} P x)
    forall x, P x


    之前的 \coqref{LF.Logic.dist not exists}{\coqdoclemma{dist\_not\_exists}} 证明了此等价式的一个方向。有趣的是，
    我们无法用构造逻辑证明另一个方向。你的任务就是证明排中律蕴含此方向的证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Logic.not exists dist}{not\_exists\_dist}{\coqdoclemma{not\_exists\_dist}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Logic.excluded middle}{\coqdocdefinition{excluded\_middle}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{P} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop}),\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\exists}}} \coqdocvar{x}\coqexternalref{::type scope:'exists' x '..' x ',' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{,}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}} \coqdocvariable{P} \coqdocvariable{x}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvariable{P} \coqdocvariable{x}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：5 星, standard, optional (classical\_axioms)}




    对于喜欢挑战的读者，以下练习来自于 Bertot 与 Casteran 所著的
    Coq'Art 一书中第 123 页。以下四条陈述的每一条，加上 \coqref{LF.Logic.excluded middle}{\coqdocdefinition{excluded\_middle}}
    可以认为刻画了经典逻辑。我们无法在 Coq 中证明其中的任意一条，
    不过如果我们希望在经典逻辑下工作的话，可以安全地将其中任意一条作为公理添加到
    Coq 中而不会造成不一致性。


    请证明所有五个命题都是等价的（这四个再加上 \coqref{LF.Logic.excluded middle}{\coqdocdefinition{excluded\_middle}}）。


    提示：不要去分别考虑每一对命题，而是证明一条将它们连接起来的单向蕴含环链。
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Logic.peirce}{peirce}{\coqdocdefinition{peirce}} := \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q}: \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{((}}\coqdocvariable{P}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)->}}\coqdocvariable{P}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)->}}\coqdocvariable{P}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Logic.double negation elimination}{double\_negation\_elimination}{\coqdocdefinition{double\_negation\_elimination}} := \coqdockw{\ensuremath{\forall}} \coqdocvar{P}:\coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\~{}\~{}}}\coqdocvariable{P} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Logic.de morgan not and not}{de\_morgan\_not\_and\_not}{\coqdocdefinition{de\_morgan\_not\_and\_not}} := \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q}:\coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\~{}(\~{}}}\coqdocvariable{P} \coqexternalref{::type scope:x '/x5C' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\land}}} \coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}}\coqdocvariable{Q}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{P}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}}\coqdocvariable{Q}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Logic.implies to or}{implies\_to\_or}{\coqdocdefinition{implies\_to\_or}} := \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q}:\coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{P}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{::type scope:'x7E' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lnot}}}\coqdocvariable{P}\coqexternalref{::type scope:x 'x5C/' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\lor}}}\coqdocvariable{Q}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.Tactics}{Library }{LF.Tactics}

\begin{coqdoccode}
\end{coqdoccode}
\section{Tactics: 更多基本策略}



 本章额外介绍了一些证明策略和手段，
    它们能用来证明更多关于函数式程序的有趣性质。


    我们会看到：

\begin{itemize}
\item  如何在“向前证明”和“向后证明”两种风格中使用辅助引理；

\item  如何对数据构造子进行论证，特别是，如何利用它们单射且不交的事实；

\item  如何增强归纳假设，以及何时需要增强；

\item  还有通过分类讨论进行论证的更多细节。 
\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Export} \coqref{LF.Poly}{\coqdoclibrary{Poly}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{\texorpdfstring{\protect\coqdoctac{apply}}{apply} 策略}



 我们经常会遇到待证目标与上下文中的前提或已证引理\textit{'刚好相同'}的情况。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.silly1}{silly1}{\coqdoclemma{silly1}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{o}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{p}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{o}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{m}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{p}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{p} \coqdocvar{eq1} \coqdocvar{eq2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{eq1}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们可以像之前那样用“\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{eq2}.  \coqdoctac{reflexivity}.”来完成。
    不过如果我们使用 \coqdoctac{apply} 策略，只需一步就能完成此证明： \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{eq2}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdoctac{apply} 策略也可以配合\textit{'条件（Conditional）'}假设和引理来使用：
    如果被应用的语句是一个蕴含式，那么该蕴含式的前提就会被添加到待证子目标列表中。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.silly2}{silly2}{\coqdoclemma{silly2}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{o}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{m}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{p}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{o}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{m}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{p}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{p} \coqdocvar{eq1} \coqdocvar{eq2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{eq2}. \coqdoctac{apply} \coqdocvar{eq1}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
通常，当我们使用 \coqdoctac{apply} \coqdocvariable{H} 时，语句 \coqdocvariable{H} 会以一个引入了某些
    \textit{'通用变量（Universal Variables）'} 的 \coqdockw{\ensuremath{\forall}} 开始。在 Coq 针对 \coqdocvariable{H}
    的结论匹配当前目标时，它会尝试为这些变量查找适当的值。例如，
    当我们在以下证明中执行 \coqdoctac{apply} \coqdocvar{eq2} 时，\coqdocvar{eq2} 中的通用变量 \coqdocvariable{q}
    会以 \coqdocvariable{n} 实例化，而 \coqdocvariable{r} 会以 \coqdocvariable{m} 实例化。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.silly2a}{silly2a}{\coqdoclemma{silly2a}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvariable{n}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}}\coqdocvariable{n}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvariable{m}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}}\coqdocvariable{m}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} (\coqdocvar{q} \coqdocvar{r} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}), \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvariable{q}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}}\coqdocvariable{q}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvariable{r}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}}\coqdocvariable{r}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{q}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{r}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{m}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{eq1} \coqdocvar{eq2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{eq2}. \coqdoctac{apply} \coqdocvar{eq1}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard, optional (silly\_ex)}




    请只用 \coqdoctac{intros} 和 \coqdoctac{apply} 完成以下证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.silly ex}{silly\_ex}{\coqdoclemma{silly\_ex}} :\coqdoceol
\coqdocindent{2.50em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} 4 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} 3 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 要使用 \coqdoctac{apply} 策略，被应用的事实（的结论）必须精确地匹配证明目标：
    例如, 当等式的左右两边互换后，\coqdoctac{apply} 就无法起效了。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.silly3 firsttry}{silly3\_firsttry}{\coqdoclemma{silly3\_firsttry}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 5\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{(}}\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n})\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{)}} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 7 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{H}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在这里，我们无法直接使用 \coqdoctac{apply}，不过我们可以用 \coqdoctac{symmetry} 策略
    它会交换证明目标中等式的左右两边。 \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{symmetry}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \end{coqdoccode}
（此处的 \coqdoctac{simpl} 是可选的，因为 \coqdoctac{apply} 会在需要时先进行化简。） \begin{coqdoccode}
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：3 星, standard (apply\_exercise1)}




    （\textit{'提示'}：你可以配合之前定义的引理来使用 \coqdoctac{apply}，不仅限于当前上下文中的前提。
    记住 \coqdockw{Search} 是你的朋友。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.rev exercise1}{rev\_exercise1}{\coqdoclemma{rev\_exercise1}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{l} \coqdocvar{l'} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.rev}{\coqdocdefinition{rev}} \coqdocvariable{l'} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{l'} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.rev}{\coqdocdefinition{rev}} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：1 星, standard, optional (apply\_rewrite)}




    简述 \coqdoctac{apply} 与 \coqdoctac{rewrite} 策略之区别。哪些情况下二者均可有效利用？ \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\section{\texorpdfstring{\protect\coqdoctac{apply}}{apply} \texorpdfstring{\protect\coqdockw{with}}{with} 策略}



 以下愚蠢的例子在一行中使用了两次改写来将 [\coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}};\coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}}] 变成 [\coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}};\coqdocvariable{f}]。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Tactics.trans eq example}{trans\_eq\_example}{\coqdocdefinition{trans\_eq\_example}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d} \coqdocvar{e} \coqdocvar{f} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{a}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{b}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{c}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{d}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{c}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{d}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{e}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{f}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{a}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{b}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{e}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{f}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d} \coqdocvar{e} \coqdocvar{f} \coqdocvar{eq1} \coqdocvar{eq2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{eq1}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{eq2}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
由于这种模式十分常见，因此我们希望一劳永逸地把它作为一条引理记录下来，
    即等式具有传递性。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.trans eq}{trans\_eq}{\coqdoclemma{trans\_eq}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{n} \coqdocvar{m} \coqdocvar{o} : \coqdocvariable{X}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{o} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{o}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{eq1} \coqdocvar{eq2}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{eq1}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{eq2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在，按理说我们应该可以用 \coqref{LF.Tactics.trans eq}{\coqdoclemma{trans\_eq}} 来证明前面的例子了。
    然而，为此我们还需要稍微改进一下 \coqdoctac{apply} 策略。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Tactics.trans eq example'}{trans\_eq\_example'}{\coqdocdefinition{trans\_eq\_example'}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d} \coqdocvar{e} \coqdocvar{f} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{a}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{b}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{c}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{d}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{c}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{d}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{e}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{f}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{a}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{b}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{e}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{f}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d} \coqdocvar{e} \coqdocvar{f} \coqdocvar{eq1} \coqdocvar{eq2}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
如果此时我们只是告诉 Coq \coqdoctac{apply} \coqref{LF.Tactics.trans eq}{\coqdoclemma{trans\_eq}}，那么它会
    （根据该引理的结论对证明目标的匹配）说 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 应当实例化为 [\coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}]、\coqdocvariable{n}
    实例化为 [\coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}},\coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}}]、以及 \coqdocvariable{o} 实例化为 [\coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}},\coqdocvariable{f}]。然而，匹配过程并没有为
    \coqdocvariable{m} 确定实例：我们必须在 \coqdoctac{apply} 的调用后面加上 ``\coqdockw{with} (\coqdocvariable{m}:=[\coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}},\coqref{LF.Poly.MumbleGrumble.d}{\coqdocconstructor{d}}])''
    来显式地提供一个实例。 \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{LF.Tactics.trans eq}{\coqdoclemma{trans\_eq}} \coqdockw{with} (\coqdocvar{m}:=\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvar{c}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvar{d}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{eq1}. \coqdoctac{apply} \coqdocvar{eq2}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（实际上，我们通常不必在 \coqdockw{with} 从句中包含名字 \coqdocvariable{m}，Coq
    一般足够聪明来确定我们实例化的变量。我们也可以写成：
    \coqdoctac{apply} \coqref{LF.Tactics.trans eq}{\coqdoclemma{trans\_eq}} \coqdockw{with} [\coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}};\coqref{LF.Poly.MumbleGrumble.d}{\coqdocconstructor{d}}]。） 

\paragraph{练习：3 星, standard, optional (apply\_with\_exercise)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Tactics.trans eq exercise}{trans\_eq\_exercise}{\coqdocdefinition{trans\_eq\_exercise}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.minustwo}{\coqdocdefinition{minustwo}} \coqdocvariable{o}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.minustwo}{\coqdocdefinition{minustwo}} \coqdocvariable{o}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{The \texorpdfstring{\protect\coqdoctac{injection}}{injection} and \texorpdfstring{\protect\coqdoctac{discriminate}}{discriminate} Tactics}



 回想自然数的定义：


     Inductive nat : Type :=
       | O
       | S (n : nat).


    我们可从该定义中观察到，所有的数都是两种形式之一：要么是构造子 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}}，
    要么就是将构造子 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 应用到另一个数上。不过这里还有无法直接看到的：
    自然数的定义中还蕴含了两个事实：



\begin{itemize}
\item  构造子 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 是\textit{'单射（Injective）'}或\textit{'一一对应'}的。
      即，如果 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{m}，那么 \coqdocvariable{n} = \coqdocvariable{m} 必定成立。



\item  构造子 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} 和 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 是\textit{'不相交（Disjoint）'}的。
      即，对于任何 \coqdocvariable{n}，\coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} 都不等于 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}。 
\end{itemize}


 类似的原理同样适用于所有归纳定义的类型：所有构造子都是单射的，
    而不同构造子构造出的值绝不可能相等。对于列表来说，\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 构造子是单射的，
    而 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} 不同于任何非空列表。对于布尔值来说，\coqref{LF.Basics.true}{\coqdocconstructor{true}} 和 \coqref{LF.Basics.false}{\coqdocconstructor{false}} 是不同的。
    因为 \coqref{LF.Basics.true}{\coqdocconstructor{true}} 和 \coqref{LF.Basics.false}{\coqdocconstructor{false}} 二者都不接受任何参数，它们既不在这边也不在那边。
    其它归纳类型亦是如此。 

 例如，我们可以使用定义在 \coqdocvar{Basics.v} 中的 \coqref{LF.Basics.NatPlayground.pred}{\coqdocdefinition{pred}} 函数来证明 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 的单射性。
. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.S injective}{S\_injective}{\coqdoclemma{S\_injective}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{H2}: \coqdocvar{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{pred}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{pred}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n})). \{ \coqdoctac{reflexivity}. \}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{H2}. \coqdoctac{rewrite} \coqdocvar{H1}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这个技巧可以通过编写等价的 \coqref{LF.Basics.NatPlayground.pred}{\coqdocdefinition{pred}} 来推广到任意的构造子上 ——
    即编写一个“撤销”一次构造子调用的函数。为此，Coq 提供了更加简便的
    \coqdoctac{injection} 策略，它能让我们利用任意构造子的单射性。
    下面是使用 \coqdoctac{injection} 对上面定理的另一种证法： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.S injective'}{S\_injective'}{\coqdoclemma{S\_injective'}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{H}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
通过在此处编写 \coqdoctac{injection} \coqdocvariable{H} \coqdockw{as} \coqdocvar{Hmn}，我们让 Coq
    利用构造子的单射性来产生所有它能从 \coqdocvariable{H} 所推出的等式（本例中为等式 \coqdocvariable{n} = \coqdocvariable{m}）。
    每一个这样的等式都作为假设（本例中为 \coqdocvar{Hmn}）被添加到上下文中。
\begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{injection} \coqdocvar{H} \coqdockw{as} \coqdocvar{Hnm}. \coqdoctac{apply} \coqdocvar{Hnm}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
以下例子展示了一个 \coqdoctac{injection} 如何直接得出多个等式。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.injection ex1}{injection\_ex1}{\coqdoclemma{injection\_ex1}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} \coqdocvar{o} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} \coqdocvariable{m}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{o}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} \coqdocvariable{o}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{m}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{injection} \coqdocvar{H} \coqdockw{as} \coqdocvar{H1} \coqdocvar{H2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{H1}. \coqdoctac{rewrite} \coqdocvar{H2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
另一方面，如果你只使用 \coqdoctac{injection} \coqdocvariable{H} 而不带 \coqdockw{as} 从句，
    那么所有的等式都会在目标的开头被转变为假设。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.injection ex2}{injection\_ex2}{\coqdoclemma{injection\_ex2}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} \coqdocvar{o} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} \coqdocvariable{m}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{o}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} \coqdocvariable{o}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{m}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{injection} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H1} \coqdocvar{H2}. \coqdoctac{rewrite} \coqdocvar{H1}. \coqdoctac{rewrite} \coqdocvar{H2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：3 星, standard (injection\_ex3)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Tactics.injection ex3}{injection\_ex3}{\coqdocdefinition{injection\_ex3}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvariable{X}) (\coqdocvar{l} \coqdocvar{j} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{x} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{y} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{z} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{j} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{j} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{z} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{l} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 So much for injectivity of constructors.  What about disjointness?


    The principle of disjointness says that two terms beginning with
    different constructors (like \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} and \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}}, or \coqref{LF.Basics.true}{\coqdocconstructor{true}} and \coqref{LF.Basics.false}{\coqdocconstructor{false}})
    can never be equal.  This means that, any time we find ourselves
    in a context where we've \textit{assumed} that two such terms are equal,
    we are justified in concluding anything we want, since the
    assumption is nonsensical. 

 The \coqdoctac{discriminate} tactic embodies this principle: It is used on a
    hypothesis involving an equality between different
    constructors (e.g., \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}}), and it solves the current goal
    immediately.  Here is an example: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.eqb 0 l}{eqb\_0\_l}{\coqdoclemma{eqb\_0\_l}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.50em}
0 \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们可以通过对 \coqdocvariable{n} 进行分类讨论来继续。第一种分类是平凡的。 \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}] \coqdocvar{eqn}:\coqdocvar{E}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{H}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
However, the second one doesn't look so simple: assuming 0
    =? (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}) = \coqref{LF.Basics.true}{\coqdocconstructor{true}}, we must show \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'} = 0!  The way forward is to
    observe that the assumption itself is nonsensical: \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
    如果我们对这个假设使用 \coqdoctac{discriminate} ，
    Coq 便会确认我们当前正在证明的目标不可行，并同时移除它，不再考虑。 \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{H}. \coqdoctac{discriminate} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
本例是逻辑学原理\textit{'爆炸原理'}的一个实例，它断言矛盾的前提会推出任何东西，
    甚至是假命题！ \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.discriminate ex1}{discriminate\_ex1}{\coqdoclemma{discriminate\_ex1}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
2 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 5.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{contra}. \coqdoctac{discriminate} \coqdocvar{contra}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.discriminate ex2}{discriminate\_ex2}{\coqdoclemma{discriminate\_ex2}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{m}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{contra}. \coqdoctac{discriminate} \coqdocvar{contra}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
爆炸原理可能令你费解，那么请记住上述证明\textit{'并不'}肯定其后件，
    而是说明：\textit{'如果'}荒谬的前件成立，\textit{'那么'}就会得出荒谬的结论，
    如此一来我们将生活在一个不一致的宇宙中，这里每个陈述都是正确的。
    下一章将进一步讨论爆炸原理。 

\paragraph{练习：1 星, standard (discriminate\_ex3)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Tactics.discriminate ex3}{discriminate\_ex3}{\coqdocdefinition{discriminate\_ex3}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvariable{X}) (\coqdocvar{l} \coqdocvar{j} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{x} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{y} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{z}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 构造子的单射性能让我们论证 \coqdockw{\ensuremath{\forall}} (\coqdocvariable{n} \coqdocvariable{m} : \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}), \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{m} \ensuremath{\rightarrow} \coqdocvariable{n} = \coqdocvariable{m}。
    此蕴含式的逆形式是一个构造子和函数的更一般的实例，
    在后面我们会发现它用起来很方便： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.f equal}{f\_equal}{\coqdoclemma{f\_equal}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{A} \coqdocvar{B} : \coqdockw{Type}) (\coqdocvar{f}: \coqdocvariable{A} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{B}) (\coqdocvar{x} \coqdocvar{y}: \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{f} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{f} \coqdocvariable{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{f} \coqdocvar{x} \coqdocvar{y} \coqdocvar{eq}. \coqdoctac{rewrite} \coqdocvar{eq}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.eq implies succ equal}{eq\_implies\_succ\_equal}{\coqdoclemma{eq\_implies\_succ\_equal}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{apply} \coqref{LF.Tactics.f equal}{\coqdoclemma{f\_equal}}. \coqdoctac{apply} \coqdocvar{H}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
There is also a tactic named `f\_equal` that can prove such
    theorems.  Given a goal of the form \coqdocvariable{f} \coqdocvariable{a1} ... \coqdocvar{an} = \coqdocvariable{g} \coqdocvariable{b1} ... \coqdocvar{bn},
    the tactic \coqdoctac{f\_equal} will produce subgoals of the form \coqdocvariable{f} = \coqdocvariable{g},
    \coqdocvariable{a1} = \coqdocvariable{b1}, ..., \coqdocvar{an} = \coqdocvar{bn}. At the same time, any of these subgoals
    that are simple enough (e.g., immediately provable by
    \coqdoctac{reflexivity}) will be automatically discharged by \coqdoctac{f\_equal}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.eq implies succ equal'}{eq\_implies\_succ\_equal'}{\coqdoclemma{eq\_implies\_succ\_equal'}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{H}. \coqdoctac{f\_equal}. \coqdoctac{apply} \coqdocvar{H}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{对假设使用策略}



 默认情况下，大部分策略会作用于目标公式并保持上下文不变。然而，
    大部分策略还有对应的变体来对上下文中的语句执行类似的操作。


    例如，策略 \coqdoctac{simpl} \coqdoctac{in} \coqdocvariable{H} 会对上下文中的假设 \coqdocvariable{H} 执行化简。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.S inj}{S\_inj}{\coqdoclemma{S\_inj}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{b} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}),\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{(}}\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{)}} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{(}}\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{m}\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{b}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{b} \coqdocvar{H}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{H}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
类似地，\coqdoctac{apply} \coqdocvar{L} \coqdoctac{in} \coqdocvariable{H} 会针对上下文中的假设 \coqdocvariable{H} 匹配某些
    （形如 \coqref{LF.Imp.X}{\coqdocdefinition{X}} \ensuremath{\rightarrow} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} 中的）条件语句 \coqdocvar{L}。然而，与一般的 \coqdoctac{apply} 不同
    （它将匹配 \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} 的目标改写为子目标 \coqref{LF.Imp.X}{\coqdocdefinition{X}}），\coqdoctac{apply} \coqdocvar{L} \coqdoctac{in} \coqdocvariable{H} 会针对
    \coqref{LF.Imp.X}{\coqdocdefinition{X}} 匹配 \coqdocvariable{H}，如果成功，就将其替换为 \coqref{LF.Imp.Y}{\coqdocdefinition{Y}}。


    换言之，\coqdoctac{apply} \coqdocvar{L} \coqdoctac{in} \coqdocvariable{H} 给了我们一种“正向推理”的方式：根据 \coqref{LF.Imp.X}{\coqdocdefinition{X}} \ensuremath{\rightarrow} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}}
    和一个匹配 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 的假设，它会产生一个匹配 \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} 的假设。作为对比，\coqdoctac{apply} \coqdocvar{L}
    是一种“反向推理”：它表示如果我们知道 \coqref{LF.Imp.X}{\coqdocdefinition{X}} \ensuremath{\rightarrow} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} 并且试图证明 \coqref{LF.Imp.Y}{\coqdocdefinition{Y}}，
    那么证明 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 就足够了。


    下面是前面证明的一种变体，它始终使用正向推理而非反向推理。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.silly3'}{silly3'}{\coqdoclemma{silly3'}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 5 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{(}}\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n})\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{)}} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 7 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 5\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}  \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{(}}\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n})\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{)}} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 7\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{eq} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{eq} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
正向推理从\textit{'给定'}的东西开始（即前提、已证明的定理），
    根据它们迭代地刻画结论直到抵达目标。反向推理从\textit{'目标'}开始，
    迭代地推理蕴含目标的东西，直到抵达前提或已证明的定理。


    你在数学或计算机科学课上见过的非形式化证明可能倾向于正向推理。
    通常，Coq 习惯上倾向于使用反向推理，但在某些情况下，正向推理更易于思考。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{变换归纳假设}



 在 Coq 中进行归纳证明时，有时控制归纳假设的确切形式是十分重要的。
    特别是，在调用 \coqdoctac{induction} 策略前，我们有时需要用 \coqdoctac{intros}
    将假设从目标移到上下文中时要十分小心。例如，假设我们要证明 \coqref{LF.Induction.double}{\coqdocdefinition{double}}
    函数是单射的 -- 即，它将不同的参数映射到不同的结果：


       Theorem double\_injective: forall n m,
         double n = double m -> n = m.


    此证明的开始方式有点微妙：如果我们以


       intros n. induction n.


    开始，那么一切都好。然而假如以


       intros n m. induction n.


    开始，就会卡在归纳情况中... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.double injective FAILED}{double\_injective\_FAILED}{\coqdoclemma{double\_injective\_FAILED}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'} \coqdocvar{IHn'}].\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{eq}. \coqdoctac{destruct} \coqdocvar{m} \coqdockw{as} [| \coqdocvar{m'}] \coqdocvar{eqn}:\coqdocvar{E}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{discriminate} \coqdocvar{eq}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{intros} \coqdocvar{eq}. \coqdoctac{destruct} \coqdocvar{m} \coqdockw{as} [| \coqdocvar{m'}] \coqdocvar{eqn}:\coqdocvar{E}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{discriminate} \coqdocvar{eq}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{apply} \coqref{LF.Tactics.f equal}{\coqdoclemma{f\_equal}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
此时，归纳假设 \coqdocvar{IHn'} \textit{'不会'}给出 \coqdocvariable{n'} = \coqdocvar{m'} -- 会有个额外的 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 阻碍 --
    因此该目标无法证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
哪里出了问题？ 

 问题在于，我们在调用归纳假设的地方已经将 \coqdocvariable{m} 引入了上下文中 --
    直观上，我们已经告诉了 Coq“我们来考虑具体的 \coqdocvariable{n} 和 \coqdocvariable{m}...”，
    而现在必须为那些\textit{'具体的'} \coqdocvariable{n} 和 \coqdocvariable{m} 证明 \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{m}，
    然后才有 \coqdocvariable{n} = \coqdocvariable{m}。


    下一个策略 \coqdoctac{induction} \coqdocvariable{n} 告诉 Coq：我们要对 \coqdocvariable{n} 归纳来证明该目标。
    也就是说，我们要证明对于\textit{'所有的'} \coqdocvariable{n}，命题



\begin{itemize}
\item  \coqdocvariable{P} \coqdocvariable{n} = ``if \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{m}, then \coqdocvariable{n} = \coqdocvariable{m}''

\end{itemize}


    成立，需通过证明



\begin{itemize}
\item  \coqdocvariable{P} \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}}


        （即，若“\coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{m} 则 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} = \coqdocvariable{m}”）和



\item  \coqdocvariable{P} \coqdocvariable{n} \ensuremath{\rightarrow} \coqdocvariable{P} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n})


        （即，若“\coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{m} 则 \coqdocvariable{n} = \coqdocvariable{m}”蕴含“若
        \coqref{LF.Induction.double}{\coqdocdefinition{double}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}) = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{m} 则 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n} = \coqdocvariable{m}”）来得出。

\end{itemize}


    如果我们仔细观察第二个语句，就会发现它说了奇怪的事情：即，对于一个\textit{'具体的'}
    \coqdocvariable{m}，如果我们知道



\begin{itemize}
\item  “若 \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{m} 则 \coqdocvariable{n} = \coqdocvariable{m}”

\end{itemize}


    那么我们就能证明



\begin{itemize}
\item  “若 \coqref{LF.Induction.double}{\coqdocdefinition{double}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}) = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{m} 则 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n} = \coqdocvariable{m}”。

\end{itemize}


    要理解为什么它很奇怪，我们来考虑一个具体的（任意但确定的）\coqdocvariable{m} --
    比如说 5。该语句就会这样说：如果我们知道



\begin{itemize}
\item  \coqdocvariable{Q} = “若 \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} = 10 则 \coqdocvariable{n} = 5”

\end{itemize}


    那么我们就能证明



\begin{itemize}
\item  \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} = “若 \coqref{LF.Induction.double}{\coqdocdefinition{double}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}) = 10 则 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n} = 5”。

\end{itemize}


    但是知道 \coqdocvariable{Q} 对于证明 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}} 来说并没有任何帮助！（如果我们试着根据 \coqdocvariable{Q}
    证明 \coqref{LF.IndProp.R.R}{\coqdocinductive{R}}，就会以“假设 \coqref{LF.Induction.double}{\coqdocdefinition{double}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}) = 10..”这样的句子开始，
    不过之后我们就会卡住：知道 \coqref{LF.Induction.double}{\coqdocdefinition{double}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}) 为 10 并不能告诉我们
    \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} 是否为 10。（实际上，它强烈地表示 \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} \textit{'不是'} 10！）
    因此 \coqdocvariable{Q} 是没有用的。） 

 当 \coqdocvariable{m} 已经在上下文中时，试图对 \coqdocvariable{n} 进行归纳来进行此证明是行不通的，
    因为我们之后要尝试证明涉及\textit{'每一个'} \coqdocvariable{n} 的命题，而不只是\textit{'单个'} \coqdocvariable{m}。 

 对 \coqref{LF.Tactics.double injective}{\coqdoclemma{double\_injective}} 的成功证明将 \coqdocvariable{m} 留在了目标语句中 \coqdoctac{induction}
    作用于 \coqdocvariable{n} 的地方：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.double injective}{double\_injective}{\coqdoclemma{double\_injective}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'} \coqdocvar{IHn'}].\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{m} \coqdocvar{eq}. \coqdoctac{destruct} \coqdocvar{m} \coqdockw{as} [| \coqdocvar{m'}] \coqdocvar{eqn}:\coqdocvar{E}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{discriminate} \coqdocvar{eq}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
-  \coqdoctac{simpl}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
注意，此时的证明目标和归纳假设是不同的：证明目标要求我们证明更一般的事情
    （即，为\textit{'每一个'} \coqdocvariable{m} 证明该语句），而归纳假设 \coqdocvar{IH} 相应地更加灵活，
    允许我们在应用归纳假设时选择任何想要的 \coqdocvariable{m}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{eq}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在我们选择了一个具体的 \coqdocvariable{m} 并引入了假设 \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{m}。
    由于我们对 \coqdocvariable{n} 做了情况分析，因此还要对 \coqdocvariable{m} 做情况分析来保持两边“同步”。 \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{m} \coqdockw{as} [| \coqdocvar{m'}] \coqdocvar{eqn}:\coqdocvar{E}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{simpl}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
0 的情况很显然： \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{3.00em}
\coqdoctac{discriminate} \coqdocvar{eq}.\coqdoceol
\coqdocemptyline
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{LF.Tactics.f equal}{\coqdoclemma{f\_equal}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
到这里，由于我们在 \coqdoctac{destruct} \coqdocvariable{m} 的第二个分支中，因此上下文中涉及到的 \coqdocvar{m'}
    就是我们开始讨论的 \coqdocvariable{m} 的前趋。由于我们也在归纳的 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 分支中，这就很完美了：
    如果我们在归纳假设中用当前的 \coqdocvar{m'}（此实例由下一步的 \coqdoctac{apply} 自动产生）
    实例化一般的 \coqdocvariable{m}，那么 \coqdocvar{IHn'} 就刚好能给出我们需要的来结束此证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHn'}. \coqdoctac{injection} \coqdocvar{eq} \coqdockw{as} \coqdockw{goal}. \coqdoctac{apply} \coqdockw{goal}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
What you should take away from all this is that we need to be
    careful, when using induction, that we are not trying to prove
    something too specific: When proving a property involving two
    variables \coqdocvariable{n} and \coqdocvariable{m} by induction on \coqdocvariable{n}, it is sometimes
    crucial to leave \coqdocvariable{m} generic. 

 以下练习遵循同样的模式。 

\paragraph{练习：2 星, standard (eqb\_true)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.eqb true}{eqb\_true}{\coqdoclemma{eqb\_true}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, advanced (eqb\_true\_informal)}




    给出一个详细的 \coqref{LF.Tactics.eqb true}{\coqdoclemma{eqb\_true}} 的非形式化证明，量词要尽可能明确。 \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Tactics.manual grade for informal proof}{manual\_grade\_for\_informal\_proof}{\coqdocdefinition{manual\_grade\_for\_informal\_proof}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard, recommended (plus\_n\_n\_injective)}




    In addition to being careful about how you use \coqdoctac{intros}, practice
    using ``in'' variants in this proof.  (Hint: use \coqref{LF.Induction.plus n Sm}{\coqdoclemma{plus\_n\_Sm}}.) \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.plus n n injective}{plus\_n\_n\_injective}{\coqdoclemma{plus\_n\_n\_injective}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 在 \coqdoctac{induction} 之前做一些 \coqdoctac{intros} 来获得更一般归纳假设并不总是奏效。
    有时需要对量化的变量做一下\textit{'重排'}。例如，假设我们想要通过对 \coqdocvariable{m}
    而非 \coqdocvariable{n} 进行归纳来证明 \coqref{LF.Tactics.double injective}{\coqdoclemma{double\_injective}}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.double injective take2 FAILED}{double\_injective\_take2\_FAILED}{\coqdoclemma{double\_injective\_take2\_FAILED}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}. \coqdoctac{induction} \coqdocvar{m} \coqdockw{as} [| \coqdocvar{m'} \coqdocvar{IHm'}].\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{eq}. \coqdoctac{destruct} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}] \coqdocvar{eqn}:\coqdocvar{E}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{discriminate} \coqdocvar{eq}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{intros} \coqdocvar{eq}. \coqdoctac{destruct} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}] \coqdocvar{eqn}:\coqdocvar{E}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{discriminate} \coqdocvar{eq}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{apply} \coqref{LF.Tactics.f equal}{\coqdoclemma{f\_equal}}.\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
问题在于，要对 \coqdocvariable{m} 进行归纳，我们首先必须对 \coqdocvariable{n} 归纳。
    （而如果我们不引入任何东西就执行 \coqdoctac{induction} \coqdocvariable{m}，Coq 就会自动为我们引入 \coqdocvariable{n}！） 

 我们可以对它做什么？一种可能就是改写该引理的陈述使得 \coqdocvariable{m} 在 \coqdocvariable{n} 之前量化。
    这样是可行的，不过它不够好：我们不想调整该引理的陈述来适应具体的证明策略！
    我们更想以最清晰自然的方式陈述它。 

 我们可以先引入所有量化的变量，然后\textit{'重新一般化（re-generalize）'}
    其中的一个或几个，选择性地从上下文中挑出几个变量并将它们放回证明目标的开始处。
    用 \coqdoctac{generalize} \coqdoctac{dependent} 策略就能做到。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.double injective take2}{double\_injective\_take2}{\coqdoclemma{double\_injective\_take2}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{m} \coqdockw{as} [| \coqdocvar{m'} \coqdocvar{IHm'}].\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{n} \coqdocvar{eq}. \coqdoctac{destruct} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}] \coqdocvar{eqn}:\coqdocvar{E}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{discriminate} \coqdocvar{eq}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{intros} \coqdocvar{n} \coqdocvar{eq}. \coqdoctac{destruct} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}] \coqdocvar{eqn}:\coqdocvar{E}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{discriminate} \coqdocvar{eq}.\coqdoceol
\coqdocindent{2.00em}
+  \coqdoctac{apply} \coqref{LF.Tactics.f equal}{\coqdoclemma{f\_equal}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHm'}. \coqdoctac{injection} \coqdocvar{eq} \coqdockw{as} \coqdockw{goal}. \coqdoctac{apply} \coqdockw{goal}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们来看一下此定理的非形式化证明。注意我们保持 \coqdocvariable{n}
    的量化状态并通过归纳证明的命题，对应于我们形式化证明中依赖的一般化。


    \textit{'定理'}：对于任何自然数 \coqdocvariable{n} 和 \coqdocvariable{m}，若 \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{m}，则 \coqdocvariable{n} = \coqdocvariable{m}。


    \textit{'证明'}：令 \coqdocvariable{m} 为一个 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}。我们通过对 \coqdocvariable{m} 进行归纳来证明，对于任何 \coqdocvariable{n}，
        若 \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{m}，则 \coqdocvariable{n} = \coqdocvariable{m}。



\begin{itemize}
\item  首先，设 \coqdocvariable{m} = 0，而 \coqdocvariable{n} 是一个数使得 \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{m}。
        我们必须证明 \coqdocvariable{n} = 0。


        由于 \coqdocvariable{m} = 0，根据 \coqref{LF.Induction.double}{\coqdocdefinition{double}} 的定义，我们有 \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} = 0。此时对于 \coqdocvariable{n}
        需要考虑两种情况。若 \coqdocvariable{n} = 0，则得证，因为 \coqdocvariable{m} = 0 = \coqdocvariable{n}，正如所需。
        否则，若对于某个 \coqdocvariable{n'} 有 \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}，我们就会导出矛盾：根据 \coqref{LF.Induction.double}{\coqdocdefinition{double}}
        的定义，我们可得出 \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n'}))，但它与 \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} = 0
        相矛盾。



\item  其次，设 \coqdocvariable{m} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvar{m'}，而 \coqdocvariable{n} 同样是一个数使得 \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{m}。
        我们必须证明 \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvar{m'}，根据归纳假设，对于任何数 \coqdocvariable{s}，若
        \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{s} = \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvar{m'}，则 \coqdocvariable{s} = \coqdocvar{m'}。


        根据 \coqdocvariable{m} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvar{m'} 的事实以及 \coqref{LF.Induction.double}{\coqdocdefinition{double}} 的定义我们有 \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvar{m'}))。
        此时对于 \coqdocvariable{n} 需要考虑两种情况。


        若 \coqdocvariable{n} = 0，则根据 \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} = 0 的定义会得出矛盾。


        故存在 \coqdocvariable{n'} 使得 \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}。再次根据 \coqref{LF.Induction.double}{\coqdocdefinition{double}} 之定义，可得 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}}
        (\coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n'})) = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvar{m'}))。再由构造子单射可知 \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n'} =
        \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvar{m'}。以\coqdocvariable{n'} 代入归纳假设，推得 \coqdocvariable{n'} = \coqdocvar{m'}，故显然 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvar{m'}，
        其中 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'} = \coqdocvariable{n}，\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvar{m'} = \coqdocvariable{m}，所以原命题得证。 \ensuremath{\Box} 
\end{itemize}


 在结束本节之前，我们先稍微跑个题，使用 \coqref{LF.Tactics.eqb true}{\coqdoclemma{eqb\_true}}
    来证明一个标识符的类似性质以备后用： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.eqb id true}{eqb\_id\_true}{\coqdoclemma{eqb\_id\_true}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.eqb id}{\coqdocdefinition{eqb\_id}} \coqdocvariable{x} \coqdocvariable{y} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} [\coqdocvar{m}] [\coqdocvar{n}]. \coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{H'} : \coqdocvar{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{n}). \{ \coqdoctac{apply} \coqref{LF.Tactics.eqb true}{\coqdocaxiom{eqb\_true}}. \coqdoctac{apply} \coqdocvar{H}. \}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{H'}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：3 星, standard, recommended (gen\_dep\_practice)}




    通过对 \coqdocvariable{l} 进行归纳来证明它。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.nth error after last}{nth\_error\_after\_last}{\coqdoclemma{nth\_error\_after\_last}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Poly.nth error}{\coqdocdefinition{nth\_error}} \coqdocvariable{l} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{展开定义}



 It sometimes happens that we need to manually unfold a name that
    has been introduced by a \coqdockw{Definition} so that we can manipulate
    the expression it denotes.  For example, if we define... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Tactics.square}{square}{\coqdocdefinition{square}} \coqdocvar{n} := \coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{n}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
...并试图证明一个关于 \coqref{LF.Tactics.square}{\coqdocdefinition{square}} 的简单事实... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Tactics.square mult}{square\_mult}{\coqdoclemma{square\_mult}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m}, \coqref{LF.Tactics.square}{\coqdocdefinition{square}} (\coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{m}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Tactics.square}{\coqdocdefinition{square}} \coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqref{LF.Tactics.square}{\coqdocdefinition{square}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
...那么就会卡住：\coqdoctac{simpl} 无法化简任何东西，而由于我们尚未证明任何关于
    \coqref{LF.Tactics.square}{\coqdocdefinition{square}} 的事实，也就没有任何可以用来 \coqdoctac{apply} 或 \coqdoctac{rewrite} 的东西。


    为此，我们可以手动用 \coqdoctac{unfold} 展开 \coqref{LF.Tactics.square}{\coqdocdefinition{square}} 的定义： \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{LF.Tactics.square}{\coqdocdefinition{square}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在我们有很多工作要做：等式两边都是涉及乘法的表达式，
    而我们有很多可用的关于乘法的事实。特别是，我们知道它满足交换性和结合性，
    该引理据此不难证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqref{LF.Induction.mult assoc}{\coqdocaxiom{mult\_assoc}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{H} : \coqdocvar{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvar{m} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvar{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvar{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvar{m}).\coqdoceol
\coqdocindent{2.00em}
\{ \coqdoctac{rewrite} \coqref{LF.Induction.mult comm}{\coqdocaxiom{mult\_comm}}. \coqdoctac{apply} \coqref{LF.Induction.mult assoc}{\coqdocaxiom{mult\_assoc}}. \}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqref{LF.Induction.mult assoc}{\coqdocaxiom{mult\_assoc}}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在，是时候讨论下展开和化简了。


    我们已经观察到，像 \coqdoctac{simpl}、\coqdoctac{reflexivity} 和 \coqdoctac{apply} 这样的策略，
    通常总会在需要时自动展开函数的定义。例如，若我们将 \coqref{LF.Tactics.foo}{\coqdocdefinition{foo}} \coqdocvariable{m} 定义为常量 5... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Tactics.foo}{foo}{\coqdocdefinition{foo}} (\coqdocvar{x}: \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) := 5.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
那么在以下证明中 \coqdoctac{simpl}（或 \coqdoctac{reflexivity}，如果我们忽略 \coqdoctac{simpl}）
    就会将 \coqref{LF.Tactics.foo}{\coqdocdefinition{foo}} \coqdocvariable{m} 展开为 (\coqdockw{fun} \coqdocvariable{x} \ensuremath{\Rightarrow} 5) \coqdocvariable{m} 并进一步将其化简为 5。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fact} \coqdef{LF.Tactics.silly fact 1}{silly\_fact\_1}{\coqdoclemma{silly\_fact\_1}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqref{LF.Tactics.foo}{\coqdocdefinition{foo}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Tactics.foo}{\coqdocdefinition{foo}} (\coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1) \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
然而，这种自动展开有些保守。例如，若我们用模式匹配定义稍微复杂点的函数... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Tactics.bar}{bar}{\coqdocdefinition{bar}} \coqdocvar{x} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{x} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} 5\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{\_} \ensuremath{\Rightarrow} 5\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
...那么类似的证明就会被卡住： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fact} \coqdef{LF.Tactics.silly fact 2 FAILED}{silly\_fact\_2\_FAILED}{\coqdoclemma{silly\_fact\_2\_FAILED}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqref{LF.Tactics.bar}{\coqdocdefinition{bar}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Tactics.bar}{\coqdocdefinition{bar}} (\coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1) \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdoctac{simpl} 没有进展的原因在于，它注意到在试着展开 \coqref{LF.Tactics.bar}{\coqdocdefinition{bar}} \coqdocvariable{m} 之后会留下被匹配的
    \coqdocvariable{m}，它是一个变量，因此 \coqdockw{match} 无法被进一步化简。它还没有聪明到发现
    \coqdockw{match} 的两个分支是完全相同的。因此它会放弃展开 \coqref{LF.Tactics.bar}{\coqdocdefinition{bar}} \coqdocvariable{m} 并留在那。
    类似地，在试着展开 \coqref{LF.Tactics.bar}{\coqdocdefinition{bar}} (\coqdocvariable{m}+1) 时会留下一个 \coqdockw{match}，被匹配者是一个函数应用
    （即它本身，即便在展开 + 的定义后也无法被化简），因此 \coqdoctac{simpl} 会留下它。 

 此时有两种方法可以继续。一种是用 \coqdoctac{destruct} \coqdocvariable{m} 将证明分为两种情况，
    每一种都关注于更具体的 \coqdocvariable{m}（\coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} vs \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvar{\_}）。在这两种情况下，
    \coqref{LF.Tactics.bar}{\coqdocdefinition{bar}} 中的 \coqdockw{match} 可以继续了，证明则很容易完成。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fact} \coqdef{LF.Tactics.silly fact 2}{silly\_fact\_2}{\coqdoclemma{silly\_fact\_2}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqref{LF.Tactics.bar}{\coqdocdefinition{bar}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Tactics.bar}{\coqdocdefinition{bar}} (\coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1) \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{m} \coqdocvar{eqn}:\coqdocvar{E}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这种方法是可行的，不过它依赖于我们能发现隐藏在 \coqref{LF.Tactics.bar}{\coqdocdefinition{bar}} 中的 \coqdockw{match}
    阻碍了证明的进展。 

 一种更直白的方式就是明确地告诉 Coq 去展开 \coqref{LF.Tactics.bar}{\coqdocdefinition{bar}}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fact} \coqdef{LF.Tactics.silly fact 2'}{silly\_fact\_2'}{\coqdoclemma{silly\_fact\_2'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqref{LF.Tactics.bar}{\coqdocdefinition{bar}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Tactics.bar}{\coqdocdefinition{bar}} (\coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1) \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqref{LF.Tactics.bar}{\coqdocdefinition{bar}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在很明显，我们在 = 两边的 \coqdockw{match} 上都卡住了，不用多想就能用
    \coqdoctac{destruct} 来结束证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{m} \coqdocvar{eqn}:\coqdocvar{E}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{对复合表达式使用 \texorpdfstring{\protect\coqdoctac{destruct}}{destruct}}



 我们已经见过许多通过 \coqdoctac{destruct} 进行情况分析来处理一些变量的值了。
    有时我们需要根据某些\textit{'表达式'}的结果的情况来进行推理。我们也可以用
    \coqdoctac{destruct} 来做这件事。


    下面是一些例子：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Tactics.sillyfun}{sillyfun}{\coqdocdefinition{sillyfun}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{if} \coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 3 \coqdockw{then} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{else} \coqdockw{if} \coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 5 \coqdockw{then} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{else} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.sillyfun false}{sillyfun\_false}{\coqdoclemma{sillyfun\_false}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Tactics.sillyfun}{\coqdocdefinition{sillyfun}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{unfold} \coqref{LF.Tactics.sillyfun}{\coqdocdefinition{sillyfun}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 3) \coqdocvar{eqn}:\coqdocvar{E1}.\coqdoceol
\coqdocindent{2.00em}
-  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
-  \coqdoctac{destruct} (\coqdocvar{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 5) \coqdocvar{eqn}:\coqdocvar{E2}.\coqdoceol
\coqdocindent{3.00em}
+  \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
+  \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在前面的证明中展开 \coqref{LF.Tactics.sillyfun}{\coqdocdefinition{sillyfun}} 后，我们发现卡在
    \coqdockw{if} (\coqdocvariable{n} =? 3) \coqdockw{then} ... \coqdockw{else} ... 上了。但由于 \coqdocvariable{n} 要么等于 3
    要么不等于，因此我们可以用 \coqdoctac{destruct} (\coqref{LF.Basics.eqb}{\coqdocdefinition{eqb}} \coqdocvariable{n} 3) 来对这两种情况进行推理。


    通常，\coqdoctac{destruct} 策略可用于对任何计算结果进行情况分析。如果 \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}}
    是某个表达式，其类型为归纳定义的类型 \coqdocvariable{T}，那么对于 \coqdocvariable{T} 的每个构造子
    \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}}，\coqdoctac{destruct} \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} 都会生成一个子目标，其中（即目标和上下文中）所有的
    \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} 都会被替换成 \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}}。

\paragraph{练习：3 星, standard, optional (combine\_split)}




    以下是 \coqdoclibrary{Poly} 一章中出现过的 \coqdoctac{split} 函数的实现： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Tactics.split}{split}{\coqdocdefinition{split}} \{\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}\} (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} (\coqdocvariable{X}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqdocvariable{Y}))\coqdoceol
\coqdocindent{7.50em}
: \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{(}}\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{)}} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{(}}\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{Y}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{)}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvar{x}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqdocvar{y}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{t} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{match} \coqref{LF.Tactics.split}{\coqdocdefinition{split}} \coqdocvar{t} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvar{lx}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqdocvar{ly}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}} \ensuremath{\Rightarrow} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{lx}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqdocvar{y} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{ly}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
请证明 \coqdoctac{split} 和 \coqref{LF.Poly.combine}{\coqdocdefinition{combine}} 在以下概念下互为反函数： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.combine split}{combine\_split}{\coqdoclemma{combine\_split}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X} \coqdocvar{Y} (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} (\coqdocvariable{X} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{Y})) \coqdocvar{l1} \coqdocvar{l2},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Tactics.split}{\coqdocdefinition{split}} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvariable{l1}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqdocvariable{l2}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.combine}{\coqdocdefinition{combine}} \coqdocvariable{l1} \coqdocvariable{l2} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 \coqdoctac{destruct} 策略的 \coqdocvar{eqn}: 部分是可选的：目前，我们大部分时间都会包含它，
    只是为了文档的目的。


    然而在用 \coqdoctac{destruct} 结构复合表达式时，\coqdocvar{eqn}: 记录的信息是十分关键的：
    如果我们丢弃它，那么 \coqdoctac{destruct} 会擦除我们完成证明时所需的信息。


    例如，假设函数 \coqref{LF.Tactics.sillyfun1}{\coqdocdefinition{sillyfun1}} 定义如下： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Tactics.sillyfun1}{sillyfun1}{\coqdocdefinition{sillyfun1}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{if} \coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 3 \coqdockw{then} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{else} \coqdockw{if} \coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 5 \coqdockw{then} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{else} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now suppose that we want to convince Coq that \coqref{LF.Tactics.sillyfun1}{\coqdocdefinition{sillyfun1}} \coqdocvariable{n}
    yields \coqref{LF.Basics.true}{\coqdocconstructor{true}} only when \coqdocvariable{n} is odd.  If we start the proof like
    this (with no \coqdocvar{eqn}: on the \coqdoctac{destruct})... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.sillyfun1 odd FAILED}{sillyfun1\_odd\_FAILED}{\coqdoclemma{sillyfun1\_odd\_FAILED}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Tactics.sillyfun1}{\coqdocdefinition{sillyfun1}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{eq}. \coqdoctac{unfold} \coqref{LF.Tactics.sillyfun1}{\coqdocdefinition{sillyfun1}} \coqdoctac{in} \coqdocvar{eq}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 3).\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
... then we are stuck at this point because the context does
    not contain enough information to prove the goal!  The problem is
    that the substitution performed by \coqdoctac{destruct} is quite brutal --
    in this case, it thows away every occurrence of \coqdocvariable{n} =? 3, but we
    need to keep some memory of this expression and how it was
    destructed, because we need to be able to reason that, since \coqdocvariable{n} =?
    3 = \coqref{LF.Basics.true}{\coqdocconstructor{true}} in this branch of the case analysis, it must be that \coqdocvariable{n}
    = 3, from which it follows that \coqdocvariable{n} is odd.


    What we want here is to substitute away all existing occurences of
    \coqdocvariable{n} =? 3, but at the same time add an equation to the context that
    records which case we are in.  This is precisely what the \coqdocvar{eqn}:
    qualifier does. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.sillyfun1 odd}{sillyfun1\_odd}{\coqdoclemma{sillyfun1\_odd}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Tactics.sillyfun1}{\coqdocdefinition{sillyfun1}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{eq}. \coqdoctac{unfold} \coqref{LF.Tactics.sillyfun1}{\coqdocdefinition{sillyfun1}} \coqdoctac{in} \coqdocvar{eq}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 3) \coqdocvar{eqn}:\coqdocvar{Heqe3}.\coqdoceol
\coqdocindent{2.00em}
-  \coqdoctac{apply} \coqref{LF.Tactics.eqb true}{\coqdocaxiom{eqb\_true}} \coqdoctac{in} \coqdocvar{Heqe3}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{Heqe3}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
- \coqdoceol
\coqdocindent{2.50em}
\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} (\coqdocvar{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 5) \coqdocvar{eqn}:\coqdocvar{Heqe5}.\coqdoceol
\coqdocindent{4.00em}
+ \coqdoceol
\coqdocindent{5.00em}
\coqdoctac{apply} \coqref{LF.Tactics.eqb true}{\coqdocaxiom{eqb\_true}} \coqdoctac{in} \coqdocvar{Heqe5}.\coqdoceol
\coqdocindent{5.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{Heqe5}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{4.00em}
+  \coqdoctac{discriminate} \coqdocvar{eq}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard (destruct\_eqn\_practice)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.bool fn applied thrice}{bool\_fn\_applied\_thrice}{\coqdoclemma{bool\_fn\_applied\_thrice}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{f} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{b} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{f} (\coqdocvariable{f} (\coqdocvariable{f} \coqdocvariable{b})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{f} \coqdocvariable{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{复习}



 现在我们已经见过 Coq 中最基础的策略了。未来的章节中我们还会介绍更多，
    之后我们会看到一些更加强大的\textit{'自动化'}策略，它能让 Coq 帮我们处理底层的细节。
    不过基本上我们已经有了完成工作所需的东西。


    下面是我们已经见过的：



\begin{itemize}
\item  \coqdoctac{intros}：将前提/变量从证明目标移到上下文中



\item  \coqdoctac{reflexivity}：（当目标形如 \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} = \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} 时）结束证明



\item  \coqdoctac{apply}：用前提、引理或构造子证明目标



\item  \coqdoctac{apply}... \coqdoctac{in} \coqdocvariable{H}：将前提、引理或构造子应用到上下文中的假设上（正向推理）



\item  \coqdoctac{apply}... \coqdockw{with}...：为无法被模式匹配确定的变量显式指定值



\item  \coqdoctac{simpl}：化简目标中的计算



\item  \coqdoctac{simpl} \coqdoctac{in} \coqdocvariable{H}：化简前提中的计算



\item  \coqdoctac{rewrite}：使用相等关系假设（或引理）来改写目标



\item  \coqdoctac{rewrite} ... \coqdoctac{in} \coqdocvariable{H}：使用相等关系假设（或引理）来改写前提



\item  \coqdoctac{symmetry}：将形如 \coqdocvariable{t}=\coqdocvar{u} 的目标改为 \coqdocvar{u}=\coqdocvariable{t}



\item  \coqdoctac{symmetry} \coqdoctac{in} \coqdocvariable{H}：将形如 \coqdocvariable{t}=\coqdocvar{u} 的前提改为 \coqdocvar{u}=\coqdocvariable{t}



\item  \coqdoctac{unfold}：用目标中的右式替换定义的常量



\item  \coqdoctac{unfold}... \coqdoctac{in} \coqdocvariable{H}：用前提中的右式替换定义的常量



\item  \coqdoctac{destruct}... \coqdockw{as}...：对归纳定义类型的值进行情况分析



\item  \coqdoctac{destruct}... \coqdocvar{eqn}:...：为添加到上下文中的等式指定名字，
        记录情况分析的结果



\item  \coqdoctac{induction}... \coqdockw{as}...: 对归纳定义类型的值进行归纳



\item  \coqdoctac{injection}: reason by injectivity on equalities
        between values of inductively defined types



\item  \coqdoctac{discriminate}: reason by disjointness of constructors on
        equalities between values of inductively defined types



\item  \coqdoctac{assert} (\coqdocvariable{H}: \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}})（或 \coqdoctac{assert} (\coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}}) \coqdockw{as} \coqdocvariable{H}）：引入“局部引理”\coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}}
        并称之为 \coqdocvariable{H}



\item  \coqdoctac{generalize} \coqdoctac{dependent} \coqdocvariable{x}：将变量 \coqdocvariable{x}（以及任何依赖它的东西）
        从上下文中移回目标公式内的前提中 
\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{附加练习}



\paragraph{练习：3 星, standard (eqb\_sym)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.eqb sym}{eqb\_sym}{\coqdoclemma{eqb\_sym}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{m}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{m} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{n}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, advanced, optional (eqb\_sym\_informal)}




    根据前面你对该引理的形式化证明，给出与它对应的非形式化证明：


   定理：对于任何自然数 \coqdocvariable{n} \coqdocvariable{m}，\coqdocvariable{n} =? \coqdocvariable{m} = \coqdocvariable{m} =? \coqdocvariable{n}.


   证明： \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：3 星, standard, optional (eqb\_trans)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.eqb trans}{eqb\_trans}{\coqdoclemma{eqb\_trans}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{m} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, advanced (split\_combine)}




    在前面的练习中，我们证明了对于所有序对的列表，\coqref{LF.Poly.combine}{\coqdocdefinition{combine}} 是 \coqdoctac{split}
    的反函数。你如何形式化陈述 \coqdoctac{split} 是 \coqref{LF.Poly.combine}{\coqdocdefinition{combine}} 的反函数？何时此性质成立？


    请完成下面 \coqref{LF.Tactics.split combine statement}{\coqdocdefinition{split\_combine\_statement}} 的定义，其性质指出 \coqdoctac{split}
    是 \coqref{LF.Poly.combine}{\coqdocdefinition{combine}} 的反函数。之后，证明该性质成立。（除必要的 \coqdoctac{intros}
    之外，不要进行更多的 \coqdoctac{intros}，以此来保证你的归纳假设的一般性。
    提示：你需要 \coqdocvariable{l1} 和 \coqdocvariable{l2} 的什么性质来保证
    \coqdoctac{split} (\coqref{LF.Poly.combine}{\coqdocdefinition{combine}} \coqdocvariable{l1} \coqdocvariable{l2}) = (\coqdocvariable{l1},\coqdocvariable{l2}) 成立？） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Tactics.split combine statement}{split\_combine\_statement}{\coqdocdefinition{split\_combine\_statement}} : \coqdockw{Prop}\coqdoceol
\coqdocindent{1.00em}
\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.split combine}{split\_combine}{\coqdoclemma{split\_combine}} : \coqref{LF.Tactics.split combine statement}{\coqdocaxiom{split\_combine\_statement}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Tactics.manual grade for split combine}{manual\_grade\_for\_split\_combine}{\coqdocdefinition{manual\_grade\_for\_split\_combine}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, advanced (filter\_exercise)}




    本练习有点难度。为你的归纳假设的形式花点心思。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.filter exercise}{filter\_exercise}{\coqdoclemma{filter\_exercise}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{test} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}})\coqdoceol
\coqdocindent{14.50em}
(\coqdocvar{x} : \coqdocvariable{X}) (\coqdocvar{l} \coqdocvar{lf} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{2.50em}
\coqref{LF.Poly.filter}{\coqdocdefinition{filter}} \coqdocvariable{test} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{x} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{lf} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{2.50em}
\coqdocvariable{test} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：4 星, advanced, recommended (forall\_exists\_challenge)}




    定义两个递归的 \coqdocvar{Fixpoints}，\coqref{LF.Tactics.forallb}{\coqdocdefinition{forallb}} 和 \coqref{LF.Tactics.existsb}{\coqdocdefinition{existsb}}。
    第一个检查列表中的每一个元素是否均满足给定的断言：


      forallb oddb 1;3;5;7;9 = true


      forallb negb \coqref{LF.Basics.false}{\coqdocconstructor{false}};\coqref{LF.Basics.false}{\coqdocconstructor{false}} = true


      forallb evenb 0;2;4;5 = false


      forallb (eqb 5) \ensuremath{\Box} = true


    第二个检查列表中是否存在一个元素满足给定的断言：


      existsb (eqb 5) 0;2;3;6 = false


      existsb (andb true) \coqref{LF.Basics.true}{\coqdocconstructor{true}};\coqref{LF.Basics.true}{\coqdocconstructor{true}};\coqref{LF.Basics.false}{\coqdocconstructor{false}} = true


      existsb oddb 1;0;0;0;0;3 = true


      existsb evenb \ensuremath{\Box} = false


    接着，用 \coqref{LF.Tactics.forallb}{\coqdocdefinition{forallb}} 和 \coqref{LF.Basics.negb}{\coqdocdefinition{negb}} 定义一个 \coqref{LF.Tactics.existsb}{\coqdocdefinition{existsb}} 的非递归版本，名为 \coqref{LF.Tactics.existsb'}{\coqdocdefinition{existsb'}}。


    最后，证明定理 \coqref{LF.Tactics.existsb existsb'}{\coqdoclemma{existsb\_existsb'}} 指出 \coqref{LF.Tactics.existsb'}{\coqdocdefinition{existsb'}} 和 \coqref{LF.Tactics.existsb}{\coqdocdefinition{existsb}} 的行为相同。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Tactics.forallb}{forallb}{\coqdocdefinition{forallb}} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{test} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Tactics.test forallb 1}{test\_forallb\_1}{\coqdocdefinition{test\_forallb\_1}} : \coqref{LF.Tactics.forallb}{\coqdocaxiom{forallb}} \coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}7\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}9\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Tactics.test forallb 2}{test\_forallb\_2}{\coqdocdefinition{test\_forallb\_2}} : \coqref{LF.Tactics.forallb}{\coqdocaxiom{forallb}} \coqref{LF.Basics.negb}{\coqdocdefinition{negb}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Tactics.test forallb 3}{test\_forallb\_3}{\coqdocdefinition{test\_forallb\_3}} : \coqref{LF.Tactics.forallb}{\coqdocaxiom{forallb}} \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}0\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Tactics.test forallb 4}{test\_forallb\_4}{\coqdocdefinition{test\_forallb\_4}} : \coqref{LF.Tactics.forallb}{\coqdocaxiom{forallb}} (\coqref{LF.Basics.eqb}{\coqdocdefinition{eqb}} 5) \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Tactics.existsb}{existsb}{\coqdocdefinition{existsb}} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{test} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Tactics.test existsb 1}{test\_existsb\_1}{\coqdocdefinition{test\_existsb\_1}} : \coqref{LF.Tactics.existsb}{\coqdocaxiom{existsb}} (\coqref{LF.Basics.eqb}{\coqdocdefinition{eqb}} 5) \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}0\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Tactics.test existsb 2}{test\_existsb\_2}{\coqdocdefinition{test\_existsb\_2}} : \coqref{LF.Tactics.existsb}{\coqdocaxiom{existsb}} (\coqref{LF.Basics.andb}{\coqdocdefinition{andb}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}) \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Tactics.test existsb 3}{test\_existsb\_3}{\coqdocdefinition{test\_existsb\_3}} : \coqref{LF.Tactics.existsb}{\coqdocaxiom{existsb}} \coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Tactics.test existsb 4}{test\_existsb\_4}{\coqdocdefinition{test\_existsb\_4}} : \coqref{LF.Tactics.existsb}{\coqdocaxiom{existsb}} \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Tactics.existsb'}{existsb'}{\coqdocdefinition{existsb'}} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{test} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Tactics.existsb existsb'}{existsb\_existsb'}{\coqdoclemma{existsb\_existsb'}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{test} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Tactics.existsb}{\coqdocaxiom{existsb}} \coqdocvariable{test} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Tactics.existsb'}{\coqdocaxiom{existsb'}} \coqdocvariable{test} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.Poly}{Library }{LF.Poly}

\begin{coqdoccode}
\end{coqdoccode}
\section{Poly: 多态与高阶函数}

\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Set} \coqdocvar{Warnings} "-notation-overridden,-parsing".\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Export} \coqref{LF.Lists}{\coqdoclibrary{Lists}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{多态}



 在本章中，我们会继续发展函数式编程的基本概念，其中最关键的新概念就是
    \textit{'多态'}（在所处理的数据类型上抽象出函数）和\textit{'高阶函数'}（函数作为数据）。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{多态列表}



 在上一章中，我们使用了只包含数的列表。很明显，
    有趣的程序还需要能够处理其它元素类型的列表，如字符串列表、布尔值列表、
    列表的列表等等。我们\textit{'可以'}分别为它们定义新的归纳数据类型，例如... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Poly.boollist}{boollist}{\coqdocinductive{boollist}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Poly.bool nil}{bool\_nil}{\coqdocconstructor{bool\_nil}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Poly.bool cons}{bool\_cons}{\coqdocconstructor{bool\_cons}} (\coqdocvar{b} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{l} : \coqref{LF.Poly.boollist}{\coqdocinductive{boollist}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
...不过这样很快就会变得乏味。
    部分原因在于我们必须为每种数据类型都定义不同的构造子，
    然而主因还是我们必须为每种数据类型再重新定义一遍所有的列表处理函数
    （ \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}}、\coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} 等）以及它们所有的性质（\coqref{LF.Lists.NatList.rev length}{\coqdoclemma{rev\_length}}、\coqref{LF.Lists.NatList.app assoc}{\coqdoclemma{app\_assoc}} 等）。 

 为避免这些重复，Coq 支持定义\textit{'多态'}归纳类型。
    例如，以下就是\textit{'多态列表'}数据类型。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Poly.list}{list}{\coqdocinductive{list}} (\coqdocvar{X}:\coqdockw{Type}) : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Poly.nil}{nil}{\coqdocconstructor{nil}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Poly.cons}{cons}{\coqdocconstructor{cons}} (\coqdocvar{x} : \coqdocvariable{X}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这和上一章中 \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}} 的定义基本一样，只是将 \coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 构造子的
    \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 参数换成了任意的类型 \coqref{LF.Imp.X}{\coqdocdefinition{X}}，函数头的第一行添加了 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 的绑定，
    而构造子类型中的 \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}} 则换成了 \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}}。（我们可以重用构造子名
    \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} 和 \coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}}，因为之前定义的 \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}} 在当前作用之外的一个 \coqdockw{Module} 中。）


    \coqref{LF.Poly.list}{\coqdocinductive{list}} 本身又是什么类型？一种不错的思路就是把 \coqref{LF.Poly.list}{\coqdocinductive{list}} 当做从 \coqdockw{Type}
    类型到 \coqdockw{Inductive} 归纳定义的\textit{'函数'}；或者换种更简明的思路，即 \coqref{LF.Poly.list}{\coqdocinductive{list}}
    是个从 \coqdockw{Type} 类型到 \coqdockw{Type} 类型的函数。对于任何特定的类型 \coqref{LF.Imp.X}{\coqdocdefinition{X}}，
    类型 \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} 是一个 \coqdockw{Inductive} 归纳定义的，元素类型为 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 的列表的集合。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.Poly.list}{\coqdocinductive{list}} : \coqdockw{Type} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqref{LF.Poly.list}{\coqdocinductive{list}} 的定义中的参数 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 自动
    成为构造子 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} 和 \coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 的参数 —— 也就是说，\coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} 和 \coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 在这里是多态
    的构造子；现在我们调用它们的时候必须要提供一个参数，就是它们要构造的列表的具
    体类型。例如，\coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 构造的是 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 类型的空列表。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqref{LF.Poly.nil}{\coqdocconstructor{nil}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 与此类似，它将类型为 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 的元素添加到类型为
    \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 的列表中。以下示例构造了一个只包含自然数 3 的列表： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} 3 (\coqref{LF.Poly.nil}{\coqdocconstructor{nil}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})) : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} 的类型会是什么呢？也许我们可以（根据定义）说它是 \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}}，
    不过这样它就不是接受 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 返回 \coqref{LF.Poly.list}{\coqdocinductive{list}} 的函数了。再提出一种：\coqdockw{Type} \ensuremath{\rightarrow} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}}
    并没有解释 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 是什么，(\coqref{LF.Imp.X}{\coqdocdefinition{X}} : \coqdockw{Type}) \ensuremath{\rightarrow} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} 则比较接近。
    Coq 对这种情况的记法为 \coqdockw{\ensuremath{\forall}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} : \coqdockw{Type}, \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}}： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.Poly.nil}{\coqdocconstructor{nil}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X} : \coqdockw{Type}, \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
类似地，定义中 \coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 的类型看起来像 \coqref{LF.Imp.X}{\coqdocdefinition{X}} \ensuremath{\rightarrow} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \ensuremath{\rightarrow} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}}
    然而以上述约定来解释 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 的含义则可以得到类型
    \coqdockw{\ensuremath{\forall}} \coqref{LF.Imp.X}{\coqdocdefinition{X}}, \coqref{LF.Imp.X}{\coqdocdefinition{X}} \ensuremath{\rightarrow} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \ensuremath{\rightarrow} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.Poly.cons}{\coqdocconstructor{cons}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X} : \coqdockw{Type}, \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（关于记法的附注：在 .\coqdocvariable{v} 文件中，量词“forall”会写成字母的形式，
    而在生成的 HTML 和一些设置了显示控制的 IDE 中，\coqdockw{\ensuremath{\forall}}
    通常会渲染成一般的“倒 A”数学符号，虽然你偶尔还是会看到英文拼写的
    “forall”。这只是排版上的效果，它们的含义没有任何区别。） 

 如果在每次使用列表构造子时，都要为它提供类型参数，那样会很麻烦。
    不过我们很快就会看到如何省去这种麻烦。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} 2 (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} 1 (\coqref{LF.Poly.nil}{\coqdocconstructor{nil}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})))\coqdoceol
\coqdocindent{3.00em}
: \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在我们可以回过头来定义之前写下的列表处理函数的多态版本了。
    例如 \coqdoctac{repeat}：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Poly.repeat}{repeat}{\coqdocdefinition{repeat}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{x} : \coqdocvariable{X}) (\coqdocvar{count} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{count} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} 0 \ensuremath{\Rightarrow} \coqref{LF.Poly.nil}{\coqdocconstructor{nil}} \coqdocvariable{X}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{count'} \ensuremath{\Rightarrow} \coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqdocvariable{X} \coqdocvariable{x} (\coqref{LF.Poly.repeat}{\coqdocdefinition{repeat}} \coqdocvariable{X} \coqdocvariable{x} \coqdocvar{count'})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
同 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} 与 \coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 一样，我们可以通过将 \coqdoctac{repeat}
    应用到一个类型、一个该类型的元素以及一个数字来使用它： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test repeat1}{test\_repeat1}{\coqdocdefinition{test\_repeat1}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.repeat}{\coqdocdefinition{repeat}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} 4 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} 4 (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} 4 (\coqref{LF.Poly.nil}{\coqdocconstructor{nil}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
要用 \coqdoctac{repeat} 构造其它种类的列表，
    我们只需通过对应类型的参数将它实例化即可： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test repeat2}{test\_repeat2}{\coqdocdefinition{test\_repeat2}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.repeat}{\coqdocdefinition{repeat}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}} \coqref{LF.Basics.false}{\coqdocconstructor{false}} 1 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}} \coqref{LF.Basics.false}{\coqdocconstructor{false}} (\coqref{LF.Poly.nil}{\coqdocconstructor{nil}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard (mumble\_grumble)}




    考虑以下两个归纳定义的类型： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Poly.MumbleGrumble}{MumbleGrumble}{\coqdocmodule{MumbleGrumble}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Poly.MumbleGrumble.mumble}{mumble}{\coqdocinductive{mumble}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Poly.MumbleGrumble.a}{a}{\coqdocconstructor{a}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Poly.MumbleGrumble.b}{b}{\coqdocconstructor{b}} (\coqdocvar{x} : \coqref{LF.Poly.mumble}{\coqdocinductive{mumble}}) (\coqdocvar{y} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Poly.MumbleGrumble.c}{c}{\coqdocconstructor{c}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Poly.MumbleGrumble.grumble}{grumble}{\coqdocinductive{grumble}} (\coqdocvar{X}:\coqdockw{Type}) : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Poly.MumbleGrumble.d}{d}{\coqdocconstructor{d}} (\coqdocvar{m} : \coqref{LF.Poly.MumbleGrumble.mumble}{\coqdocinductive{mumble}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Poly.MumbleGrumble.e}{e}{\coqdocconstructor{e}} (\coqdocvar{x} : \coqdocvariable{X}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
对于某个类型 \coqref{LF.Imp.X}{\coqdocdefinition{X}}，以下哪些是 \coqref{LF.Poly.MumbleGrumble.grumble}{\coqdocinductive{grumble}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} 良定义的元素？
    （在各选项后填“是”或“否”。）

\begin{itemize}
\item  \coqref{LF.Poly.MumbleGrumble.d}{\coqdocconstructor{d}} (\coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 5)

\item  \coqref{LF.Poly.MumbleGrumble.d}{\coqdocconstructor{d}} \coqref{LF.Poly.MumbleGrumble.mumble}{\coqdocinductive{mumble}} (\coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 5)

\item  \coqref{LF.Poly.MumbleGrumble.d}{\coqdocconstructor{d}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}} (\coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 5)

\item  \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}

\item  \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} \coqref{LF.Poly.MumbleGrumble.mumble}{\coqdocinductive{mumble}} (\coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 0)

\item  \coqref{LF.Poly.MumbleGrumble.e}{\coqdocconstructor{e}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}} (\coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 0)

\item  \coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} 
\end{itemize}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{End} \coqref{LF.Poly.MumbleGrumble}{\coqdocmodule{MumbleGrumble}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.manual grade for mumble grumble}{manual\_grade\_for\_mumble\_grumble}{\coqdocdefinition{manual\_grade\_for\_mumble\_grumble}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsubsection{类型标注的推断}



 我们再写一遍 \coqdoctac{repeat} 的定义，不过这次不指定任何参数的类型。
    Coq 还会接受它么？ \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Poly.repeat'}{repeat'}{\coqdocdefinition{repeat'}} \coqdocvar{X} \coqdocvar{x} \coqdocvar{count} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{count} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} 0        \ensuremath{\Rightarrow} \coqref{LF.Poly.nil}{\coqdocconstructor{nil}} \coqdocvariable{X}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{count'} \ensuremath{\Rightarrow} \coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqdocvariable{X} \coqdocvariable{x} (\coqref{LF.Poly.repeat'}{\coqdocdefinition{repeat'}} \coqdocvariable{X} \coqdocvariable{x} \coqdocvar{count'})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
确实会。我们来看看 Coq 赋予了 \coqref{LF.Poly.repeat'}{\coqdocdefinition{repeat'}} 什么类型： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.Poly.repeat'}{\coqdocdefinition{repeat'}}\coqdoceol
\coqdocindent{1.00em}
: \coqdockw{\ensuremath{\forall}} \coqdocvar{X} : \coqdockw{Type}, \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}.\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqref{LF.Poly.repeat}{\coqdocdefinition{repeat}}\coqdoceol
\coqdocindent{1.00em}
: \coqdockw{\ensuremath{\forall}} \coqdocvar{X} : \coqdockw{Type}, \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
它与 \coqdoctac{repeat} 的类型完全一致。Coq 可以使用\textit{'类型推断'}
    基于它们的使用方式来推出 \coqref{LF.Imp.X}{\coqdocdefinition{X}}、\coqdocvariable{x} 和 \coqref{LF.Lists.NatList.count}{\coqdocdefinition{count}} 一定是什么类型。例如，
    由于 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 是作为 \coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 的参数使用的，因此它必定是个 \coqdockw{Type} 类型，
    因为 \coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 期望一个 \coqdockw{Type} 作为其第一个参数，而用 0 和 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 来匹配
    \coqref{LF.Lists.NatList.count}{\coqdocdefinition{count}} 意味着它必须是个 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}，诸如此类。


    这种强大的功能意味着我们不必总是在任何地方都显式地写出类型标注，
    不过显式的类型标注对于文档和完整性检查来说仍然非常有用，
    因此我们仍会继续使用它。在代码中使用类型标注时，你应当把握好一个度，
    太多会导致混乱并分散注意力，太少则会迫使读者为理解你的代码而在大脑中进行类型推断。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsubsection{类型参数的推断}



 要使用多态函数，我们需要为其参数再额外传入一个或更多类型。
    例如，前面 \coqdoctac{repeat} 函数体中的递归调用必须传递类型 \coqref{LF.Imp.X}{\coqdocdefinition{X}}。不过由于
    \coqdoctac{repeat} 的第二个参数为 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 类型的元素，第一个参数明显只能是 \coqref{LF.Imp.X}{\coqdocdefinition{X}}，
    既然如此，我们何必显式地写出它呢？


    幸运的是，Coq 允许我们避免这种冗余。在任何我们可以写类型参数的地方，我们都可
    以将类型参数写为 “洞” \coqdocvar{\_}，可以看做是说 “请 Coq 自行找出这里应该填什么。”
    更确切地说，当 Coq 遇到 \coqdocvar{\_} 时，它会尝试\textit{'统一'}所有的局部变量信息，
    包括函数应当应用到的类型，其它参数的类型，以及应用函数的上下文中期望的类型，
    以此来确定 \coqdocvar{\_} 处应当填入的具体类型。


    这听起来很像类型标注推断。实际上，这两种个过程依赖于同样的底层机制。
    除了简单地忽略函数中某些参数的类型：


      repeat' X x count : list X :=


    我们还可以将类型换成洞：


      repeat' (X : \_) (x : \_) (count : \_) : list X :=


    以此来告诉 Coq 要尝试推断出缺少的信息。


    Using holes, the \coqdoctac{repeat} function can be written like this: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Poly.repeat''}{repeat'{}'}{\coqdocdefinition{repeat'{}'}} \coqdocvar{X} \coqdocvar{x} \coqdocvar{count} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{count} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} 0        \ensuremath{\Rightarrow} \coqref{LF.Poly.nil}{\coqdocconstructor{nil}} \coqdocvar{\_}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{count'} \ensuremath{\Rightarrow} \coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqdocvar{\_} \coqdocvariable{x} (\coqref{LF.Poly.repeat''}{\coqdocdefinition{repeat'{}'}} \coqdocvar{\_} \coqdocvariable{x} \coqdocvar{count'})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在此例中，我们写出 \coqdocvar{\_} 并没有省略多少 \coqref{LF.Imp.X}{\coqdocdefinition{X}}。然而在很多情况下，
    这对减少击键次数和提高可读性还是很有效的。例如，假设我们要写下一个包含数字
    1、2 和 3 的列表，此时不必写成这样： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.list123}{list123}{\coqdocdefinition{list123}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} 1 (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} 2 (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} 3 (\coqref{LF.Poly.nil}{\coqdocconstructor{nil}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}))).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
……我们可以用洞来这样写： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.list123'}{list123'}{\coqdocdefinition{list123'}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqdocvar{\_} 1 (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqdocvar{\_} 2 (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqdocvar{\_} 3 (\coqref{LF.Poly.nil}{\coqdocconstructor{nil}} \coqdocvar{\_}))).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{隐式参数}



 我们甚至可以通过告诉 Coq \textit{'总是'}推断给定函数的类型参数来在大多数情况下
    直接避免写 \coqdocvar{\_}。


    \coqdocvar{Arguments} 用于指令指定函数或构造子的名字并列出其参数名，
    花括号中的任何参数都会被视作隐式参数。（如果定义中的某个参数没有名字，
    那么它可以用通配模式 \coqdocvar{\_} 来标记。这种情况常见于构造子中。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Arguments} \coqref{LF.Poly.nil}{\coqdocconstructor{nil}} \{\coqdocvar{X}\}.\coqdoceol
\coqdocnoindent
\coqdocvar{Arguments} \coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \{\coqdocvar{X}\} \coqdocvar{\_} \coqdocvar{\_}.\coqdoceol
\coqdocnoindent
\coqdocvar{Arguments} \coqref{LF.Poly.repeat}{\coqdocdefinition{repeat}} \{\coqdocvar{X}\} \coqdocvar{x} \coqdocvar{count}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在我们完全不用提供类型参数了： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.list123''}{list123'{}'}{\coqdocdefinition{list123'{}'}} := \coqref{LF.Poly.cons}{\coqdocconstructor{cons}} 1 (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} 2 (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} 3 \coqref{LF.Poly.nil}{\coqdocconstructor{nil}})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
此外，我们还可以在定义函数时就声明隐式参数，
    只需要将某个参数两边的圆括号换成花括号。例如： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Poly.repeat'''}{repeat'{}'{}'}{\coqdocdefinition{repeat'{}'{}'}} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{x} : \coqdocvariable{X}) (\coqdocvar{count} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{count} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} 0        \ensuremath{\Rightarrow} \coqref{LF.Poly.nil}{\coqdocconstructor{nil}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{count'} \ensuremath{\Rightarrow} \coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqdocvariable{x} (\coqref{LF.Poly.repeat'''}{\coqdocdefinition{repeat'{}'{}'}} \coqdocvariable{x} \coqdocvar{count'})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（注意我们现在甚至不必在 \coqref{LF.Poly.repeat'''}{\coqdocdefinition{repeat'{}'{}'}} 的递归调用中提供类型参数了，
      实际上提供了反而是无效的，因为 Coq 并不想要它。）


    我们会尽可能使用最后一种风格，不过还会继续在 \coqdockw{Inductive} 构造子中使用显式的
    \coqdocvar{Argument} 声明。原因在于如果将归纳类型的形参标为隐式的话，
    不仅构造子的类型会变成隐式的，类型本身也会变成隐式的。例如，
    考虑以下 \coqref{LF.Poly.list}{\coqdocinductive{list}} 类型的另一种定义： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Poly.list'}{list'}{\coqdocinductive{list'}} \{\coqdocvar{X}:\coqdockw{Type}\} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Poly.nil'}{nil'}{\coqdocconstructor{nil'}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Poly.cons'}{cons'}{\coqdocconstructor{cons'}} (\coqdocvar{x} : \coqdocvariable{X}) (\coqdocvar{l} : \coqref{LF.Poly.list'}{\coqdocinductive{list'}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
由于 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 在包括 \coqref{LF.Poly.list'}{\coqdocinductive{list'}} 本身的\textit{'整个'}归纳定义中都是隐式声明的，
    因此当我们讨论数值、布尔值或其它任何类型的列表时，都只能写 \coqref{LF.Poly.list'}{\coqdocinductive{list'}}，
    而写不了 \coqref{LF.Poly.list'}{\coqdocinductive{list'}} \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}、\coqref{LF.Poly.list'}{\coqdocinductive{list'}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 等等，这样就有点过分了。 

 作为本节的收尾，我们为新的多态列表重新实现几个其它的标准列表函数... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Poly.app}{app}{\coqdocdefinition{app}} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{l1} \coqdocvar{l2} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X})\coqdoceol
\coqdocindent{6.50em}
: (\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l1} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.nil}{\coqdocconstructor{nil}}      \ensuremath{\Rightarrow} \coqdocvariable{l2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqdocvar{h} \coqdocvar{t} \ensuremath{\Rightarrow} \coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqdocvar{h} (\coqref{LF.Poly.app}{\coqdocdefinition{app}} \coqdocvar{t} \coqdocvariable{l2})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Poly.rev}{rev}{\coqdocdefinition{rev}} \{\coqdocvar{X}:\coqdockw{Type}\} (\coqdocvar{l}:\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.nil}{\coqdocconstructor{nil}}      \ensuremath{\Rightarrow} \coqref{LF.Poly.nil}{\coqdocconstructor{nil}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqdocvar{h} \coqdocvar{t} \ensuremath{\Rightarrow} \coqref{LF.Poly.app}{\coqdocdefinition{app}} (\coqref{LF.Poly.rev}{\coqdocdefinition{rev}} \coqdocvar{t}) (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqdocvar{h} \coqref{LF.Poly.nil}{\coqdocconstructor{nil}})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Poly.length}{length}{\coqdocdefinition{length}} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.nil}{\coqdocconstructor{nil}} \ensuremath{\Rightarrow} 0\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqdocvar{\_} \coqdocvar{l'} \ensuremath{\Rightarrow} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvar{l'})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test rev1}{test\_rev1}{\coqdocdefinition{test\_rev1}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.rev}{\coqdocdefinition{rev}} (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} 1 (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} 2 \coqref{LF.Poly.nil}{\coqdocconstructor{nil}})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} 2 (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} 1 \coqref{LF.Poly.nil}{\coqdocconstructor{nil}})\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test rev2}{test\_rev2}{\coqdocdefinition{test\_rev2}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.rev}{\coqdocdefinition{rev}} (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqref{LF.Poly.nil}{\coqdocconstructor{nil}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqref{LF.Poly.nil}{\coqdocconstructor{nil}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test length1}{test\_length1}{\coqdocdefinition{test\_length1}}: \coqref{LF.Poly.length}{\coqdocdefinition{length}} (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} 1 (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} 2 (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} 3 \coqref{LF.Poly.nil}{\coqdocconstructor{nil}}))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 3.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{显式提供类型参数}



 用 \coqdockw{Implicit} 将参数声明为隐式的会有个小问题：Coq
    偶尔会没有足够的局部信息来确定类型参数。此时，我们需要告诉 Coq
    这次我们会显示地给出参数。例如，假设我们写了如下定义： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Fail} \coqdockw{Definition} \coqdef{LF.Poly.mynil}{mynil}{\coqdocdefinition{mynil}} := \coqref{LF.Poly.nil}{\coqdocconstructor{nil}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（\coqdockw{Definition} 前面的 \coqdocvar{Fail} 限定符可用于\textit{'任何'}指令，
    它的作用是确保该指令在执行时确实会失败。如果该指令失败了，Coq
    就会打印出相应的错误信息，不过之后会继续处理文件中剩下的部分。）


    在这里，Coq 给出了一条错误信息，因为它不知道应该为 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} 提供何种类型。
    我们可以为它提供个显式的类型声明来帮助它，这样 Coq 在“应用”\coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}}
    时就有更多可用的信息了： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.mynil}{mynil}{\coqdocdefinition{mynil}} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} := \coqref{LF.Poly.nil}{\coqdocconstructor{nil}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
此外，我们还可以在函数名前加上前缀 @ 来强制将隐式参数变成显式的： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} @\coqref{LF.Poly.nil}{\coqdocconstructor{nil}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X} : \coqdockw{Type}, \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.mynil'}{mynil'}{\coqdocdefinition{mynil'}} := @\coqref{LF.Poly.nil}{\coqdocconstructor{nil}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
使用参数推断和隐式参数，我们可以为列表定义和前面一样的简便记法。
    由于我们让构造子的的类型参数变成了隐式的，因此 Coq
    就知道在我们使用该记法时自动推断它们了。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Poly.:::x '::' x}{"}{"}x :: y" := (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqdocvar{x} \coqdocvar{y})\coqdoceol
\coqdocindent{10.50em}
(\coqdoctac{at} \coqdockw{level} 60, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Poly.:::'[' ']'}{"}{"}[ ]" := \coqref{LF.Poly.nil}{\coqdocconstructor{nil}}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Poly.:::'[' x ';' '..' ';' x ']'}{"}{"}[ x ; .. ; y ]" := (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqdocvar{x} .. (\coqref{LF.Poly.cons}{\coqdocconstructor{cons}} \coqdocvar{y} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}) ..).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Poly.:::x '++' x}{"}{"}x ++ y" := (\coqref{LF.Poly.app}{\coqdocdefinition{app}} \coqdocvar{x} \coqdocvar{y})\coqdoceol
\coqdocindent{10.50em}
(\coqdoctac{at} \coqdockw{level} 60, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在列表就能写成我们希望的方式了： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.list123'''}{list123'{}'{}'}{\coqdocdefinition{list123'{}'{}'}} := \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{练习}



\paragraph{练习：2 星, standard, optional (poly\_exercises)}




    下面是一些简单的练习，和 \coqdoclibrary{Lists} 一章中的一样。
    为了实践多态，请完成下面的证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Poly.app nil r}{app\_nil\_r}{\coqdoclemma{app\_nil\_r}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}), \coqdockw{\ensuremath{\forall}} \coqdocvar{l}:\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{l} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Poly.app assoc}{app\_assoc}{\coqdoclemma{app\_assoc}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{A} (\coqdocvar{l} \coqdocvar{m} \coqdocvar{n}:\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{A}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{l} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{m} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{(}}\coqdocvariable{l} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{m}\coqref{LF.Poly.:::x '++' x}{\coqdocnotation{)}} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Poly.app length}{app\_length}{\coqdoclemma{app\_length}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{l1} \coqdocvar{l2} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.length}{\coqdocdefinition{length}} (\coqdocvariable{l1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{l2}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{l1} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{l2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, optional (more\_poly\_exercises)}




    这儿有些更有趣的东西... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Poly.rev app distr}{rev\_app\_distr}{\coqdoclemma{rev\_app\_distr}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{X} (\coqdocvar{l1} \coqdocvar{l2} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.rev}{\coqdocdefinition{rev}} (\coqdocvariable{l1} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{l2}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.rev}{\coqdocdefinition{rev}} \coqdocvariable{l2} \coqref{LF.Poly.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.Poly.rev}{\coqdocdefinition{rev}} \coqdocvariable{l1}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Poly.rev involutive}{rev\_involutive}{\coqdoclemma{rev\_involutive}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X} : \coqdockw{Type}, \coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.rev}{\coqdocdefinition{rev}} (\coqref{LF.Poly.rev}{\coqdocdefinition{rev}} \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{多态序对}



 按照相同的模式，我们在上一章中给出的数值序对的定义可被推广为
    \textit{'多态序对（Polymorphic Pairs）'}，它通常叫做\textit{'积（Products）'}： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Poly.prod}{prod}{\coqdocinductive{prod}} (\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}) : \coqdockw{Type} :=\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.Poly.pair}{pair}{\coqdocconstructor{pair}} (\coqdocvar{x} : \coqdocvariable{X}) (\coqdocvar{y} : \coqdocvariable{Y}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Arguments} \coqref{LF.Poly.pair}{\coqdocconstructor{pair}} \{\coqdocvar{X}\} \{\coqdocvar{Y}\} \coqdocvar{\_} \coqdocvar{\_}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
和列表一样，我们也可以将类型参数定义成隐式的，
    并以此定义类似的具体记法： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Poly.:::'(' x ',' x ')'}{"}{"}( x , y )" := (\coqref{LF.Poly.pair}{\coqdocconstructor{pair}} \coqdocvar{x} \coqdocvar{y}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们也可以使用 \coqdockw{Notation} 来定义标准的\textit{'积类型（Product Types）'}记法： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Poly.::type scope:x '*' x}{"}{"}X * Y" := (\coqref{LF.Poly.prod}{\coqdocinductive{prod}} \coqdocvar{X} \coqdocvar{Y}) : \coqdocvar{type\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（标注 : \coqdocvar{type\_scope} 会告诉 Coq 该缩写只能在解析类型而非表达式时使用。
      这避免了与乘法符号的冲突。) 

 一开始会很容易混淆 (\coqdocvariable{x},\coqdocvariable{y}) 和 \coqref{LF.Imp.X}{\coqdocdefinition{X}}\ensuremath{\times}\coqref{LF.Imp.Y}{\coqdocdefinition{Y}}。不过要记住 (\coqdocvariable{x},\coqdocvariable{y})
    是一个\textit{'值'}，它由两个其它的值构造得来；而 \coqref{LF.Imp.X}{\coqdocdefinition{X}}\ensuremath{\times}\coqref{LF.Imp.Y}{\coqdocdefinition{Y}} 是一个\textit{'类型'}，
    它由两个其它的类型构造得来。如果 \coqdocvariable{x} 的类型为 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 而 \coqdocvariable{y} 的类型为 \coqref{LF.Imp.Y}{\coqdocdefinition{Y}}，
    那么 (\coqdocvariable{x},\coqdocvariable{y}) 的类型就是 \coqref{LF.Imp.X}{\coqdocdefinition{X}}\ensuremath{\times}\coqref{LF.Imp.Y}{\coqdocdefinition{Y}}。 

 第一元（first）和第二元（second）的射影函数（Projection Functions）
    现在看起来和其它函数式编程语言中的很像了： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.fst}{fst}{\coqdocdefinition{fst}} \{\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}\} (\coqdocvar{p} : \coqdocvariable{X} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{Y}) : \coqdocvariable{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvar{x}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqdocvar{y}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}} \ensuremath{\Rightarrow} \coqdocvar{x}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.snd}{snd}{\coqdocdefinition{snd}} \{\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}\} (\coqdocvar{p} : \coqdocvariable{X} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{Y}) : \coqdocvariable{Y} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvar{x}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqdocvar{y}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}} \ensuremath{\Rightarrow} \coqdocvar{y}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
以下函数接受两个列表，并将它们结合成一个序对的列表。
    在其它函数式语言中，它通常被称作 \coqdocvar{zip}。我们为了与 Coq 的标准库保持一致，
    将它命名为 \coqref{LF.Poly.combine}{\coqdocdefinition{combine}}。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Poly.combine}{combine}{\coqdocdefinition{combine}} \{\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}\} (\coqdocvar{lx} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) (\coqdocvar{ly} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{Y})\coqdoceol
\coqdocindent{5.50em}
: \coqref{LF.Poly.list}{\coqdocinductive{list}} (\coqdocvariable{X}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqdocvariable{Y}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{lx}, \coqdocvariable{ly} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}, \coqdocvar{\_} \ensuremath{\Rightarrow} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{\_}, \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{x} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{tx}, \coqdocvar{y} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{ty} \ensuremath{\Rightarrow} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvar{x}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqdocvar{y}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{(}}\coqref{LF.Poly.combine}{\coqdocdefinition{combine}} \coqdocvar{tx} \coqdocvar{ty}\coqref{LF.Poly.:::x '::' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, standard, optional (combine\_checks)}




    请尝试在纸上回答以下问题并在 Coq 中检验你的解答：

\begin{itemize}
\item  \coqref{LF.Poly.combine}{\coqdocdefinition{combine}} 的类型是什么？（即 \coqdockw{Check} @\coqref{LF.Poly.combine}{\coqdocdefinition{combine}} 会打印出什么？）

\item  以下指令会打印出什么？


        Compute (combine 1;2 \coqref{LF.Basics.false}{\coqdocconstructor{false}};\coqref{LF.Basics.false}{\coqdocconstructor{false}};\coqref{LF.Basics.true}{\coqdocconstructor{true}};\coqref{LF.Basics.true}{\coqdocconstructor{true}}).

\end{itemize}
 \ensuremath{\Box} 

\paragraph{练习：2 星, standard, recommended (split)}




    函数 \coqdoctac{split} 是 \coqref{LF.Poly.combine}{\coqdocdefinition{combine}} 的右逆（right inverse）：
    它接受一个序对的列表并返回一个列表的序对。
    在很多函数式语言中，它被称作 \coqdocvar{unzip}。


    请在下面完成 \coqdoctac{split} 的定义，确保它能够通过给定的单元测试。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Poly.split}{split}{\coqdocdefinition{split}} \{\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}\} (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} (\coqdocvariable{X}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqdocvariable{Y}))\coqdoceol
\coqdocindent{7.50em}
: \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{(}}\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{)}} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{(}}\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{Y}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test split}{test\_split}{\coqdocdefinition{test\_split}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.split}{\coqdocaxiom{split}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}1\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}}\coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}2\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}}\coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{多态候选}



 最后一种要介绍的多态类型是\textit{'多态候选（Polymorphic Options）'},
    它推广了上一章中的 \coqref{LF.Lists.NatList.natoption}{\coqdocinductive{natoption}}（由于我们之后要用标准库中定义的
    \coqref{LF.Poly.OptionPlayground.option}{\coqdocinductive{option}} 版本，因此这里的定义我们把它放在模块中）： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Poly.OptionPlayground}{OptionPlayground}{\coqdocmodule{OptionPlayground}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Poly.OptionPlayground.option}{option}{\coqdocinductive{option}} (\coqdocvar{X}:\coqdockw{Type}) : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Poly.OptionPlayground.Some}{Some}{\coqdocconstructor{Some}} (\coqdocvar{x} : \coqdocvariable{X})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Poly.OptionPlayground.None}{None}{\coqdocconstructor{None}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Arguments} \coqref{LF.Poly.OptionPlayground.Some}{\coqdocconstructor{Some}} \{\coqdocvar{X}\} \coqdocvar{\_}.\coqdoceol
\coqdocnoindent
\coqdocvar{Arguments} \coqref{LF.Poly.OptionPlayground.None}{\coqdocconstructor{None}} \{\coqdocvar{X}\}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.Poly.OptionPlayground}{\coqdocmodule{OptionPlayground}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在我们可以重写 \coqref{LF.Lists.NatList.nth error}{\coqdocdefinition{nth\_error}} 函数来让它适用于任何类型的列表了。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Poly.nth error}{nth\_error}{\coqdocdefinition{nth\_error}} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{9.50em}
: \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqdocvariable{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \ensuremath{\Rightarrow} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{a} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{l'} \ensuremath{\Rightarrow} \coqdockw{if} \coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \coqdockw{then} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvar{a} \coqdockw{else} \coqref{LF.Poly.nth error}{\coqdocdefinition{nth\_error}} \coqdocvar{l'} (\coqexternalref{pred}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{pred}} \coqdocvariable{n})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test nth error1}{test\_nth\_error1}{\coqdocdefinition{test\_nth\_error1}} : \coqref{LF.Poly.nth error}{\coqdocdefinition{nth\_error}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}7\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} 0 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} 4.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test nth error2}{test\_nth\_error2}{\coqdocdefinition{test\_nth\_error2}} : \coqref{LF.Poly.nth error}{\coqdocdefinition{nth\_error}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];[}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]]}} 1 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test nth error3}{test\_nth\_error3}{\coqdocdefinition{test\_nth\_error3}} : \coqref{LF.Poly.nth error}{\coqdocdefinition{nth\_error}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, standard, optional (hd\_error\_poly)}




    请完成上一章中 \coqref{LF.Lists.NatList.hd error}{\coqdocdefinition{hd\_error}} 的多态定义，确保它能通过下方的单元测试。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.hd error}{hd\_error}{\coqdocdefinition{hd\_error}} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqdocvariable{X}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
再说一遍，要强制将隐式参数转为显式参数，我们可以在函数名前使用 @。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} @\coqref{LF.Poly.hd error}{\coqdocaxiom{hd\_error}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X} : \coqdockw{Type}, \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqdocvariable{X}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test hd error1}{test\_hd\_error1}{\coqdocdefinition{test\_hd\_error1}} : \coqref{LF.Poly.hd error}{\coqdocaxiom{hd\_error}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} 1.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test hd error2}{test\_hd\_error2}{\coqdocdefinition{test\_hd\_error2}} : \coqref{LF.Poly.hd error}{\coqdocaxiom{hd\_error}}  \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];[}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]]}}  \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{函数作为数据}



 和大部分现代编程语言一样，特别是“函数式”的语言，包括 OCaml、Haskell、
    Racket、Scala、Clojure 等，Coq 也将函数视作“一等公民（First-Class Citizens）”，
    即允许将它们作为参数传入其它函数、作为结果返回、以及存储在数据结构中等等。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{高阶函数}



 用于操作其它函数的函数通常叫做\textit{'高阶函数'}。以下是简单的示例： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.doit3times}{doit3times}{\coqdocdefinition{doit3times}} \{\coqdocvar{X}:\coqdockw{Type}\} (\coqdocvar{f}:\coqdocvariable{X}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdocvariable{X}) (\coqdocvar{n}:\coqdocvariable{X}) : \coqdocvariable{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{f} (\coqdocvariable{f} (\coqdocvariable{f} \coqdocvariable{n})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这里的参数 \coqdocvariable{f} 本身也是个（从 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 到 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 的）函数，
    \coqref{LF.Poly.doit3times}{\coqdocdefinition{doit3times}} 的函数体将 \coqdocvariable{f} 对某个值 \coqdocvariable{n} 应用三次。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} @\coqref{LF.Poly.doit3times}{\coqdocdefinition{doit3times}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X} : \coqdockw{Type}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{X}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{X}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test doit3times}{test\_doit3times}{\coqdocdefinition{test\_doit3times}}: \coqref{LF.Poly.doit3times}{\coqdocdefinition{doit3times}} \coqref{LF.Basics.minustwo}{\coqdocdefinition{minustwo}} 9 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 3.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test doit3times'}{test\_doit3times'}{\coqdocdefinition{test\_doit3times'}}: \coqref{LF.Poly.doit3times}{\coqdocdefinition{doit3times}} \coqref{LF.Basics.negb}{\coqdocdefinition{negb}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{过滤器}



 下面是个更有用的高阶函数，它接受一个元素类型为 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 的列表和一个
    \coqref{LF.Imp.X}{\coqdocdefinition{X}} 的谓词（即一个从 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 到 \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 的函数），然后“过滤”此列表并返回一个新列表，
    其中仅包含对该谓词返回 \coqref{LF.Basics.true}{\coqdocconstructor{true}} 的元素。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Poly.filter}{filter}{\coqdocdefinition{filter}} \{\coqdocvar{X}:\coqdockw{Type}\} (\coqdocvar{test}: \coqdocvariable{X}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{l}:\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X})\coqdoceol
\coqdocindent{8.00em}
: (\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}     \ensuremath{\Rightarrow} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{t} \ensuremath{\Rightarrow} \coqdockw{if} \coqdocvariable{test} \coqdocvar{h} \coqdockw{then} \coqdocvar{h} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{(}}\coqref{LF.Poly.filter}{\coqdocdefinition{filter}} \coqdocvariable{test} \coqdocvar{t}\coqref{LF.Poly.:::x '::' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{12.00em}
\coqdockw{else}       \coqref{LF.Poly.filter}{\coqdocdefinition{filter}} \coqdocvariable{test} \coqdocvar{t}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
例如，如果我们将 \coqref{LF.Poly.filter}{\coqdocdefinition{filter}} 应用到谓词 \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} 和一个数值列表 \coqdocvariable{l}
    上，那么它就会返回一个只包含 \coqdocvariable{l} 中偶数的列表。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test filter1}{test\_filter1}{\coqdocdefinition{test\_filter1}}: \coqref{LF.Poly.filter}{\coqdocdefinition{filter}} \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.length is 1}{length\_is\_1}{\coqdocdefinition{length\_is\_1}} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{(}}\coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{l}\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{)}} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 1.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test filter2}{test\_filter2}{\coqdocdefinition{test\_filter2}}:\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Poly.filter}{\coqdocdefinition{filter}} \coqref{LF.Poly.length is 1}{\coqdocdefinition{length\_is\_1}}\coqdoceol
\coqdocindent{5.50em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}7\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}8\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}8\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们可以使用 \coqref{LF.Poly.filter}{\coqdocdefinition{filter}} 给出 \coqdoclibrary{Lists} 中 \coqref{LF.Lists.NatList.countoddmembers}{\coqdocdefinition{countoddmembers}}
    函数的简洁的版本。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.countoddmembers'}{countoddmembers'}{\coqdocdefinition{countoddmembers'}} (\coqdocvar{l}:\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.length}{\coqdocdefinition{length}} (\coqref{LF.Poly.filter}{\coqdocdefinition{filter}} \coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} \coqdocvariable{l}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test countoddmembers'1}{test\_countoddmembers'1}{\coqdocdefinition{test\_countoddmembers'1}}:   \coqref{LF.Poly.countoddmembers'}{\coqdocdefinition{countoddmembers'}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 4.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test countoddmembers'2}{test\_countoddmembers'2}{\coqdocdefinition{test\_countoddmembers'2}}:   \coqref{LF.Poly.countoddmembers'}{\coqdocdefinition{countoddmembers'}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}0\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test countoddmembers'3}{test\_countoddmembers'3}{\coqdocdefinition{test\_countoddmembers'3}}:   \coqref{LF.Poly.countoddmembers'}{\coqdocdefinition{countoddmembers'}} \coqref{LF.Poly.nil}{\coqdocconstructor{nil}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{匿名函数}



 在上面这个例子中，我们不得不定义一个名为 \coqref{LF.Poly.length is 1}{\coqdocdefinition{length\_is\_1}} 的函数，
    以便让它能够作为参数传入到 \coqref{LF.Poly.filter}{\coqdocdefinition{filter}} 中，由于该函数可能再也用不到了，
    这有点令人沮丧。我们经常需要传入“一次性”的函数作为参数，之后不会再用，
    而为每个函数取名是十分无聊的。


    幸运的是，有一种更好的方法。我们可以按需随时构造函数而不必在顶层中声明它
    或给它取名。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test anon fun'}{test\_anon\_fun'}{\coqdocdefinition{test\_anon\_fun'}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.doit3times}{\coqdocdefinition{doit3times}} (\coqdockw{fun} \coqdocvar{n} \ensuremath{\Rightarrow} \coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{n}) 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 256.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
表达式 (\coqdockw{fun} \coqdocvariable{n} \ensuremath{\Rightarrow} \coqdocvariable{n} \ensuremath{\times} \coqdocvariable{n}) 可读作“一个给定 \coqdocvariable{n} 并返回 \coqdocvariable{n} \ensuremath{\times} \coqdocvariable{n} 的函数。” 

 以下为使用匿名函数重写的 \coqref{LF.Poly.filter}{\coqdocdefinition{filter}} 示例：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test filter2'}{test\_filter2'}{\coqdocdefinition{test\_filter2'}}:\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Poly.filter}{\coqdocdefinition{filter}} (\coqdockw{fun} \coqdocvar{l} \ensuremath{\Rightarrow} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{(}}\coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{l}\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{)}} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 1)\coqdoceol
\coqdocindent{5.50em}
\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}7\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}8\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}8\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard (filter\_even\_gt7)}




    使用 \coqref{LF.Poly.filter}{\coqdocdefinition{filter}}（而非 \coqdockw{Fixpoint}）来编写 Coq 函数 \coqref{LF.Poly.filter even gt7}{\coqdocdefinition{filter\_even\_gt7}}，
    它接受一个自然数列表作为输入，返回一个只包含大于 7 的偶数的列表。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.filter even gt7}{filter\_even\_gt7}{\coqdocdefinition{filter\_even\_gt7}} (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test filter even gt7 1}{test\_filter\_even\_gt7\_1}{\coqdocdefinition{test\_filter\_even\_gt7\_1}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.filter even gt7}{\coqdocaxiom{filter\_even\_gt7}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}9\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}10\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}12\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}8\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}10\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}12\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}8\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test filter even gt7 2}{test\_filter\_even\_gt7\_2}{\coqdocdefinition{test\_filter\_even\_gt7\_2}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.filter even gt7}{\coqdocaxiom{filter\_even\_gt7}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}19\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}129\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard (partition)}




    使用 \coqref{LF.Poly.filter}{\coqdocdefinition{filter}} 编写一个 Coq 函数 \coqref{LF.Poly.partition}{\coqdocdefinition{partition}}：


      partition : forall X : Type,
                  (X -> bool) -> list X -> list X * list X


   给定一个集合 \coqref{LF.Imp.X}{\coqdocdefinition{X}}、一个类型为 \coqref{LF.Imp.X}{\coqdocdefinition{X}} \ensuremath{\rightarrow} \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 的断言和一个 \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}}，
   \coqref{LF.Poly.partition}{\coqdocdefinition{partition}} 应当返回一个列表的序对。该序对的第一个成员为包含原始列表中
   满足该测试的子列表，而第二个成员为包含不满足该测试的元素的子列表。
   两个子列表中元素的顺序应当与它们在原始列表中的顺序相同。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.partition}{partition}{\coqdocdefinition{partition}} \{\coqdocvar{X} : \coqdockw{Type}\}\coqdoceol
\coqdocindent{10.50em}
(\coqdocvar{test} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}})\coqdoceol
\coqdocindent{10.50em}
(\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X})\coqdoceol
\coqdocindent{9.50em}
: \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test partition1}{test\_partition1}{\coqdocdefinition{test\_partition1}}: \coqref{LF.Poly.partition}{\coqdocaxiom{partition}} \coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test partition2}{test\_partition2}{\coqdocdefinition{test\_partition2}}: \coqref{LF.Poly.partition}{\coqdocaxiom{partition}} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqref{LF.Basics.false}{\coqdocconstructor{false}}) \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}9\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}9\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{映射}



 另一个方便的高阶函数叫做 \coqref{LF.Poly.map}{\coqdocdefinition{map}}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Poly.map}{map}{\coqdocdefinition{map}} \{\coqdocvar{X} \coqdocvar{Y}: \coqdockw{Type}\} (\coqdocvar{f}:\coqdocvariable{X}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdocvariable{Y}) (\coqdocvar{l}:\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) : (\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{Y}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}     \ensuremath{\Rightarrow} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{t} \ensuremath{\Rightarrow} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{(}}\coqdocvariable{f} \coqdocvar{h}\coqref{LF.Poly.:::x '::' x}{\coqdocnotation{)}} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{(}}\coqref{LF.Poly.map}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvar{t}\coqref{LF.Poly.:::x '::' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
它接受一个函数 \coqdocvariable{f} 和一个列表  \coqdocvariable{l} = [\coqdocvariable{n1}, \coqdocvariable{n2}, \coqdocvariable{n3}, ...] 
    并返回列表  [\coqdocvariable{f} \coqdocvariable{n1}, \coqdocvariable{f} \coqdocvariable{n2}, \coqdocvariable{f} \coqdocvariable{n3},...] ，其中 \coqdocvariable{f} 可分别应用于 \coqdocvariable{l}
    中的每一个元素。例如： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test map1}{test\_map1}{\coqdocdefinition{test\_map1}}: \coqref{LF.Poly.map}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqexternalref{plus}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{plus}} 3 \coqdocvariable{x}) \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
输入列表和输出列表的元素类型不必相同，因为 \coqref{LF.Poly.map}{\coqdocdefinition{map}} 会接受\textit{'两个'}类型参数
    \coqref{LF.Imp.X}{\coqdocdefinition{X}} 和 \coqref{LF.Imp.Y}{\coqdocdefinition{Y}}，因此它可以应用到一个数值的列表和一个从数值到布尔值的函数，
    并产生一个布尔值列表： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test map2}{test\_map2}{\coqdocdefinition{test\_map2}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.map}{\coqdocdefinition{map}} \coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
它甚至可以应用到一个数值的列表和一个从数值到布尔值列表的函数，
    并产生一个布尔值的\textit{'列表的列表'}： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test map3}{test\_map3}{\coqdocdefinition{test\_map3}}:\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Poly.map}{\coqdocdefinition{map}} (\coqdockw{fun} \coqdocvar{n} \ensuremath{\Rightarrow} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} \coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}) \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[[}}\coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];[}}\coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];[}}\coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];[}}\coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{习题}



\paragraph{练习：3 星, standard (map\_rev)}




    请证明 \coqref{LF.Poly.map}{\coqdocdefinition{map}} 和 \coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} 可交换。你可能需要定义一个辅助引理 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Poly.map rev}{map\_rev}{\coqdoclemma{map\_rev}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}) (\coqdocvar{f} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y}) (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.map}{\coqdocdefinition{map}} \coqdocvariable{f} (\coqref{LF.Poly.rev}{\coqdocdefinition{rev}} \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.rev}{\coqdocdefinition{rev}} (\coqref{LF.Poly.map}{\coqdocdefinition{map}} \coqdocvariable{f} \coqdocvariable{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, recommended (flat\_map)}




    函数 \coqref{LF.Poly.map}{\coqdocdefinition{map}} 通过一个类型为 \coqref{LF.Imp.X}{\coqdocdefinition{X}} \ensuremath{\rightarrow} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} 的函数将 \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} 映射到 \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}}。
    我们可以定义一个类似的函数 \coqref{LF.Poly.flat map}{\coqdocdefinition{flat\_map}}，它通过一个类型为 \coqref{LF.Imp.X}{\coqdocdefinition{X}} \ensuremath{\rightarrow} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}}
    的函数 \coqdocvariable{f} 将 \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.X}{\coqdocdefinition{X}} 映射到 \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Imp.Y}{\coqdocdefinition{Y}}。你的定义应当可以“压扁”\coqdocvariable{f}
    的结果，就像这样：


        flat\_map (fun n => \coqdocvariable{n};\coqdocvariable{n}+1;\coqdocvariable{n}+2) 1;5;10
      = 1; 2; 3; 5; 6; 7; 10; 11; 12.
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Poly.flat map}{flat\_map}{\coqdocdefinition{flat\_map}} \{\coqdocvar{X} \coqdocvar{Y}: \coqdockw{Type}\} (\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{Y}) (\coqdocvar{l}: \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X})\coqdoceol
\coqdocindent{9.50em}
: (\coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{Y})\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test flat map1}{test\_flat\_map1}{\coqdocdefinition{test\_flat\_map1}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.flat map}{\coqdocaxiom{flat\_map}} (\coqdockw{fun} \coqdocvar{n} \ensuremath{\Rightarrow} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqdocvariable{n}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}) \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}} 4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 \coqref{LF.Poly.map}{\coqdocdefinition{map}} 这个函数不止对列表有意义，以下是一个在 \coqref{LF.Poly.OptionPlayground.option}{\coqdocinductive{option}} 上的 \coqref{LF.Poly.map}{\coqdocdefinition{map}}：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.option map}{option\_map}{\coqdocdefinition{option\_map}} \{\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}\} (\coqdocvar{f} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y}) (\coqdocvar{xo} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqdocvariable{X})\coqdoceol
\coqdocindent{11.00em}
: \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} \coqdocvariable{Y} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{xo} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}} \ensuremath{\Rightarrow} \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} \coqdocvar{x} \ensuremath{\Rightarrow} \coqexternalref{Some}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{Some}} (\coqdocvariable{f} \coqdocvar{x})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard, optional (implicit\_args)}




    \coqref{LF.Poly.filter}{\coqdocdefinition{filter}} 和 \coqref{LF.Poly.map}{\coqdocdefinition{map}} 的定义和应用在很多地方使用了隐式参数。
    请将隐式参数外层的花括号替换为圆括号，然后在必要的地方补充显式类型形参并用
    Coq 检查你做的是否正确。（本练习并不会打分，你可以在本文件的\textit{'副本'}中做它，
    之后丢掉即可。）
 \ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{折叠}



 一个更加强大的高阶函数叫做 \coqdoctac{fold}。本函数启发自“\coqdocvar{reduce} 归约”
    操作，它是 Google 的 map/reduce 分布式编程框架的核心。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Poly.fold}{fold}{\coqdocdefinition{fold}} \{\coqdocvar{X} \coqdocvar{Y}: \coqdockw{Type}\} (\coqdocvar{f}: \coqdocvariable{X}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdocvariable{Y}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdocvariable{Y}) (\coqdocvar{l}: \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) (\coqdocvar{b}: \coqdocvariable{Y})\coqdoceol
\coqdocindent{12.50em}
: \coqdocvariable{Y} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Poly.nil}{\coqdocconstructor{nil}} \ensuremath{\Rightarrow} \coqdocvariable{b}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} \coqref{LF.Poly.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvariable{f} \coqdocvar{h} (\coqref{LF.Poly.fold}{\coqdocdefinition{fold}} \coqdocvariable{f} \coqdocvar{t} \coqdocvariable{b})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
直观上来说，\coqdoctac{fold} 操作的行为就是将给定的二元操作符 \coqdocvariable{f}
    插入到给定列表的每一对元素之间。例如， \coqdoctac{fold} \coqref{LF.Basics.NatPlayground2.plus}{\coqdocdefinition{plus}} [1;2;3;4] 
    直观上的意思是 1+2+3+4。为了让它更精确，我们还需要一个“起始元素”
    作为 \coqdocvariable{f} 初始的第二个输入。因此，例如


       fold plus 1;2;3;4 0


    就会产生


       1 + (2 + (3 + (4 + 0))).


    以下是更多例子： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqref{LF.Poly.fold}{\coqdocdefinition{fold}} \coqref{LF.Basics.andb}{\coqdocdefinition{andb}}) : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.fold example1}{fold\_example1}{\coqdocdefinition{fold\_example1}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.fold}{\coqdocdefinition{fold}} \coqexternalref{mult}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{mult}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} 1 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 24.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.fold example2}{fold\_example2}{\coqdocdefinition{fold\_example2}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.fold}{\coqdocdefinition{fold}} \coqref{LF.Basics.andb}{\coqdocdefinition{andb}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}\coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.fold example3}{fold\_example3}{\coqdocdefinition{fold\_example3}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.fold}{\coqdocdefinition{fold}} \coqref{LF.Poly.app}{\coqdocdefinition{app}}  \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];}}\coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}}\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;[}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{];[}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]]}} \coqref{LF.Poly.:::'[' ']'}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, advanced (fold\_types\_different)}




    我们观察到 \coqdoctac{fold} 由 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 和 \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} 这\textit{'两个'}类型变量参数化，形参 \coqdocvariable{f}
    则是个接受 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 和 \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} 并返回 \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} 的二元操作符。你能想出一种 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 和
    \coqref{LF.Imp.Y}{\coqdocdefinition{Y}} 不同时的应用情景吗？ \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.manual grade for fold types different}{manual\_grade\_for\_fold\_types\_different}{\coqdocdefinition{manual\_grade\_for\_fold\_types\_different}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{用函数构造函数}



 目前我们讨论过的大部分高阶函数都是接受函数作为参数的。
    现在我们来看一些将函数作为其它函数的结果\textit{'返回'}的例子。
    首先，下面是一个接受值 \coqdocvariable{x}（由某个类型 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 刻画）并返回一个从
    \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 到 \coqref{LF.Imp.X}{\coqdocdefinition{X}} 的函数，当它被调用时总是产生 \coqdocvariable{x} 并忽略其 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 参数。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.constfun}{constfun}{\coqdocdefinition{constfun}} \{\coqdocvar{X}: \coqdockw{Type}\} (\coqdocvar{x}: \coqdocvariable{X}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdocvariable{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} (\coqdocvar{k}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) \ensuremath{\Rightarrow} \coqdocvariable{x}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.ftrue}{ftrue}{\coqdocdefinition{ftrue}} := \coqref{LF.Poly.constfun}{\coqdocdefinition{constfun}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.constfun example1}{constfun\_example1}{\coqdocdefinition{constfun\_example1}} : \coqref{LF.Poly.ftrue}{\coqdocdefinition{ftrue}} 0 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.constfun example2}{constfun\_example2}{\coqdocdefinition{constfun\_example2}} : (\coqref{LF.Poly.constfun}{\coqdocdefinition{constfun}} 5) 99 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 5.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
实际上，我们已经见过的多参函数也是讲函数作为数据传入的例子。
    为了理解为什么，请回想 \coqref{LF.Basics.NatPlayground2.plus}{\coqdocdefinition{plus}} 的类型。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqexternalref{plus}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{plus}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
该表达式中的每个 \ensuremath{\rightarrow} 实际上都是一个类型上的\textit{'二元'}操作符。
    该操作符是\textit{'右结合'}的，因此 \coqref{LF.Basics.NatPlayground2.plus}{\coqdocdefinition{plus}} 的类型其实是 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} \ensuremath{\rightarrow} (\coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} \ensuremath{\rightarrow} \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}})
    的简写，即，它可以读作“\coqref{LF.Basics.NatPlayground2.plus}{\coqdocdefinition{plus}} 是一个单参数函数，它接受一个 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}
    并返回另一个函数，该函数接受另一个 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 并返回一个 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}”。
    在上面的例子中，我们总是将 \coqref{LF.Basics.NatPlayground2.plus}{\coqdocdefinition{plus}} 一次同时应用到两个参数上。
    不过如果我们喜欢，也可以一次只提供一个参数，这叫做\textit{'偏应用（Partial
    Application）'}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.plus3}{plus3}{\coqdocdefinition{plus3}} := \coqexternalref{plus}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{plus}} 3.\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqref{LF.Poly.plus3}{\coqdocdefinition{plus3}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test plus3}{test\_plus3}{\coqdocdefinition{test\_plus3}} :    \coqref{LF.Poly.plus3}{\coqdocdefinition{plus3}} 4 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 7.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test plus3'}{test\_plus3'}{\coqdocdefinition{test\_plus3'}} :   \coqref{LF.Poly.doit3times}{\coqdocdefinition{doit3times}} \coqref{LF.Poly.plus3}{\coqdocdefinition{plus3}} 0 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 9.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.test plus3''}{test\_plus3'{}'}{\coqdocdefinition{test\_plus3'{}'}} :  \coqref{LF.Poly.doit3times}{\coqdocdefinition{doit3times}} (\coqexternalref{plus}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{plus}} 3) 0 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 9.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{附加练习}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Poly.Exercises}{Exercises}{\coqdocmodule{Exercises}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard (fold\_length)}




    列表的很多通用函数都可以通过 \coqdoctac{fold} 来实现。例如，下面是
    \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} 的另一种实现： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.Exercises.fold length}{fold\_length}{\coqdocdefinition{fold\_length}} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.fold}{\coqdocdefinition{fold}} (\coqdockw{fun} \coqdocvar{\_} \coqdocvar{n} \ensuremath{\Rightarrow} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}) \coqdocvariable{l} 0.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.Exercises.test fold length1}{test\_fold\_length1}{\coqdocdefinition{test\_fold\_length1}} : \coqref{LF.Poly.Exercises.fold length}{\coqdocdefinition{fold\_length}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}4\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}7\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 3.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
请证明 \coqref{LF.Poly.Exercises.fold length}{\coqdocdefinition{fold\_length}} 的正确性。
    （提示：知道 \coqdoctac{reflexivity} 的化简力度比 \coqdoctac{simpl}
    更大或许会有所帮助。也就是说，你或许会遇到 \coqdoctac{simpl} 无法解决但 \coqdoctac{reflexivity}
    可以解决的目标。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Poly.Exercises.fold length correct}{fold\_length\_correct}{\coqdoclemma{fold\_length\_correct}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X} (\coqdocvar{l} : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.Exercises.fold length}{\coqdocdefinition{fold\_length}} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.length}{\coqdocdefinition{length}} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard (fold\_map)}




    我们也可以用 \coqdoctac{fold} 来定义 \coqref{LF.Poly.map}{\coqdocdefinition{map}}。请完成下面的 \coqref{LF.Poly.Exercises.fold map}{\coqdocdefinition{fold\_map}}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.Exercises.fold map}{fold\_map}{\coqdocdefinition{fold\_map}} \{\coqdocvar{X} \coqdocvar{Y}: \coqdockw{Type}\} (\coqdocvar{f}: \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y}) (\coqdocvar{l}: \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{X}) : \coqref{LF.Poly.list}{\coqdocinductive{list}} \coqdocvariable{Y}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在 Coq 中写出 \coqdocvar{fold\_map\_correct} 来陈述 \coqref{LF.Poly.Exercises.fold map}{\coqdocdefinition{fold\_map}} 是正确的，然后证明它。
    （提示：再次提醒，\coqdoctac{reflexivity} 的化简力度比 \coqdoctac{simpl} 更强。） \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.Exercises.manual grade for fold map}{manual\_grade\_for\_fold\_map}{\coqdocdefinition{manual\_grade\_for\_fold\_map}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, advanced (currying)}




    在 Coq 中，函数 \coqdocvariable{f} : \coqref{LF.Basics.A}{\coqdocconstructor{A}} \ensuremath{\rightarrow} \coqref{LF.Basics.B}{\coqdocconstructor{B}} \ensuremath{\rightarrow} \coqdocvar{C} 的类型其实是 \coqref{LF.Basics.A}{\coqdocconstructor{A}} \ensuremath{\rightarrow} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \ensuremath{\rightarrow} \coqdocvar{C})。
    也就是说，如果给 \coqdocvariable{f} 一个类型为 \coqref{LF.Basics.A}{\coqdocconstructor{A}} 的值，它就会给你函数 \coqdocvar{f'} : \coqref{LF.Basics.B}{\coqdocconstructor{B}} \ensuremath{\rightarrow} \coqdocvar{C}。
    如果再给 \coqdocvar{f'} 一个类型为 \coqref{LF.Basics.B}{\coqdocconstructor{B}} 的值，它就会返回一个类型为 \coqdocvar{C} 的值。
    这为我们提供了 \coqref{LF.Poly.plus3}{\coqdocdefinition{plus3}} 中的那种偏应用能力。
    用返回函数的函数处理参数列表的方式被称为\textit{'柯里化（Currying）'}，
    它是为了纪念逻辑学家 Haskell Curry。


    反之，我们也可以将 \coqref{LF.Basics.A}{\coqdocconstructor{A}} \ensuremath{\rightarrow} \coqref{LF.Basics.B}{\coqdocconstructor{B}} \ensuremath{\rightarrow} \coqdocvar{C} 解释为 (\coqref{LF.Basics.A}{\coqdocconstructor{A}} \ensuremath{\times} \coqref{LF.Basics.B}{\coqdocconstructor{B}}) \ensuremath{\rightarrow} \coqdocvar{C}。这叫做
    \textit{'反柯里化（Uncurrying）'}。对于反柯里化的二元函数，
    两个参数必须作为序对一次给出，此时它不会偏应用。 

 我们可以将柯里化定义如下： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.Exercises.prod curry}{prod\_curry}{\coqdocdefinition{prod\_curry}} \{\coqdocvar{X} \coqdocvar{Y} \coqdocvar{Z} : \coqdockw{Type}\}\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{f} : \coqdocvariable{X} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z}) (\coqdocvar{x} : \coqdocvariable{X}) (\coqdocvar{y} : \coqdocvariable{Y}) : \coqdocvariable{Z} := \coqdocvariable{f} \coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvariable{x}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqdocvariable{y}\coqref{LF.Poly.:::'(' x ',' x ')'}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
作为练习，请定义它的反函数 \coqref{LF.Poly.Exercises.prod uncurry}{\coqdocdefinition{prod\_uncurry}}，
    然后在下面证明它们互为反函数的定理。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.Exercises.prod uncurry}{prod\_uncurry}{\coqdocdefinition{prod\_uncurry}} \{\coqdocvar{X} \coqdocvar{Y} \coqdocvar{Z} : \coqdockw{Type}\}\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{f} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z}) (\coqdocvar{p} : \coqdocvariable{X} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{Y}) : \coqdocvariable{Z}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
举一个柯里化用途的（平凡的）例子，我们可以用它来缩短之前看到的一个例子： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.Exercises.test map1'}{test\_map1'}{\coqdocdefinition{test\_map1'}}: \coqref{LF.Poly.map}{\coqdocdefinition{map}} (\coqexternalref{plus}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{plus}} 3) \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Poly.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
思考练习：在运行以下指令之前，你能计算出 \coqref{LF.Poly.Exercises.prod curry}{\coqdocdefinition{prod\_curry}} 和 \coqref{LF.Poly.Exercises.prod uncurry}{\coqdocdefinition{prod\_uncurry}} 
    的类型吗？ \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} @\coqref{LF.Poly.Exercises.prod curry}{\coqdocdefinition{prod\_curry}}.\coqdoceol
\coqdocnoindent
\coqdockw{Check} @\coqref{LF.Poly.Exercises.prod uncurry}{\coqdocaxiom{prod\_uncurry}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Poly.Exercises.uncurry curry}{uncurry\_curry}{\coqdoclemma{uncurry\_curry}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} \coqdocvar{Y} \coqdocvar{Z} : \coqdockw{Type})\coqdoceol
\coqdocindent{12.00em}
(\coqdocvar{f} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Y} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z})\coqdoceol
\coqdocindent{12.00em}
\coqdocvar{x} \coqdocvar{y},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.Exercises.prod curry}{\coqdocdefinition{prod\_curry}} (\coqref{LF.Poly.Exercises.prod uncurry}{\coqdocaxiom{prod\_uncurry}} \coqdocvariable{f}) \coqdocvariable{x} \coqdocvariable{y} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{f} \coqdocvariable{x} \coqdocvariable{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Poly.Exercises.curry uncurry}{curry\_uncurry}{\coqdoclemma{curry\_uncurry}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} \coqdocvar{Y} \coqdocvar{Z} : \coqdockw{Type})\coqdoceol
\coqdocindent{12.00em}
(\coqdocvar{f} : \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{X} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{Y}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{Z}) (\coqdocvar{p} : \coqdocvariable{X} \coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{Y}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.Exercises.prod uncurry}{\coqdocaxiom{prod\_uncurry}} (\coqref{LF.Poly.Exercises.prod curry}{\coqdocdefinition{prod\_curry}} \coqdocvariable{f}) \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{f} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, advanced (nth\_error\_informal)}




    回想 \coqref{LF.Lists.NatList.nth error}{\coqdocdefinition{nth\_error}} 函数的定义：


   Fixpoint nth\_error \{X : Type\} (l : list X) (n : nat) : option X :=
     match l with
     | \ensuremath{\Box} => None
     | a :: l' => if n =? O then Some a else nth\_error l' (pred n)
     end.


   请写出以下定理的非形式化证明：


   forall X l n, length l = n -> @nth\_error X l n = None
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.Exercises.manual grade for informal proof}{manual\_grade\_for\_informal\_proof}{\coqdocdefinition{manual\_grade\_for\_informal\_proof}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqref{LF.Poly.::type scope:x '*' x}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 本练习使用\textit{'邱奇数（Church numerals）'}探讨了另一种定义自然数的方式，
    它以数学家 Alonzo Church 命名。我们可以将自然数 \coqdocvariable{n} 表示为一个函数，
    它接受一个函数 \coqdocvariable{f} 作为参数并返回迭代了 \coqdocvariable{n} 次的 \coqdocvariable{f}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Poly.Exercises.Church}{Church}{\coqdocmodule{Church}}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.Exercises.Church.cnat}{cnat}{\coqdocdefinition{cnat}} := \coqdockw{\ensuremath{\forall}} \coqdocvar{X} : \coqdockw{Type}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{X}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{X}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们来看看如何用这种记法写数。将函数迭代一次应当与将它应用一次相同。
    因此： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.Exercises.Church.one}{one}{\coqdocdefinition{one}} : \coqref{LF.Poly.Exercises.Church.cnat}{\coqdocdefinition{cnat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{f} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{X}) (\coqdocvar{x} : \coqdocvariable{X}) \ensuremath{\Rightarrow} \coqdocvariable{f} \coqdocvariable{x}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
与此类似，\coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{two}} 应当对其参数应用两次 \coqdocvariable{f}： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.Exercises.Church.two}{two}{\coqdocdefinition{two}} : \coqref{LF.Poly.Exercises.Church.cnat}{\coqdocdefinition{cnat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{f} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{X}) (\coqdocvar{x} : \coqdocvariable{X}) \ensuremath{\Rightarrow} \coqdocvariable{f} (\coqdocvariable{f} \coqdocvariable{x}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
定义 \coqref{LF.Poly.Exercises.Church.zero}{\coqdocdefinition{zero}} 有点刁钻：我们如何“将函数应用零次”？答案很简单：
    把参数原样返回就好。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.Exercises.Church.zero}{zero}{\coqdocdefinition{zero}} : \coqref{LF.Poly.Exercises.Church.cnat}{\coqdocdefinition{cnat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{f} : \coqdocvariable{X} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{X}) (\coqdocvar{x} : \coqdocvariable{X}) \ensuremath{\Rightarrow} \coqdocvariable{x}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
更一般地说，数 \coqdocvariable{n} 可以写作 \coqdockw{fun} \coqref{LF.Imp.X}{\coqdocdefinition{X}} \coqdocvariable{f} \coqdocvariable{x} \ensuremath{\Rightarrow} \coqdocvariable{f} (\coqdocvariable{f}
    ... (\coqdocvariable{f} \coqdocvariable{x}) ...)，其中 \coqdocvariable{f} 出现了 \coqdocvariable{n} 次。要特别注意我们之前定义
    \coqref{LF.Poly.doit3times}{\coqdocdefinition{doit3times}} 函数的方式就是 3 的邱奇数表示。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.Exercises.Church.three}{three}{\coqdocdefinition{three}} : \coqref{LF.Poly.Exercises.Church.cnat}{\coqdocdefinition{cnat}} := @\coqref{LF.Poly.doit3times}{\coqdocdefinition{doit3times}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
完成以下函数的定义。请用 \coqdoctac{reflexivity} 证明来确认它们能够通过对应的单元测试。 

\paragraph{练习：1 星, advanced (church\_succ)}



 自然数的后继：给定一个邱奇数 \coqdocvariable{n}，它的后继 \coqref{LF.Poly.Exercises.Church.succ}{\coqdocdefinition{succ}} \coqdocvariable{n} 是一个把它的参数比 \coqdocvariable{n}
    还多迭代一次的函数。 \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.Exercises.Church.succ}{succ}{\coqdocdefinition{succ}} (\coqdocvar{n} : \coqref{LF.Poly.Exercises.Church.cnat}{\coqdocdefinition{cnat}}) : \coqref{LF.Poly.Exercises.Church.cnat}{\coqdocdefinition{cnat}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.Exercises.Church.succ 1}{succ\_1}{\coqdocdefinition{succ\_1}} : \coqref{LF.Poly.Exercises.Church.succ}{\coqdocaxiom{succ}} \coqref{LF.Poly.Exercises.Church.zero}{\coqdocdefinition{zero}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{one}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.Exercises.Church.succ 2}{succ\_2}{\coqdocdefinition{succ\_2}} : \coqref{LF.Poly.Exercises.Church.succ}{\coqdocaxiom{succ}} \coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{one}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{two}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.Exercises.Church.succ 3}{succ\_3}{\coqdocdefinition{succ\_3}} : \coqref{LF.Poly.Exercises.Church.succ}{\coqdocaxiom{succ}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{two}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{three}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：1 星, advanced (church\_plus)}



 两邱奇数相加： \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.Exercises.Church.plus}{plus}{\coqdocdefinition{plus}} (\coqdocvar{n} \coqdocvar{m} : \coqref{LF.Poly.Exercises.Church.cnat}{\coqdocdefinition{cnat}}) : \coqref{LF.Poly.Exercises.Church.cnat}{\coqdocdefinition{cnat}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.Exercises.Church.plus 1}{plus\_1}{\coqdocdefinition{plus\_1}} : \coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{plus}} \coqref{LF.Poly.Exercises.Church.zero}{\coqdocdefinition{zero}} \coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{one}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{one}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.Exercises.Church.plus 2}{plus\_2}{\coqdocdefinition{plus\_2}} : \coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{plus}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{two}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{three}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{plus}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{three}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{two}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.Exercises.Church.plus 3}{plus\_3}{\coqdocdefinition{plus\_3}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{plus}} (\coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{plus}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{two}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{two}}) \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{three}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{plus}} \coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{one}} (\coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{plus}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{three}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{three}}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, advanced (church\_mult)}



 乘法： \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.Exercises.Church.mult}{mult}{\coqdocdefinition{mult}} (\coqdocvar{n} \coqdocvar{m} : \coqref{LF.Poly.Exercises.Church.cnat}{\coqdocdefinition{cnat}}) : \coqref{LF.Poly.Exercises.Church.cnat}{\coqdocdefinition{cnat}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.Exercises.Church.mult 1}{mult\_1}{\coqdocdefinition{mult\_1}} : \coqref{LF.Poly.Exercises.Church.mult}{\coqdocaxiom{mult}} \coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{one}} \coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{one}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{one}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.Exercises.Church.mult 2}{mult\_2}{\coqdocdefinition{mult\_2}} : \coqref{LF.Poly.Exercises.Church.mult}{\coqdocaxiom{mult}} \coqref{LF.Poly.Exercises.Church.zero}{\coqdocdefinition{zero}} (\coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{plus}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{three}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{three}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.Exercises.Church.zero}{\coqdocdefinition{zero}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.Exercises.Church.mult 3}{mult\_3}{\coqdocdefinition{mult\_3}} : \coqref{LF.Poly.Exercises.Church.mult}{\coqdocaxiom{mult}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{two}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{three}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{plus}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{three}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{three}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, advanced (church\_exp)}



 乘方： 

 （\textit{'提示'}：多态在这里起到了关键的作用。然而，棘手之处在于选择正确的类型来迭代。
    如果你遇到了「Universe inconsistency，全域不一致」错误，请在不同的类型上迭
    代。在 \coqref{LF.Poly.Exercises.Church.cnat}{\coqdocdefinition{cnat}} 本身上迭代通常会有问题。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Poly.Exercises.Church.exp}{exp}{\coqdocdefinition{exp}} (\coqdocvar{n} \coqdocvar{m} : \coqref{LF.Poly.Exercises.Church.cnat}{\coqdocdefinition{cnat}}) : \coqref{LF.Poly.Exercises.Church.cnat}{\coqdocdefinition{cnat}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.Exercises.Church.exp 1}{exp\_1}{\coqdocdefinition{exp\_1}} : \coqref{LF.Poly.Exercises.Church.exp}{\coqdocaxiom{exp}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{two}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{two}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{plus}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{two}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{two}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.Exercises.Church.exp 2}{exp\_2}{\coqdocdefinition{exp\_2}} : \coqref{LF.Poly.Exercises.Church.exp}{\coqdocaxiom{exp}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{three}} \coqref{LF.Poly.Exercises.Church.zero}{\coqdocdefinition{zero}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{one}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Poly.Exercises.Church.exp 3}{exp\_3}{\coqdocdefinition{exp\_3}} : \coqref{LF.Poly.Exercises.Church.exp}{\coqdocaxiom{exp}} \coqref{LF.Poly.Exercises.Church.three}{\coqdocdefinition{three}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{two}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Poly.Exercises.Church.plus}{\coqdocaxiom{plus}} (\coqref{LF.Poly.Exercises.Church.mult}{\coqdocaxiom{mult}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{two}} (\coqref{LF.Poly.Exercises.Church.mult}{\coqdocaxiom{mult}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{two}} \coqref{LF.Poly.Exercises.Church.two}{\coqdocdefinition{two}})) \coqref{LF.Poly.Exercises.Church.one}{\coqdocdefinition{one}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.Poly.Exercises.Church}{\coqdocmodule{Church}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.Poly.Exercises}{\coqdocmodule{Exercises}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.Lists}{Library }{LF.Lists}

\begin{coqdoccode}
\end{coqdoccode}
\section{Lists: 使用结构化的数据}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Export} \coqref{LF.Induction}{\coqdoclibrary{Induction}}.\coqdoceol
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Lists.NatList}{NatList}{\coqdocmodule{NatList}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{数值序对}



 在 \coqdockw{Inductive} 类型定义中，每个构造子（Constructor）可以有任意多个参数
    —— 可以没有（如 \coqref{LF.Basics.true}{\coqdocconstructor{true}} 和 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}}），可以只有一个（如 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}}），也可以更多
    （如 \coqref{LF.Basics.nybble}{\coqdocinductive{nybble}}，以及下文所示）： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Lists.NatList.natprod}{natprod}{\coqdocinductive{natprod}} : \coqdockw{Type} :=\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{LF.Lists.NatList.pair}{pair}{\coqdocconstructor{pair}} (\coqdocvar{n1} \coqdocvar{n2} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
此声明可以读作：“构造数值序对的唯一一种方法，就是将构造子 \coqref{LF.Lists.NatList.pair}{\coqdocconstructor{pair}}
    应用到两个 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 类型的参数上。” \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqref{LF.Lists.NatList.pair}{\coqdocconstructor{pair}} 3 5) : \coqref{LF.Lists.NatList.natprod}{\coqdocinductive{natprod}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
下述函数分别用于提取二元组中的第一个和第二个分量。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.fst}{fst}{\coqdocdefinition{fst}} (\coqdocvar{p} : \coqref{LF.Lists.NatList.natprod}{\coqdocinductive{natprod}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.NatList.pair}{\coqdocconstructor{pair}} \coqdocvar{x} \coqdocvar{y} \ensuremath{\Rightarrow} \coqdocvar{x}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.snd}{snd}{\coqdocdefinition{snd}} (\coqdocvar{p} : \coqref{LF.Lists.NatList.natprod}{\coqdocinductive{natprod}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.NatList.pair}{\coqdocconstructor{pair}} \coqdocvar{x} \coqdocvar{y} \ensuremath{\Rightarrow} \coqdocvar{y}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Compute} (\coqref{LF.Lists.NatList.fst}{\coqdocdefinition{fst}} (\coqref{LF.Lists.NatList.pair}{\coqdocconstructor{pair}} 3 5)).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
由于二元组十分常用，不妨以标准的数学记法 (\coqdocvariable{x},\coqdocvariable{y}) 取代 \coqref{LF.Lists.NatList.pair}{\coqdocconstructor{pair}} \coqdocvariable{x} \coqdocvariable{y}。
    通过 \coqdockw{Notation} 向 Coq 声明该记法： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Lists.NatList.:::'(' x ',' x ')'}{"}{"}( x , y )" := (\coqref{LF.Lists.NatList.pair}{\coqdocconstructor{pair}} \coqdocvar{x} \coqdocvar{y}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The new notation can be used both in expressions and in pattern
    matches. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Compute} (\coqref{LF.Lists.NatList.fst}{\coqdocdefinition{fst}} \coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{(}}3\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{,}}5\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{)}}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.fst'}{fst'}{\coqdocdefinition{fst'}} (\coqdocvar{p} : \coqref{LF.Lists.NatList.natprod}{\coqdocinductive{natprod}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvar{x}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{,}}\coqdocvar{y}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{)}} \ensuremath{\Rightarrow} \coqdocvar{x}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.snd'}{snd'}{\coqdocdefinition{snd'}} (\coqdocvar{p} : \coqref{LF.Lists.NatList.natprod}{\coqdocinductive{natprod}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvar{x}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{,}}\coqdocvar{y}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{)}} \ensuremath{\Rightarrow} \coqdocvar{y}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.swap pair}{swap\_pair}{\coqdocdefinition{swap\_pair}} (\coqdocvar{p} : \coqref{LF.Lists.NatList.natprod}{\coqdocinductive{natprod}}) : \coqref{LF.Lists.NatList.natprod}{\coqdocinductive{natprod}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvar{x}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{,}}\coqdocvar{y}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{)}} \ensuremath{\Rightarrow} \coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvar{y}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{,}}\coqdocvar{x}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Note that pattern-matching on a pair (with parentheses: (\coqdocvariable{x}, \coqdocvariable{y}))
    is not to be confused with the ``multiple pattern'' syntax
    (with no parentheses: \coqdocvariable{x}, \coqdocvariable{y}) that we have seen previously.
    The above examples illustrate pattern matching on a pair with
    elements \coqdocvariable{x} and \coqdocvariable{y}, whereas, for example, the definition of \coqref{LF.Basics.NatPlayground2.minus}{\coqdocdefinition{minus}} in
    \coqdoclibrary{Basics} performs pattern matching on the values \coqdocvariable{n}
    and \coqdocvariable{m}:


       Fixpoint minus (n m : nat) : nat :=
         match n, m with
         | O   , \_    => O
         | S \_ , O    => n
         | S n', S m' => minus n' m'
         end.


    The distinction is minor, but it is worth knowing that they
    are not the same. For instance, the following definitions are
    ill-formed:


                Definition bad\_fst (p : natprod) : nat :=
          match p with
          | x, y => x
          end.


                Definition bad\_minus (n m : nat) : nat :=
          match n, m with
          | (O   , \_   ) => O
          | (S \_ , O   ) => n
          | (S n', S m') => bad\_minus n' m'
          end.


 现在我们来证明一些有关二元组的简单事实。


    如果我们以稍显古怪的方式陈述序对的性质，那么有时只需
    \coqdoctac{reflexivity}（及其内建的简化）即可完成证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.surjective pairing'}{surjective\_pairing'}{\coqdoclemma{surjective\_pairing'}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvariable{n}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{,}}\coqdocvariable{m}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqref{LF.Lists.NatList.fst}{\coqdocdefinition{fst}} \coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvariable{n}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{,}}\coqdocvariable{m}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{),}} \coqref{LF.Lists.NatList.snd}{\coqdocdefinition{snd}} \coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqdocvariable{n}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{,}}\coqdocvariable{m}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{))}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
但是，如果我们用一种更为自然的方式来陈述此引理的话，只用
    \coqdoctac{reflexivity} 还不够。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.surjective pairing stuck}{surjective\_pairing\_stuck}{\coqdoclemma{surjective\_pairing\_stuck}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{p} : \coqref{LF.Lists.NatList.natprod}{\coqdocinductive{natprod}}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqref{LF.Lists.NatList.fst}{\coqdocdefinition{fst}} \coqdocvariable{p}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqref{LF.Lists.NatList.snd}{\coqdocdefinition{snd}} \coqdocvariable{p}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们还需要向 Coq 展示 \coqdocvariable{p} 的具体结构，这样 \coqdoctac{simpl} 才能对
    \coqref{LF.Lists.NatList.fst}{\coqdocdefinition{fst}} 和 \coqref{LF.Lists.NatList.snd}{\coqdocdefinition{snd}} 做模式匹配。通过 \coqdoctac{destruct} 可以达到这个目的。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.surjective pairing}{surjective\_pairing}{\coqdoclemma{surjective\_pairing}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{p} : \coqref{LF.Lists.NatList.natprod}{\coqdocinductive{natprod}}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqref{LF.Lists.NatList.fst}{\coqdocdefinition{fst}} \coqdocvariable{p}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqref{LF.Lists.NatList.snd}{\coqdocdefinition{snd}} \coqdocvariable{p}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p}. \coqdoctac{destruct} \coqdocvar{p} \coqdockw{as} [\coqdocvar{n} \coqdocvar{m}]. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
注意：不同于解构自然数产生两个子目标，\coqdoctac{destruct} 在此只产生
    一个子目标。这是因为 \coqref{LF.Lists.NatList.natprod}{\coqdocinductive{natprod}} 只有一种构造方法。 

\paragraph{练习：1 星, standard (snd\_fst\_is\_swap)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.snd fst is swap}{snd\_fst\_is\_swap}{\coqdoclemma{snd\_fst\_is\_swap}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{p} : \coqref{LF.Lists.NatList.natprod}{\coqdocinductive{natprod}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{(}}\coqref{LF.Lists.NatList.snd}{\coqdocdefinition{snd}} \coqdocvariable{p}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{,}} \coqref{LF.Lists.NatList.fst}{\coqdocdefinition{fst}} \coqdocvariable{p}\coqref{LF.Lists.NatList.:::'(' x ',' x ')'}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.swap pair}{\coqdocdefinition{swap\_pair}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：1 星, standard, optional (fst\_swap\_is\_snd)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.fst swap is snd}{fst\_swap\_is\_snd}{\coqdoclemma{fst\_swap\_is\_snd}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{p} : \coqref{LF.Lists.NatList.natprod}{\coqdocinductive{natprod}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.fst}{\coqdocdefinition{fst}} (\coqref{LF.Lists.NatList.swap pair}{\coqdocdefinition{swap\_pair}} \coqdocvariable{p}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.snd}{\coqdocdefinition{snd}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{数值列表}



 通过推广序对的定义，数值\textit{'列表'}类型可以这样描述：
    “一个列表要么是空的，要么就是由一个数和另一个列表组成的序对。” \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Lists.NatList.natlist}{natlist}{\coqdocinductive{natlist}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Lists.NatList.nil}{nil}{\coqdocconstructor{nil}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Lists.NatList.cons}{cons}{\coqdocconstructor{cons}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{l} : \coqref{LF.Lists.natlist}{\coqdocinductive{natlist}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
例如，这是一个三元素列表： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.mylist}{mylist}{\coqdocdefinition{mylist}} := \coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 1 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 2 (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 3 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
和序对一样，使用熟悉的编程记法来表示列表会更方便些。
    以下两个声明能让我们用 :: 作为中缀的 \coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 操作符，
    用方括号作为构造列表的“外围（outfix）”记法。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Lists.NatList.:::x '::' x}{"}{"}x :: l" := (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} \coqdocvar{x} \coqdocvar{l})\coqdoceol
\coqdocindent{10.50em}
(\coqdoctac{at} \coqdockw{level} 60, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Lists.NatList.:::'[' ']'}{"}{"}[ ]" := \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{"}{"}[ x ; .. ; y ]" := (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} \coqdocvar{x} .. (\coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} \coqdocvar{y} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}}) ..).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们不必完全理解这些声明，但如果你感兴趣的话，我会大致说明一下
    发生了什么。注解 ``\coqdoctac{right} \coqdockw{associativity}'' 告诉 Coq 当遇到多个 ::
    时如何给表达式加括号，如此一来下面三个声明做的就是同一件事： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.mylist1}{mylist1}{\coqdocdefinition{mylist1}} := 1 \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{(}}2 \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{(}}3 \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}}\coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{))}}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.mylist2}{mylist2}{\coqdocdefinition{mylist2}} := 1 \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} 2 \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} 3 \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.mylist3}{mylist3}{\coqdocdefinition{mylist3}} := \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
``\coqdoctac{at} \coqdockw{level} 60'' 告诉 Coq 当遇到表达式和其它中缀运算符时应该如何加括号。
    例如，我们已经为 \coqref{LF.Basics.NatPlayground2.plus}{\coqdocdefinition{plus}} 函数定义了 + 中缀符号，它的优先级是 50：


  Notation ``x + y'' := (plus x y)
                      (at level 50, left associativity).


    + 会比 :: 结合的更紧密，所以 1 + 2 :: [3] 会被解析成
    (1 + 2) :: [3] 而非 1 + (2 :: [3])。


   (当你在 .\coqdocvariable{v} 文件中看到“1 + (2 :: [3])”这样的记法时可能会很疑惑。
   最里面那个括住了 3 的方括号，标明了它是一个列表。而外层的方括号则是用来指示
   “coqdoc”这部分要被显示为代码而非普通的文本；在生成的 HTML
   文件中，外层的方括号是看不到的。)


   上面的第二和第三个 \coqdockw{Notation} 声明引入了标准的方括号记法来表示列表；
   第三个声明的右半部分展示了在 Coq 中声明 n 元记法的语法，
   以及将它们翻译成嵌套的二元构造子序列的方法。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Repeat}



 接下来我们看几个用来构造和操作列表的函数。第一个是 \coqdoctac{repeat}
    函数，它接受一个数字 \coqdocvariable{n} 和一个 \coqref{LF.Lists.NatList.count}{\coqdocdefinition{count}}，返回一个长度为
    \coqref{LF.Lists.NatList.count}{\coqdocdefinition{count}}，每个元素都是 \coqdocvariable{n} 的列表。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Lists.NatList.repeat}{repeat}{\coqdocdefinition{repeat}} (\coqdocvar{n} \coqdocvar{count} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{count} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{count'} \ensuremath{\Rightarrow} \coqdocvariable{n} \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{(}}\coqref{LF.Lists.repeat}{\coqdocdefinition{repeat}} \coqdocvariable{n} \coqdocvar{count'}\coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Length}



 \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} 函数用来计算列表的长度。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Lists.NatList.length}{length}{\coqdocdefinition{length}} (\coqdocvar{l}:\coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} \ensuremath{\Rightarrow} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{t} \ensuremath{\Rightarrow} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqref{LF.Lists.length}{\coqdocdefinition{length}} \coqdocvar{t})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Append}



 \coqref{LF.Lists.NatList.app}{\coqdocdefinition{app}} 函数用来把两个列表联接起来。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Lists.NatList.app}{app}{\coqdocdefinition{app}} (\coqdocvar{l1} \coqdocvar{l2} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}) : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l1} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}}    \ensuremath{\Rightarrow} \coqdocvariable{l2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{h} \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{(}}\coqref{LF.Lists.app}{\coqdocdefinition{app}} \coqdocvar{t} \coqdocvariable{l2}\coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
由于下文中 \coqref{LF.Lists.NatList.app}{\coqdocdefinition{app}} 随处可见，不妨将其定义为中缀运算符。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Lists.NatList.:::x '++' x}{"}{"}x ++ y" := (\coqref{LF.Lists.NatList.app}{\coqdocdefinition{app}} \coqdocvar{x} \coqdocvar{y})\coqdoceol
\coqdocindent{10.50em}
(\coqdoctac{right} \coqdockw{associativity}, \coqdoctac{at} \coqdockw{level} 60).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test app1}{test\_app1}{\coqdocdefinition{test\_app1}}:             \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test app2}{test\_app2}{\coqdocdefinition{test\_app2}}:             \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test app3}{test\_app3}{\coqdocdefinition{test\_app3}}:             \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Head 与 Tail}



 下面介绍列表上的两种运算：\coqref{LF.Lists.NatList.hd}{\coqdocdefinition{hd}} 函数返回列表的第一个元素（即“表头”）；
    \coqref{LF.Lists.NatList.tl}{\coqdocdefinition{tl}} 函数返回列表除去第一个元素以外的部分（即“表尾”）。由于空表没有表头，
    我们必须传入一个参数作为返回的默认值。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.hd}{hd}{\coqdocdefinition{hd}} (\coqdocvar{default}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{l}:\coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} \ensuremath{\Rightarrow} \coqdocvariable{default}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{h}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.tl}{tl}{\coqdocdefinition{tl}} (\coqdocvar{l}:\coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}) : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} \ensuremath{\Rightarrow} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{t}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test hd1}{test\_hd1}{\coqdocdefinition{test\_hd1}}:             \coqref{LF.Lists.NatList.hd}{\coqdocdefinition{hd}} 0 \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 1.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test hd2}{test\_hd2}{\coqdocdefinition{test\_hd2}}:             \coqref{LF.Lists.NatList.hd}{\coqdocdefinition{hd}} 0 \coqref{LF.Lists.NatList.:::'[' ']'}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test tl}{test\_tl}{\coqdocdefinition{test\_tl}}:              \coqref{LF.Lists.NatList.tl}{\coqdocdefinition{tl}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{练习}



\paragraph{练习：2 星, standard, recommended (list\_funs)}




    完成以下 \coqref{LF.Lists.NatList.nonzeros}{\coqdocdefinition{nonzeros}}、\coqref{LF.Lists.NatList.oddmembers}{\coqdocdefinition{oddmembers}} 和 \coqref{LF.Lists.NatList.countoddmembers}{\coqdocdefinition{countoddmembers}} 的定义，
    你可以查看测试函数来理解这些函数应该做什么。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Lists.NatList.nonzeros}{nonzeros}{\coqdocdefinition{nonzeros}} (\coqdocvar{l}:\coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}) : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test nonzeros}{test\_nonzeros}{\coqdocdefinition{test\_nonzeros}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.nonzeros}{\coqdocaxiom{nonzeros}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}0\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Lists.NatList.oddmembers}{oddmembers}{\coqdocdefinition{oddmembers}} (\coqdocvar{l}:\coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}) : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test oddmembers}{test\_oddmembers}{\coqdocdefinition{test\_oddmembers}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.oddmembers}{\coqdocaxiom{oddmembers}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}0\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.countoddmembers}{countoddmembers}{\coqdocdefinition{countoddmembers}} (\coqdocvar{l}:\coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test countoddmembers1}{test\_countoddmembers1}{\coqdocdefinition{test\_countoddmembers1}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.countoddmembers}{\coqdocaxiom{countoddmembers}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}0\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 4.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test countoddmembers2}{test\_countoddmembers2}{\coqdocdefinition{test\_countoddmembers2}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.countoddmembers}{\coqdocaxiom{countoddmembers}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}0\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test countoddmembers3}{test\_countoddmembers3}{\coqdocdefinition{test\_countoddmembers3}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.countoddmembers}{\coqdocaxiom{countoddmembers}} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, advanced (alternate)}




    完成以下 \coqref{LF.Lists.NatList.alternate}{\coqdocdefinition{alternate}} 的定义，它从两个列表中交替地取出元素并合并为一个列表，
    就像把拉链“拉”起来一样。更多具体示例见后面的测试。


    （注意：\coqref{LF.Lists.NatList.alternate}{\coqdocdefinition{alternate}} 有一种自然而优雅的定义，但是这一定义无法满足 Coq
    对于 \coqdockw{Fixpoint} 必须“显然会终止”的要求。如果你发现你被这种解法束缚住了，
    可以试着换一种稍微啰嗦一点的解法，比如同时对两个列表中的元素进行操作。
    有种可行的解法需要定义新的序对，但这并不是唯一的方法。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Lists.NatList.alternate}{alternate}{\coqdocdefinition{alternate}} (\coqdocvar{l1} \coqdocvar{l2} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}) : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test alternate1}{test\_alternate1}{\coqdocdefinition{test\_alternate1}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.alternate}{\coqdocaxiom{alternate}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test alternate2}{test\_alternate2}{\coqdocdefinition{test\_alternate2}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.alternate}{\coqdocaxiom{alternate}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test alternate3}{test\_alternate3}{\coqdocdefinition{test\_alternate3}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.alternate}{\coqdocaxiom{alternate}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test alternate4}{test\_alternate4}{\coqdocdefinition{test\_alternate4}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.alternate}{\coqdocaxiom{alternate}} \coqref{LF.Lists.NatList.:::'[' ']'}{\coqdocnotation{[]}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}20\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}30\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}20\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}30\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{用列表实现口袋（Bag）}



 \coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}}（或者叫 \coqdocvar{multiset} 多重集）类似于集合，只是其中每个元素都能出现不止一次。
   口袋的一种可行的表示是列表。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.bag}{bag}{\coqdocdefinition{bag}} := \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：3 星, standard, recommended (bag\_functions)}




    为袋子完成以下 \coqref{LF.Lists.NatList.count}{\coqdocdefinition{count}}、\coqref{LF.Lists.NatList.sum}{\coqdocdefinition{sum}}、\coqref{LF.Lists.NatList.add}{\coqdocdefinition{add}}、和 \coqref{LF.Lists.NatList.member}{\coqdocdefinition{member}} 函数的定义。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Lists.NatList.count}{count}{\coqdocdefinition{count}} (\coqdocvar{v}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{s}:\coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这些命题都能通过 \coqdoctac{reflexivity} 来证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test count1}{test\_count1}{\coqdocdefinition{test\_count1}}:              \coqref{LF.Lists.NatList.count}{\coqdocaxiom{count}} 1 \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 3.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test count2}{test\_count2}{\coqdocdefinition{test\_count2}}:              \coqref{LF.Lists.NatList.count}{\coqdocaxiom{count}} 6 \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Multiset \coqref{LF.Lists.NatList.sum}{\coqdocdefinition{sum}} is similar to set \coqdocvar{union}: \coqref{LF.Lists.NatList.sum}{\coqdocdefinition{sum}} \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} contains all
    the elements of \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} and of \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}}.  (Mathematicians usually define
    \coqdocvar{union} on multisets a little bit differently -- using max instead
    of sum -- which is why we don't call this operation \coqdocvar{union}.)  For
    \coqref{LF.Lists.NatList.sum}{\coqdocdefinition{sum}}, we're giving you a header that does not give explicit names
    to the arguments.  Moreover, it uses the keyword \coqdockw{Definition}
    instead of \coqdockw{Fixpoint}, so even if you had names for the arguments,
    you wouldn't be able to process them recursively.  The point of
    stating the question this way is to encourage you to think about
    whether \coqref{LF.Lists.NatList.sum}{\coqdocdefinition{sum}} can be implemented in another way -- perhaps by
    using one or more functions that have already been defined.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.sum}{sum}{\coqdocdefinition{sum}} : \coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test sum1}{test\_sum1}{\coqdocdefinition{test\_sum1}}:              \coqref{LF.Lists.NatList.count}{\coqdocaxiom{count}} 1 (\coqref{LF.Lists.NatList.sum}{\coqdocaxiom{sum}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 3.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.add}{add}{\coqdocdefinition{add}} (\coqdocvar{v}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{s}:\coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}}) : \coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test add1}{test\_add1}{\coqdocdefinition{test\_add1}}:                \coqref{LF.Lists.NatList.count}{\coqdocaxiom{count}} 1 (\coqref{LF.Lists.NatList.add}{\coqdocaxiom{add}} 1 \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 3.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test add2}{test\_add2}{\coqdocdefinition{test\_add2}}:                \coqref{LF.Lists.NatList.count}{\coqdocaxiom{count}} 5 (\coqref{LF.Lists.NatList.add}{\coqdocaxiom{add}} 1 \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.member}{member}{\coqdocdefinition{member}} (\coqdocvar{v}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{s}:\coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test member1}{test\_member1}{\coqdocdefinition{test\_member1}}:             \coqref{LF.Lists.NatList.member}{\coqdocaxiom{member}} 1 \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test member2}{test\_member2}{\coqdocdefinition{test\_member2}}:             \coqref{LF.Lists.NatList.member}{\coqdocaxiom{member}} 2 \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard, optional (bag\_more\_functions)}




    你可以把下面这些和 \coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}} 有关的函数当作额外的练习 

 倘若某口袋不包含所要移除的数字，那么将 \coqref{LF.Lists.NatList.remove one}{\coqdocdefinition{remove\_one}} 作用其上不应改变其内容。
    （本练习为选做，但高级班的学生为了完成后面的练习，需要写出 \coqref{LF.Lists.NatList.remove one}{\coqdocdefinition{remove\_one}}
    的定义。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Lists.NatList.remove one}{remove\_one}{\coqdocdefinition{remove\_one}} (\coqdocvar{v}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{s}:\coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}}) : \coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test remove one1}{test\_remove\_one1}{\coqdocdefinition{test\_remove\_one1}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.count}{\coqdocaxiom{count}} 5 (\coqref{LF.Lists.NatList.remove one}{\coqdocaxiom{remove\_one}} 5 \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test remove one2}{test\_remove\_one2}{\coqdocdefinition{test\_remove\_one2}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.count}{\coqdocaxiom{count}} 5 (\coqref{LF.Lists.NatList.remove one}{\coqdocaxiom{remove\_one}} 5 \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test remove one3}{test\_remove\_one3}{\coqdocdefinition{test\_remove\_one3}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.count}{\coqdocaxiom{count}} 4 (\coqref{LF.Lists.NatList.remove one}{\coqdocaxiom{remove\_one}} 5 \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 2.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test remove one4}{test\_remove\_one4}{\coqdocdefinition{test\_remove\_one4}}:\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.count}{\coqdocaxiom{count}} 5 (\coqref{LF.Lists.NatList.remove one}{\coqdocaxiom{remove\_one}} 5 \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 1.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Lists.NatList.remove all}{remove\_all}{\coqdocdefinition{remove\_all}} (\coqdocvar{v}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{s}:\coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}}) : \coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test remove all1}{test\_remove\_all1}{\coqdocdefinition{test\_remove\_all1}}:  \coqref{LF.Lists.NatList.count}{\coqdocaxiom{count}} 5 (\coqref{LF.Lists.NatList.remove all}{\coqdocaxiom{remove\_all}} 5 \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test remove all2}{test\_remove\_all2}{\coqdocdefinition{test\_remove\_all2}}:  \coqref{LF.Lists.NatList.count}{\coqdocaxiom{count}} 5 (\coqref{LF.Lists.NatList.remove all}{\coqdocaxiom{remove\_all}} 5 \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test remove all3}{test\_remove\_all3}{\coqdocdefinition{test\_remove\_all3}}:  \coqref{LF.Lists.NatList.count}{\coqdocaxiom{count}} 4 (\coqref{LF.Lists.NatList.remove all}{\coqdocaxiom{remove\_all}} 5 \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 2.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test remove all4}{test\_remove\_all4}{\coqdocdefinition{test\_remove\_all4}}:  \coqref{LF.Lists.NatList.count}{\coqdocaxiom{count}} 5 (\coqref{LF.Lists.NatList.remove all}{\coqdocaxiom{remove\_all}} 5 \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Lists.NatList.subset}{subset}{\coqdocdefinition{subset}} (\coqdocvar{s1}:\coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}}) (\coqdocvar{s2}:\coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test subset1}{test\_subset1}{\coqdocdefinition{test\_subset1}}:              \coqref{LF.Lists.NatList.subset}{\coqdocaxiom{subset}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test subset2}{test\_subset2}{\coqdocdefinition{test\_subset2}}:              \coqref{LF.Lists.NatList.subset}{\coqdocaxiom{subset}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, recommended (bag\_theorem)}




    写一个你认为有趣的关于袋子的定理 \coqdocvar{bag\_theorem}，然后证明它；
    这个定理需要用到 \coqref{LF.Lists.NatList.count}{\coqdocdefinition{count}} 和 \coqref{LF.Lists.NatList.add}{\coqdocdefinition{add}}。注意，这是个开放性问题。
    也许你写下的定理是正确的，但它可能会涉及到你尚未学过的技巧因而无法证明。
    如果你遇到麻烦了，欢迎提问！ \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.manual grade for bag theorem}{manual\_grade\_for\_bag\_theorem}{\coqdocdefinition{manual\_grade\_for\_bag\_theorem}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{有关列表的论证}



 和数字一样，有些列表处理函数的简单事实仅通过化简就能证明。
    例如，对于下面这个例子，\coqdoctac{reflexivity} 所做的简化就已经足够了... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.nil app}{nil\_app}{\coqdoclemma{nil\_app}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l}:\coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.:::'[' ']'}{\coqdocnotation{[]}} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
...由于 [] 被替换进了 \coqref{LF.Lists.NatList.app}{\coqdocdefinition{app}} 定义中相应的“被检”分支
    （即经由匹配“仔细检查”过值的表达式），整个匹配得以被简化。 

 和数字一样，有时对一个列表做分类讨论（是否是空）是非常有用的。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.tl length pred}{tl\_length\_pred}{\coqdoclemma{tl\_length\_pred}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l}:\coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{pred}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{pred}} (\coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} (\coqref{LF.Lists.NatList.tl}{\coqdocdefinition{tl}} \coqdocvariable{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l}. \coqdoctac{destruct} \coqdocvar{l} \coqdockw{as} [| \coqdocvar{n} \coqdocvar{l'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在这里 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} 的情况能够工作是因为我们定义了 \coqref{LF.Lists.NatList.tl}{\coqdocdefinition{tl}} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} = \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}}，
    而 \coqdoctac{destruct} 策略中 \coqdockw{as} 注解引入的两个名字，\coqdocvariable{n} 和 \coqdocvariable{l'}，分别对应了
    \coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 构造子的两个参数（正在构造的列表的头和尾）。 

 然而一般来说，许多关于列表的有趣定理都需要用到归纳法来证明，
    接下来我们就会看到证明的方法。 

 （一点点说教：随着不断地深入，若你只是\textit{'阅读'}证明的话，
    并不会获得什么特别有用的东西。搞清楚每一个细节非常重要，你应该在
    Coq 中单步执行这些证明并思考每一步在整个证明中的作用，否则练习题将毫无用处。
    啰嗦完毕。） \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{对列表进行归纳}



 比起对自然数的归纳，读者可能对归纳证明 \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}} 这样的数据类型更加陌生。
    不过基本思路同样简单。每个 \coqdockw{Inductive} 声明定义了一组数据值，
    这些值可以用声明过的构造子来构造。例如，布尔值可以用 \coqref{LF.Basics.true}{\coqdocconstructor{true}} 或 \coqref{LF.Basics.false}{\coqdocconstructor{false}} 来构造；
    自然数可以用 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} 或 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 应用到另一个自然数上来构造；而列表可以用 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}}
    或者将 \coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 应用到一个自然数和另一个列表上来构造。
    除此以外，归纳定义的集合中元素的形式 \textit{'只能是'} 构造子对其它项的应用。


    这一事实同时也给出了一种对归纳定义的集合进行论证的方法：一个自然数要么是
    \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}}，要么就是 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 应用到某个\textit{'更小'}的自然数上；一个列表要么是 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}}，
    要么就是 \coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 应用到某个数字和某个\textit{'更小'}的列表上，诸如此类。
    所以，如果我们有某个命题 \coqdocvariable{P} 涉及列表 \coqdocvariable{l}，而我们想证明 \coqdocvariable{P} 对 \textit{'一切'}
    列表都成立，那么可以像这样推理：



\begin{itemize}
\item  首先，证明当 \coqdocvariable{l} 为 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} 时 \coqdocvariable{P} \coqdocvariable{l} 成立。



\item  然后，证明当 \coqdocvariable{l} 为 \coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} \coqdocvariable{n} \coqdocvariable{l'} 时 \coqdocvariable{P} \coqdocvariable{l} 成立，其中 \coqdocvariable{n} 是某个自然数，\coqdocvariable{l'}
      是某个更小的列表，假设 \coqdocvariable{P} \coqdocvariable{l'} 成立.

\end{itemize}


    由于较大的列表总是能够分解为较小的列表，最终这个较小的列表会变成
    \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}}，这两点合在一起就完成了 \coqdocvariable{P} 对一切列表 \coqdocvariable{l} 成立的证明。下面是个具体的例子： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.app assoc}{app\_assoc}{\coqdoclemma{app\_assoc}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l1} \coqdocvar{l2} \coqdocvar{l3} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{(}}\coqdocvariable{l1} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{l2}\coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{)}} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{l3} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{l1} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{(}}\coqdocvariable{l2} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{l3}\coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l1} \coqdocvar{l2} \coqdocvar{l3}. \coqdoctac{induction} \coqdocvar{l1} \coqdockw{as} [| \coqdocvar{n} \coqdocvar{l1'} \coqdocvar{IHl1'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHl1'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
注意，和归纳自然数时一样，此处 \coqdoctac{induction} 策略的 \coqdockw{as}... 从句为在
    “\coqdocvariable{l1} 由构造子 \coqref{LF.Lists.NatList.cons}{\coqdocconstructor{cons}} 构造而来”这一情况时出现的“更小的列表”和归纳假设取了名字。


    再次强调，如果你把 Coq 的证明当做静态的文档，那么可能不会有特别多的收获 ——
    如果你通过交互式的 Coq 会话来阅读证明，就能看到当前的目标和上下文，
    而这些状态在你阅读写下来的脚本时是不可见的。所以一份用自然语言写成的证明 ——
    写给人看的 —— 需要包含更多的提示来帮助读者理解当前的状态，
    比如第二种情况下的归纳假设到底是什么。 

 \textit{'定理'}：对所有的列表 \coqdocvariable{l1}, \coqdocvariable{l2}, 和 \coqdocvariable{l3}，
   (\coqdocvariable{l1} ++ \coqdocvariable{l2}) ++ \coqdocvariable{l3} = \coqdocvariable{l1} ++ (\coqdocvariable{l2} ++ \coqdocvariable{l3})。


   \textit{'证明'}: 通过对 \coqdocvariable{l1} 使用归纳法。



\begin{itemize}
\item  首先, 假设 \coqdocvariable{l1} = []。我们必须证明：


       (\ensuremath{\Box} ++ l2) ++ l3 = \ensuremath{\Box} ++ (l2 ++ l3),


     这可以通过展开 ++ 的定义得到。



\item  然后, 假设 \coqdocvariable{l1} = \coqdocvariable{n}::\coqdocvar{l1'}，有：


       (l1' ++ l2) ++ l3 = l1' ++ (l2 ++ l3)


     （归纳假设）。我们必须证明：


       ((n :: l1') ++ l2) ++ l3 = (n :: l1') ++ (l2 ++ l3).


     根据 ++ 的定义, 上式等价于：


       n :: ((l1' ++ l2) ++ l3) = n :: (l1' ++ (l2 ++ l3)),


     该式可通过我们的归纳假设立即证得。  \ensuremath{\Box} 
\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsubsection{反转列表}



 举一个更加深入的例子来说明对列表的归纳证明：假设我们使用 \coqref{LF.Lists.NatList.app}{\coqdocdefinition{app}}
    来定义一个列表反转函数 \coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}}： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Lists.NatList.rev}{rev}{\coqdocdefinition{rev}} (\coqdocvar{l}:\coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}) : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}}    \ensuremath{\Rightarrow} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{t} \ensuremath{\Rightarrow} \coqref{LF.Lists.rev}{\coqdocdefinition{rev}} \coqdocvar{t} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}\coqdocvar{h}\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test rev1}{test\_rev1}{\coqdocdefinition{test\_rev1}}:            \coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test rev2}{test\_rev2}{\coqdocdefinition{test\_rev2}}:            \coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
为了比目前所见的证明多一点挑战性，
    我们来证明反转一个列表不会改变它的长度。
    我们的首次尝试在后继这一分支上卡住了.... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.rev length firsttry}{rev\_length\_firsttry}{\coqdoclemma{rev\_length\_firsttry}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} (\coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l}. \coqdoctac{induction} \coqdocvar{l} \coqdockw{as} [| \coqdocvar{n} \coqdocvar{l'} \coqdocvar{IHl'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{IHl'}.\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
不妨单独提出引理，阐述 ++ 与 \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} 形成的等式关系，
    以从我们卡住的地方推进证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.app length}{app\_length}{\coqdoclemma{app\_length}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l1} \coqdocvar{l2} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} (\coqdocvariable{l1} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{l2}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} \coqdocvariable{l1}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} \coqdocvariable{l2}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l1} \coqdocvar{l2}. \coqdoctac{induction} \coqdocvar{l1} \coqdockw{as} [| \coqdocvar{n} \coqdocvar{l1'} \coqdocvar{IHl1'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHl1'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
注意，为了让该引理尽可能 \textit{'通用'}，我们不仅关心由 \coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} 得到的列表，
    还要对 \textit{'所有'} 的 \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}} 进行全称量化。这很自然，因为这个证明目标
    显然不依赖于被反转的列表。除此之外，证明这个更普遍的性质也更容易些。 

 现在我们可以完成最初的证明了。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.rev length}{rev\_length}{\coqdoclemma{rev\_length}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} (\coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l}. \coqdoctac{induction} \coqdocvar{l} \coqdockw{as} [| \coqdocvar{n} \coqdocvar{l'} \coqdocvar{IHl'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqref{LF.Lists.NatList.app length}{\coqdoclemma{app\_length}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHl'}. \coqdoctac{rewrite} \coqref{LF.Induction.plus comm}{\coqdocaxiom{plus\_comm}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
作为对比，以下是这两个定理的非形式化证明：


    \textit{'定理'}：对于所有的列表 \coqdocvariable{l1} 和 \coqdocvariable{l2}，
       \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} (\coqdocvariable{l1} ++ \coqdocvariable{l2}) = \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} \coqdocvariable{l1} + \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} \coqdocvariable{l2}.


    \textit{'证明'}：对 \coqdocvariable{l1} 进行归纳。



\begin{itemize}
\item  首先，假设 \coqdocvariable{l1} = []。我们必须证明


        length (\ensuremath{\Box} ++ l2) = length \ensuremath{\Box} + length l2,


      根据 \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}}、++ 和 \coqref{LF.Basics.NatPlayground2.plus}{\coqdocdefinition{plus}} 的定义，上式显然可得。



\item  其次，假设 \coqdocvariable{l1} = \coqdocvariable{n}::\coqdocvar{l1'}，并且


        length (l1' ++ l2) = length l1' + length l2.


      我们必须证明


        length ((n::l1') ++ l2) = length (n::l1') + length l2.


      根据 \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} 和 ++ 的定义以及归纳假设，上式显然可得。 \ensuremath{\Box} 
\end{itemize}


 \textit{'定理'}: 对于所有的列表 \coqdocvariable{l}，\coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} (\coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} \coqdocvariable{l}) = \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} \coqdocvariable{l}。


    \textit{'证明'}: 对 \coqdocvariable{l} 进行归纳。



\begin{itemize}
\item  首先，假设 \coqdocvariable{l} = []。我们必须证明


          length (rev \ensuremath{\Box}) = length \ensuremath{\Box},


        根据 \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} 和 \coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} 的定义，上式显然可得。



\item  其次，假设 \coqdocvariable{l} = \coqdocvariable{n}::\coqdocvariable{l'}，并且


          length (rev l') = length l'.


        我们必须证明


          length (rev (n :: l')) = length (n :: l').


        根据 \coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} 的定义，上式来自于


          length ((rev l') ++ \coqdocvariable{n}) = S (length l')


        根据之前的引理，此式等同于


          length (rev l') + length \coqdocvariable{n} = S (length l').


        根据归纳假设和 \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} 的定义，上式显然可得。 \ensuremath{\Box} 
\end{itemize}


 这些证明的风格实在是冗长而迂腐。读多了之后，我们会发现减少细枝末节，
    详述不太显然的步骤更有助于我们理解证明。毕竟细节更容易在大脑中思考，
    必要时我们还可以在草稿纸上补全。下面我们以一种更加紧凑的方式呈现之前的证明： 

 \textit{'定理'}：对于所有 \coqdocvariable{l}，\coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} (\coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} \coqdocvariable{l}) = \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} \coqdocvariable{l}。


    \textit{'证明'}：首先，观察到 \coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} (\coqdocvariable{l} ++ [\coqdocvariable{n}]) = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Lists.NatList.length}{\coqdocdefinition{length}} \coqdocvariable{l}) 对一切 \coqdocvariable{l} 成立，
    这一点可通过对 \coqdocvariable{l} 的归纳直接得到。当 \coqdocvariable{l} = \coqdocvariable{n'}::\coqdocvariable{l'} 时，通过再次对 \coqdocvariable{l} 使用归纳，
    然后同时使用之前观察得到的性质和归纳假设即可证明。 \ensuremath{\Box} 

 一般而言，在不同的情况下合适的风格也会不同：读者对这个问题了解程度，
    以及当前的证明与读者熟悉的证明之间的相似度都会影响到这一点。
    对于我们现在的目的而言，最好先用更加冗长的方式。 

\subsection{\texorpdfstring{\protect\coqdockw{Search}}{Search} 搜索}



 我们已经见过很多需要使用之前证明过的结论（例如通过 \coqdoctac{rewrite}）来证明的定理了。
    但是在引用别的定理时，我们必须事先知道它们的名字。当然，即使是已被证明的定理本身
    我们都不能全部记住，更不用提它们的名字了。


    Coq 的 \coqdockw{Search} 指令在这时就非常有用了。执行 \coqdockw{Search} \coqref{LF.Tactics.foo}{\coqdocdefinition{foo}} 会让 Coq
    显示所有涉及到 \coqref{LF.Tactics.foo}{\coqdocdefinition{foo}} 的定理。例如，去掉下面的注释后，
    你会看到一个我们证明过的所有关于 \coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} 的定理的列表： \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
在接下来的学习中，你要记得使用 \coqdockw{Search}，它能为你节约大量的时间！


    如果你正在使用 ProofGeneral，那么可以用 \coqdocvar{C}-\coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} \coqdocvar{C}-\coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} \coqdocvar{C}-\coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 来运行 \coqdockw{Search}。
    通过 \coqdocvar{C}-\coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} \coqdocvar{C}-; 可以将它返回的结果粘贴到缓冲区内。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{列表练习，第一部分}



\paragraph{练习：3 星, standard (list\_exercises)}




    更多有关列表的实践： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.app nil r}{app\_nil\_r}{\coqdoclemma{app\_nil\_r}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{l} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.Lists.NatList.:::'[' ']'}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.rev app distr}{rev\_app\_distr}{\coqdoclemma{rev\_app\_distr}}: \coqdockw{\ensuremath{\forall}} \coqdocvar{l1} \coqdocvar{l2} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} (\coqdocvariable{l1} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{l2}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} \coqdocvariable{l2} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} \coqdocvariable{l1}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.rev involutive}{rev\_involutive}{\coqdoclemma{rev\_involutive}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} (\coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} \coqdocvariable{l}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
下面的练习有简短的解法，如果你开始发现情况已经复杂到你无法理清的程度，
    请后退一步并试着寻找更为简单的方法。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.app assoc4}{app\_assoc4}{\coqdoclemma{app\_assoc4}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l1} \coqdocvar{l2} \coqdocvar{l3} \coqdocvar{l4} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{l1} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{(}}\coqdocvariable{l2} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{(}}\coqdocvariable{l3} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{l4}\coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{))}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{((}}\coqdocvariable{l1} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{l2}\coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{)}} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{l3}\coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{)}} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{l4}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
一个关于你对 \coqref{LF.Lists.NatList.nonzeros}{\coqdocdefinition{nonzeros}} 的实现的练习： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Lists.NatList.nonzeros app}{nonzeros\_app}{\coqdoclemma{nonzeros\_app}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l1} \coqdocvar{l2} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.nonzeros}{\coqdocaxiom{nonzeros}} (\coqdocvariable{l1} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqdocvariable{l2}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{(}}\coqref{LF.Lists.NatList.nonzeros}{\coqdocaxiom{nonzeros}} \coqdocvariable{l1}\coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{)}} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{++}} \coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{(}}\coqref{LF.Lists.NatList.nonzeros}{\coqdocaxiom{nonzeros}} \coqdocvariable{l2}\coqref{LF.Lists.NatList.:::x '++' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard (eqblist)}




    填写 \coqref{LF.Lists.NatList.eqblist}{\coqdocdefinition{eqblist}} 的定义，它通过比较列表中的数字来判断是否相等。
    证明对于所有列表 \coqdocvariable{l}，\coqref{LF.Lists.NatList.eqblist}{\coqdocdefinition{eqblist}} \coqdocvariable{l} \coqdocvariable{l} 返回 \coqref{LF.Basics.true}{\coqdocconstructor{true}}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Lists.NatList.eqblist}{eqblist}{\coqdocdefinition{eqblist}} (\coqdocvar{l1} \coqdocvar{l2} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test eqblist1}{test\_eqblist1}{\coqdocdefinition{test\_eqblist1}} :\coqdoceol
\coqdocindent{1.00em}
(\coqref{LF.Lists.NatList.eqblist}{\coqdocaxiom{eqblist}} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}).\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test eqblist2}{test\_eqblist2}{\coqdocdefinition{test\_eqblist2}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.eqblist}{\coqdocaxiom{eqblist}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test eqblist3}{test\_eqblist3}{\coqdocdefinition{test\_eqblist3}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.eqblist}{\coqdocaxiom{eqblist}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}3\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}2\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.eqblist refl}{eqblist\_refl}{\coqdoclemma{eqblist\_refl}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l}:\coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.eqblist}{\coqdocaxiom{eqblist}} \coqdocvariable{l} \coqdocvariable{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{列表练习, 第二部分}



 下面这组简单的定理用于证明你之前关于袋子的定义。 

\paragraph{练习：1 星, standard (count\_member\_nonzero)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.count member nonzero}{count\_member\_nonzero}{\coqdoclemma{count\_member\_nonzero}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{s} : \coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}}),\coqdoceol
\coqdocindent{1.00em}
1 \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{(}}\coqref{LF.Lists.NatList.count}{\coqdocaxiom{count}} 1 (1 \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} \coqdocvariable{s})\coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 下面这条关于 \coqref{LF.Basics.leb}{\coqdocdefinition{leb}} 的引理可助你完成下一个证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.leb n Sn}{leb\_n\_Sn}{\coqdoclemma{leb\_n\_Sn}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{(}}\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}\coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'} \coqdocvar{IHn'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{IHn'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Before doing the next exercise, make sure you've filled in the
   definition of \coqref{LF.Lists.NatList.remove one}{\coqdocdefinition{remove\_one}} above. \paragraph{练习：3 星, advanced (remove\_does\_not\_increase\_count)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.remove does not increase count}{remove\_does\_not\_increase\_count}{\coqdoclemma{remove\_does\_not\_increase\_count}}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{s} : \coqref{LF.Lists.NatList.bag}{\coqdocdefinition{bag}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{(}}\coqref{LF.Lists.NatList.count}{\coqdocaxiom{count}} 0 (\coqref{LF.Lists.NatList.remove one}{\coqdocaxiom{remove\_one}} 0 \coqdocvariable{s})\coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{)}} \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{(}}\coqref{LF.Lists.NatList.count}{\coqdocaxiom{count}} 0 \coqdocvariable{s}\coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard, optional (bag\_count\_sum)}




    写下一个用到函数 \coqref{LF.Lists.NatList.count}{\coqdocdefinition{count}} 和 \coqref{LF.Lists.NatList.sum}{\coqdocdefinition{sum}} 的，关于袋子的有趣定理 \coqdocvar{bag\_count\_sum}，
    然后证明它。（你可能会发现该证明的难度取决于你如何定义 \coqref{LF.Lists.NatList.count}{\coqdocdefinition{count}}！） \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：4 星, advanced (rev\_injective)}




    求证 \coqref{LF.Lists.NatList.rev}{\coqdocdefinition{rev}} 是单射函数，即：


    forall (l1 l2 : natlist), rev l1 = rev l2 -> l1 = l2.


    （这个问题既可以用简单的方式解决也可以用繁琐的方式来解决。） \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.manual grade for rev injective}{manual\_grade\_for\_rev\_injective}{\coqdocdefinition{manual\_grade\_for\_rev\_injective}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Options 可选类型}



 假设我们想要写一个返回某个列表中第 \coqdocvariable{n} 个元素的函数。如果我们为它赋予类型
    \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} \ensuremath{\rightarrow} \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}} \ensuremath{\rightarrow} \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}，那么当列表太短时我们仍须返回某个数... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Lists.NatList.nth bad}{nth\_bad}{\coqdocdefinition{nth\_bad}} (\coqdocvar{l}:\coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}) (\coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} \ensuremath{\Rightarrow} 42\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{a} \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{l'} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvariable{n} \coqdockw{with}\coqdoceol
\coqdocindent{7.50em}
\ensuremath{|} 0 \ensuremath{\Rightarrow} \coqdocvar{a}\coqdoceol
\coqdocindent{7.50em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqref{LF.Lists.nth bad}{\coqdocdefinition{nth\_bad}} \coqdocvar{l'} \coqdocvar{n'}\coqdoceol
\coqdocindent{7.50em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这种方案并不好：如果 \coqref{LF.Lists.NatList.nth bad}{\coqdocdefinition{nth\_bad}} 返回了 42，那么不经过进一步处理的话，
    我们无法得知该值是否真的出现在了输入中。（译注：我们无法判断是什么因素让它返回了
    42，因为它可能是列表过短时的返回值，同时也可能是（此时列表足够长）在列表中找到的值）
    一种更好的方式是改变 \coqref{LF.Lists.NatList.nth bad}{\coqdocdefinition{nth\_bad}} 的返回类型，使其包含一个错误值作为可能的结果。
    我们将此类型命名为 \coqref{LF.Lists.NatList.natoption}{\coqdocinductive{natoption}}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Lists.NatList.natoption}{natoption}{\coqdocinductive{natoption}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Lists.NatList.Some}{Some}{\coqdocconstructor{Some}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Lists.NatList.None}{None}{\coqdocconstructor{None}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
然后我们可以修改前面 \coqref{LF.Lists.NatList.nth bad}{\coqdocdefinition{nth\_bad}} 的定义，使其在列表太短时返回 \coqref{LF.Lists.NatList.None}{\coqdocconstructor{None}}，
    在列表足够长且 \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}} 在 \coqdocvariable{n} 处时返回 \coqref{LF.Lists.NatList.Some}{\coqdocconstructor{Some}} \coqref{LF.Poly.MumbleGrumble.a}{\coqdocconstructor{a}}。我们将这个新函数称为
    \coqref{LF.Lists.NatList.nth error}{\coqdocdefinition{nth\_error}} 来表明它可以产生带错误的结果。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Lists.NatList.nth error}{nth\_error}{\coqdocdefinition{nth\_error}} (\coqdocvar{l}:\coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}) (\coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.Lists.NatList.natoption}{\coqdocinductive{natoption}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} \ensuremath{\Rightarrow} \coqref{LF.Lists.NatList.None}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{a} \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{l'} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvariable{n} \coqdockw{with}\coqdoceol
\coqdocindent{7.50em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqref{LF.Lists.NatList.Some}{\coqdocconstructor{Some}} \coqdocvar{a}\coqdoceol
\coqdocindent{7.50em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqref{LF.Lists.nth error}{\coqdocdefinition{nth\_error}} \coqdocvar{l'} \coqdocvar{n'}\coqdoceol
\coqdocindent{7.50em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test nth error1}{test\_nth\_error1}{\coqdocdefinition{test\_nth\_error1}} : \coqref{LF.Lists.NatList.nth error}{\coqdocdefinition{nth\_error}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}7\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} 0 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.Some}{\coqdocconstructor{Some}} 4.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test nth error2}{test\_nth\_error2}{\coqdocdefinition{test\_nth\_error2}} : \coqref{LF.Lists.NatList.nth error}{\coqdocdefinition{nth\_error}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}7\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} 3 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.Some}{\coqdocconstructor{Some}} 7.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test nth error3}{test\_nth\_error3}{\coqdocdefinition{test\_nth\_error3}} : \coqref{LF.Lists.NatList.nth error}{\coqdocdefinition{nth\_error}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}4\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}7\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} 9 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.None}{\coqdocconstructor{None}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（在 HTML 版本中隐藏了这些老套的证明。若你想看它请点击小方格。）


    本例也是个介绍 Coq 编程语言更多细微特性的机会，比如条件表达式... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Lists.NatList.nth error'}{nth\_error'}{\coqdocdefinition{nth\_error'}} (\coqdocvar{l}:\coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}) (\coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.Lists.NatList.natoption}{\coqdocinductive{natoption}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} \ensuremath{\Rightarrow} \coqref{LF.Lists.NatList.None}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{a} \coqref{LF.Lists.NatList.:::x '::' x}{\coqdocnotation{::}} \coqdocvar{l'} \ensuremath{\Rightarrow} \coqdockw{if} \coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \coqdockw{then} \coqref{LF.Lists.NatList.Some}{\coqdocconstructor{Some}} \coqdocvar{a}\coqdoceol
\coqdocindent{7.50em}
\coqdockw{else} \coqref{LF.Lists.nth error'}{\coqdocdefinition{nth\_error'}} \coqdocvar{l'} (\coqexternalref{pred}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{pred}} \coqdocvariable{n})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Coq 的条件语句和其它语言中的一样，不过加上了一点更为一般化的特性。
    由于 \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 类型不是内建的，因此 Coq 实际上支持在\textit{'任何'}带有两个构造子的，
    归纳定义的类型上使用条件表达式。当断言（guard）求值为 \coqdockw{Inductive}
    定义中的第一个构造子时，它被认为是真的；当它被求值到第二个构造子时，
    则被认为是假的。 

 以下函数从 \coqref{LF.Lists.NatList.natoption}{\coqdocinductive{natoption}} 中取出一个 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}，在遇到 \coqref{LF.Lists.NatList.None}{\coqdocconstructor{None}} 时它将返回提供的默认值。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.option elim}{option\_elim}{\coqdocdefinition{option\_elim}} (\coqdocvar{d} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{o} : \coqref{LF.Lists.NatList.natoption}{\coqdocinductive{natoption}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{o} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.NatList.Some}{\coqdocconstructor{Some}} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqdocvar{n'}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.NatList.None}{\coqdocconstructor{None}} \ensuremath{\Rightarrow} \coqdocvariable{d}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard (hd\_error)}

 用同样的思路修正之前的 \coqref{LF.Lists.NatList.hd}{\coqdocdefinition{hd}} 函数，使我们无需为 \coqref{LF.Lists.NatList.nil}{\coqdocconstructor{nil}} 的情况提供默认元素。  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.NatList.hd error}{hd\_error}{\coqdocdefinition{hd\_error}} (\coqdocvar{l} : \coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}) : \coqref{LF.Lists.NatList.natoption}{\coqdocinductive{natoption}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test hd error1}{test\_hd\_error1}{\coqdocdefinition{test\_hd\_error1}} : \coqref{LF.Lists.NatList.hd error}{\coqdocaxiom{hd\_error}} \coqref{LF.Lists.NatList.:::'[' ']'}{\coqdocnotation{[]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.None}{\coqdocconstructor{None}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test hd error2}{test\_hd\_error2}{\coqdocdefinition{test\_hd\_error2}} : \coqref{LF.Lists.NatList.hd error}{\coqdocaxiom{hd\_error}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}1\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.Some}{\coqdocconstructor{Some}} 1.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Lists.NatList.test hd error3}{test\_hd\_error3}{\coqdocdefinition{test\_hd\_error3}} : \coqref{LF.Lists.NatList.hd error}{\coqdocaxiom{hd\_error}} \coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{[}}5\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{;}}6\coqref{LF.Lists.NatList.:::'[' x ';' '..' ';' x ']'}{\coqdocnotation{]}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.Some}{\coqdocconstructor{Some}} 5.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：1 星, standard, optional (option\_elim\_hd)}

 此练习能帮助你在新的 \coqref{LF.Lists.NatList.hd error}{\coqdocdefinition{hd\_error}} 和旧的 \coqref{LF.Lists.NatList.hd}{\coqdocdefinition{hd}} 之间建立联系。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.NatList.option elim hd}{option\_elim\_hd}{\coqdoclemma{option\_elim\_hd}} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{l}:\coqref{LF.Lists.NatList.natlist}{\coqdocinductive{natlist}}) (\coqdocvar{default}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.NatList.hd}{\coqdocdefinition{hd}} \coqdocvariable{default} \coqdocvariable{l} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.option elim}{\coqdocdefinition{option\_elim}} \coqdocvariable{default} (\coqref{LF.Lists.NatList.hd error}{\coqdocaxiom{hd\_error}} \coqdocvariable{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.Lists.NatList}{\coqdocmodule{NatList}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{偏映射（Partial Maps）}



 最后演示一下如何在 Coq 中定义基础的数据结构。这是一个简单的
    \textit{'偏映射'} 数据类型，它类似于大多数编程语言中的映射或字典数据结构。 

 首先，我们定义一个新的归纳数据类型 \coqref{LF.Lists.id}{\coqdocinductive{id}} 来用作偏映射的“键”。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Lists.id}{id}{\coqdocinductive{id}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Lists.Id}{Id}{\coqdocconstructor{Id}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
本质上来说，\coqref{LF.Lists.id}{\coqdocinductive{id}} 只是一个数。但通过 \coqref{LF.Lists.Id}{\coqdocconstructor{Id}} 标签封装自然数来引入新的类型，
    能让定义变得更加可读，同时也给了我们更多的灵活性。 

 我们还需要一个 \coqref{LF.Lists.id}{\coqdocinductive{id}} 的相等关系测试： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.eqb id}{eqb\_id}{\coqdocdefinition{eqb\_id}} (\coqdocvar{x1} \coqdocvar{x2} : \coqref{LF.Lists.id}{\coqdocinductive{id}}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{x1}, \coqdocvariable{x2} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.Id}{\coqdocconstructor{Id}} \coqdocvar{n1}, \coqref{LF.Lists.Id}{\coqdocconstructor{Id}} \coqdocvar{n2} \ensuremath{\Rightarrow} \coqdocvar{n1} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvar{n2}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, standard (eqb\_id\_refl)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.eqb id refl}{eqb\_id\_refl}{\coqdoclemma{eqb\_id\_refl}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.eqb id}{\coqdocdefinition{eqb\_id}} \coqdocvariable{x} \coqdocvariable{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 现在我们定义偏映射的类型： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Lists.PartialMap}{PartialMap}{\coqdocmodule{PartialMap}}.\coqdoceol
\coqdocnoindent
\coqdockw{Export} \coqdocvar{NatList}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Lists.PartialMap.partial map}{partial\_map}{\coqdocinductive{partial\_map}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Lists.PartialMap.empty}{empty}{\coqdocconstructor{empty}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Lists.PartialMap.record}{record}{\coqdocconstructor{record}} (\coqdocvar{i} : \coqref{LF.Lists.id}{\coqdocinductive{id}}) (\coqdocvar{v} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{m} : \coqref{LF.Lists.partial map}{\coqdocinductive{partial\_map}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
此声明可以读作：“有两种方式可以构造一个 \coqref{LF.Lists.PartialMap.partial map}{\coqdocinductive{partial\_map}}：用构造子 \coqref{LF.Lists.PartialMap.empty}{\coqdocconstructor{empty}}
    表示一个空的偏映射，或将构造子 \coqref{LF.Lists.PartialMap.record}{\coqdocconstructor{record}} 应用到一个键、一个值和一个既有的
    \coqref{LF.Lists.PartialMap.partial map}{\coqdocinductive{partial\_map}} 来构造一个带“键-值”映射 的 \coqref{LF.Lists.PartialMap.partial map}{\coqdocinductive{partial\_map}}。”

 \coqref{LF.Lists.PartialMap.update}{\coqdocdefinition{update}} 函数在部分映射中覆盖给定的键以取缔原值（如该键尚不存在，
    则新建其记录）。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.PartialMap.update}{update}{\coqdocdefinition{update}} (\coqdocvar{d} : \coqref{LF.Lists.PartialMap.partial map}{\coqdocinductive{partial\_map}})\coqdoceol
\coqdocindent{9.00em}
(\coqdocvar{x} : \coqref{LF.Lists.id}{\coqdocinductive{id}}) (\coqdocvar{value} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}})\coqdoceol
\coqdocindent{9.00em}
: \coqref{LF.Lists.PartialMap.partial map}{\coqdocinductive{partial\_map}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Lists.PartialMap.record}{\coqdocconstructor{record}} \coqdocvariable{x} \coqdocvariable{value} \coqdocvariable{d}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
最后，\coqref{LF.Lists.PartialMap.find}{\coqdocdefinition{find}} 函数按照给定的键搜索一个 \coqref{LF.Lists.PartialMap.partial map}{\coqdocinductive{partial\_map}}。若该键无法找到，
    它就返回 \coqref{LF.Lists.NatList.None}{\coqdocconstructor{None}}；若该键与 \coqdocvar{val} 相关联，则返回 \coqref{LF.Lists.NatList.Some}{\coqdocconstructor{Some}} \coqdocvar{val}。
    若同一个键被映到多个值，\coqref{LF.Lists.PartialMap.find}{\coqdocdefinition{find}} 就会返回它遇到的第一个值。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Lists.PartialMap.find}{find}{\coqdocdefinition{find}} (\coqdocvar{x} : \coqref{LF.Lists.id}{\coqdocinductive{id}}) (\coqdocvar{d} : \coqref{LF.Lists.PartialMap.partial map}{\coqdocinductive{partial\_map}}) : \coqref{LF.Lists.NatList.natoption}{\coqdocinductive{natoption}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{d} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.PartialMap.empty}{\coqdocconstructor{empty}}         \ensuremath{\Rightarrow} \coqref{LF.Lists.NatList.None}{\coqdocconstructor{None}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Lists.PartialMap.record}{\coqdocconstructor{record}} \coqdocvar{y} \coqdocvar{v} \coqdocvar{d'} \ensuremath{\Rightarrow} \coqdockw{if} \coqref{LF.Lists.eqb id}{\coqdocdefinition{eqb\_id}} \coqdocvariable{x} \coqdocvar{y}\coqdoceol
\coqdocindent{10.50em}
\coqdockw{then} \coqref{LF.Lists.NatList.Some}{\coqdocconstructor{Some}} \coqdocvar{v}\coqdoceol
\coqdocindent{10.50em}
\coqdockw{else} \coqref{LF.Lists.find}{\coqdocdefinition{find}} \coqdocvariable{x} \coqdocvar{d'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, standard (update\_eq)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.PartialMap.update eq}{update\_eq}{\coqdoclemma{update\_eq}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{d} : \coqref{LF.Lists.PartialMap.partial map}{\coqdocinductive{partial\_map}}) (\coqdocvar{x} : \coqref{LF.Lists.id}{\coqdocinductive{id}}) (\coqdocvar{v}: \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Lists.PartialMap.find}{\coqdocdefinition{find}} \coqdocvariable{x} (\coqref{LF.Lists.PartialMap.update}{\coqdocdefinition{update}} \coqdocvariable{d} \coqdocvariable{x} \coqdocvariable{v}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.NatList.Some}{\coqdocconstructor{Some}} \coqdocvariable{v}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：1 星, standard (update\_neq)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Lists.PartialMap.update neq}{update\_neq}{\coqdoclemma{update\_neq}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{d} : \coqref{LF.Lists.PartialMap.partial map}{\coqdocinductive{partial\_map}}) (\coqdocvar{x} \coqdocvar{y} : \coqref{LF.Lists.id}{\coqdocinductive{id}}) (\coqdocvar{o}: \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}),\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Lists.eqb id}{\coqdocdefinition{eqb\_id}} \coqdocvariable{x} \coqdocvariable{y} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Lists.PartialMap.find}{\coqdocdefinition{find}} \coqdocvariable{x} (\coqref{LF.Lists.PartialMap.update}{\coqdocdefinition{update}} \coqdocvariable{d} \coqdocvariable{y} \coqdocvariable{o}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Lists.PartialMap.find}{\coqdocdefinition{find}} \coqdocvariable{x} \coqdocvariable{d}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocnoindent
\coqdockw{End} \coqref{LF.Lists.PartialMap}{\coqdocmodule{PartialMap}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard (baz\_num\_elts)}




    考虑以下归纳定义： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Lists.baz}{baz}{\coqdocinductive{baz}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Lists.Baz1}{Baz1}{\coqdocconstructor{Baz1}} (\coqdocvar{x} : \coqref{LF.Lists.baz}{\coqdocinductive{baz}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Lists.Baz2}{Baz2}{\coqdocconstructor{Baz2}} (\coqdocvar{y} : \coqref{LF.Lists.baz}{\coqdocinductive{baz}}) (\coqdocvar{b} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
有\textit{'多少'}个表达式具备类型 \coqref{LF.Lists.baz}{\coqdocinductive{baz}}？（以注释说明。） \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Lists.manual grade for baz num elts}{manual\_grade\_for\_baz\_num\_elts}{\coqdocdefinition{manual\_grade\_for\_baz\_num\_elts}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.Induction}{Library }{LF.Induction}

\begin{coqdoccode}
\end{coqdoccode}
\section{Induction: 归纳证明}



 在开始之前，我们需要把上一章中所有的定义都导入进来： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{From} \coqdocvar{LF} \coqdockw{Require} \coqdockw{Export} \coqref{LF.Basics}{\coqdoclibrary{Basics}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For the \coqdockw{Require} \coqdockw{Export} to work, Coq needs to be able to
    find a compiled version of \coqdocvar{Basics.v}, called \coqdocvar{Basics.vo}, in a directory
    associated with the prefix \coqdocvar{LF}.  This file is analogous to the .\coqdocvar{class}
    files compiled from .\coqdocvar{java} source files and the .\coqdocvariable{o} files compiled from
    .\coqref{LF.Poly.MumbleGrumble.c}{\coqdocconstructor{c}} files.


    First create a file named \coqdocvar{\_CoqProject} containing the following line
    (if you obtained the whole volume ``Logical Foundations'' as a single
    archive, a \coqdocvar{\_CoqProject} should already exist and you can skip this step):


      -\coqdocvariable{Q} . \coqdocvar{LF}


    This maps the current directory (``.'', which contains \coqdocvar{Basics.v},
    \coqdocvar{Induction.v}, etc.) to the prefix (or ``logical directory'') ``\coqdocvar{LF}''.
    PG and CoqIDE read \coqdocvar{\_CoqProject} automatically, so they know to where to
    look for the file \coqdocvar{Basics.vo} corresponding to the library \coqdoclibrary{LF.Basics}.


    Once \coqdocvar{\_CoqProject} is thus created, there are various ways to build
    \coqdocvar{Basics.vo}:



\begin{itemize}
\item  In Proof General: The compilation can be made to happen automatically
       when you submit the \coqdockw{Require} line above to PG, by setting the emacs
       variable \coqdocvar{coq}-\coqdocvar{compile}-\coqdockw{before}-\coqdocvar{require} to \coqdocvariable{t}.



\item  In CoqIDE: Open \coqdocvar{Basics.v}; then, in the ``Compile'' menu, click
       on ``Compile Buffer''.



\item  From the command line: Generate a \coqdocvar{Makefile} using the \coqdocvar{coq\_makefile}
       utility, that comes installed with Coq (if you obtained the whole
       volume as a single archive, a \coqdocvar{Makefile} should already exist
       and you can skip this step):


         \coqdocvar{coq\_makefile} -\coqdocvariable{f} \coqdocvar{\_CoqProject} *.\coqdocvariable{v} -\coqdocvariable{o} \coqdocvar{Makefile}


       Note: You should rerun that command whenever you add or remove Coq files
       to the directory.


       Then you can compile \coqdocvar{Basics.v} by running \coqdocvar{make} with the corresponding
       .\coqdocvar{vo} file as a target:


         \coqdocvar{make} \coqdocvar{Basics.vo}


       All files in the directory can be compiled by giving no arguments:


         \coqdocvar{make}


       Under the hood, \coqdocvar{make} uses the Coq compiler, \coqdocvar{coqc}.  You can also
       run \coqdocvar{coqc} directly:


         \coqdocvar{coqc} -\coqdocvariable{Q} . \coqdocvar{LF} \coqdocvar{Basics.v}


       But \coqdocvar{make} also calculates dependencies between source files to compile
       them in the right order, so \coqdocvar{make} should generally be prefered over
       explicit \coqdocvar{coqc}.

\end{itemize}


    如果你遇到了问题（例如，稍后你可能会在本文件中遇到缺少标识符的提示），
    那可能是因为没有正确设置 Coq 的“加载路径”。指令 \coqdockw{Print} \coqdocvar{LoadPath}.
    能帮你理清这类问题。


    特别是，如果你看到了像这样的信息：


        \coqdocvar{Compiled} \coqdocvar{library} \coqdocvar{Foo} \coqdocvar{makes} \coqdocvar{inconsistent} \coqdocvar{assumptions} \coqdocvar{over}
        \coqdocvar{library} \coqdocvar{Bar}


    check whether you have multiple installations of Coq on your machine.
    It may be that commands (like \coqdocvar{coqc}) that you execute in a terminal
    window are getting a different version of Coq than commands executed by
    Proof General or CoqIDE.



\begin{itemize}
\item  Another common reason is that the library \coqdocvar{Bar} was modified and
      recompiled without also recompiling \coqdocvar{Foo} which depends on it.  Recompile
      \coqdocvar{Foo}, or everything if too many files are affected.  (Using the third
      solution above: \coqdocvar{make} \coqdocvar{clean}; \coqdocvar{make}.)

\end{itemize}


    再给 CoqIDE 用户一点技巧：如果你看到了 \coqdocvar{Error}: \coqdocvar{Unable} \coqdocvar{to} \coqdocvar{locate}
    \coqdocvar{library} \coqdoclibrary{Basics}，那么可能的原因是用 \textit{'CoqIDE'} 编译的代码和在指令行用
    \textit{'coqc'} 编译的不一致。这通常在系统中安装了两个不兼容的 \coqdocvar{coqc} 时发生
    （一个与 CoqIDE 关联，另一个与指令行的 \coqdocvar{coqc} 关联）。这种情况的变通方法
    就是只使用 CoqIDE 来编译（即从菜单中选择“make”）并完全避免使用 \coqdocvar{coqc}。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{归纳法证明}



 我们在上一章中通过基于化简的简单论据证明了 0 是 + 的左幺元。
    我们也观察到，当我们打算证明 0 也是 + 的 \textit{'右'} 幺元时... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.plus n O firsttry}{plus\_n\_O\_firsttry}{\coqdoclemma{plus\_n\_O\_firsttry}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 0.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
...事情就没这么简单了。只应用 \coqdoctac{reflexivity} 的话不起作用，因为 \coqdocvariable{n} + 0
    中的 \coqdocvariable{n} 是任意未知数，所以在 + 的定义中 \coqdockw{match} 匹配无法被化简。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
即便用 \coqdoctac{destruct} \coqdocvariable{n} 分类讨论也不会有所改善：诚然，我们能够轻易地证明 \coqdocvariable{n} = 0
    时的情况；但在证明对于某些 \coqdocvariable{n'} 而言 \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'} 时，我们又会遇到和此前相同的问题。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.plus n O secondtry}{plus\_n\_O\_secondtry}{\coqdoclemma{plus\_n\_O\_secondtry}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{destruct} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}] \coqdocvar{eqn}:\coqdocvar{E}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}. \coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
虽然还可以用 \coqdoctac{destruct} \coqdocvariable{n'} 再推进一步，但由于 \coqdocvariable{n} 可以任意大，
    如果照这个思路继续证明的话，我们永远也证不完。 

 为了证明这种关于数字、列表等归纳定义的集合的有趣事实，
    我们通常需要一个更强大的推理原理：\textit{'归纳'}。


    回想一下 \textit{'自然数的归纳法则'}，你也许曾在高中的数学课上，在某门离散数学课上或
    在其它类似的课上学到过它：若 \coqdocvariable{P}(\coqdocvariable{n}) 为关于自然数的命题，而当我们想要证明 \coqdocvariable{P}
    对于所有自然数 \coqdocvariable{n} 都成立时，可以这样推理：

\begin{itemize}
\item  证明 \coqdocvariable{P}(\coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}}) 成立；

\item  证明对于任何 \coqdocvariable{n'}，若 \coqdocvariable{P}(\coqdocvariable{n'}) 成立，那么 \coqdocvariable{P}(\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}) 也成立。

\item  最后得出 \coqdocvariable{P}(\coqdocvariable{n}) 对于所有 \coqdocvariable{n} 都成立的结论。

\end{itemize}


    在 Coq 中的步骤也一样：我们以证明 \coqdocvariable{P}(\coqdocvariable{n}) 对于所有 \coqdocvariable{n} 都成立的目标开始，
    然后（通过应用 \coqdoctac{induction} 策略）把它分为两个子目标：一个是我们必须证明
    \coqdocvariable{P}(\coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}}) 成立，另一个是我们必须证明 \coqdocvariable{P}(\coqdocvariable{n'}) \ensuremath{\rightarrow} \coqdocvariable{P}(\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'})。下面就是对该定理的用法： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.plus n O}{plus\_n\_O}{\coqdoclemma{plus\_n\_O}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'} \coqdocvar{IHn'}].\coqdoceol
\coqdocindent{1.00em}
-     \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
-  \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{IHn'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
和 \coqdoctac{destruct} 一样，\coqdoctac{induction} 策略也能通过 \coqdockw{as}... 从句为引入到
    子目标中的变量指定名字。由于这次有两个子目标，因此 \coqdockw{as}... 有两部分，用 \ensuremath{|}
    隔开。（严格来说，我们可以忽略 \coqdockw{as}... 从句，Coq 会为它们选择名字。
    然而在实践中这样不好，因为让 Coq 自行选择名字的话更容易导致理解上的困难。）


    在第一个子目标中 \coqdocvariable{n} 被 0 所取代。由于没有新的变量会被引入，因此 \coqdockw{as} ...
    字句的第一部分为空；而当前的目标会变成 0 + 0 = 0：使用化简就能得到此结论。


    在第二个子目标中，\coqdocvariable{n} 被 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'} 所取代，而对 \coqdocvariable{n'} 的归纳假设（Inductive
    Hypothesis），即 \coqdocvariable{n'} + 0 = \coqdocvariable{n'} 则以 \coqdocvar{IHn'} 为名被添加到了上下文中。
    这两个名字在 \coqdockw{as}... 从句的第二部分中指定。在此上下文中，待证目标变成了
    (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}) + 0 = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}；它可被化简为 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqdocvariable{n'} + 0) = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}，而此结论可通过
    \coqdocvar{IHn'} 得出。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.minus diag}{minus\_diag}{\coqdoclemma{minus\_diag}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{minus}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{minus}} \coqdocvariable{n} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'} \coqdocvar{IHn'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHn'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（其实在这些证明中我们并不需要 \coqdoctac{intros}：当 \coqdoctac{induction}
    策略被应用到包含量化变量的目标中时，它会自动将需要的变量移到上下文中。） 

\paragraph{练习：2 星, standard, recommended (basic\_induction)}




    用归纳法证明以下命题。你可能需要之前的证明结果。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.mult 0 r}{mult\_0\_r}{\coqdoclemma{mult\_0\_r}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} 0 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.plus n Sm}{plus\_n\_Sm}{\coqdoclemma{plus\_n\_Sm}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{m}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.plus comm}{plus\_comm}{\coqdoclemma{plus\_comm}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.plus assoc}{plus\_assoc}{\coqdoclemma{plus\_assoc}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard (double\_plus)}




    考虑以下函数，它将其参数乘以二： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Induction.double}{double}{\coqdocdefinition{double}} (\coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{n} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvar{n'}))\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
用归纳法证明以下关于 \coqref{LF.Induction.double}{\coqdocdefinition{double}} 的简单事实： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{LF.Induction.double plus}{double\_plus}{\coqdoclemma{double\_plus}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqref{LF.Induction.double}{\coqdocdefinition{double}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n} .\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, optional (evenb\_S)}




    我们的 \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvariable{n} 定义对 \coqdocvariable{n} - 2 的递归调用不大方便。这让证明 \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvariable{n}
    时更难对 \coqdocvariable{n} 进行归纳，因此我们需要一个关于 \coqdocvariable{n} - 2 的归纳假设。
    以下引理赋予了 \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n}) 另一个特征，使其在归纳时能够更好地工作： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.evenb S}{evenb\_S}{\coqdoclemma{evenb\_S}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.negb}{\coqdocdefinition{negb}} (\coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvariable{n}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：1 星, standard, optional (destruct\_induction)}




    请简要说明一下 \coqdoctac{destruct} 策略和 \coqdoctac{induction} 策略之间的区别。


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Induction.manual grade for destruct induction}{manual\_grade\_for\_destruct\_induction}{\coqdocdefinition{manual\_grade\_for\_destruct\_induction}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{证明里的证明}



 和在非形式化的数学中一样，在 Coq 中，大的证明通常会被分为一系列定理，
    后面的定理引用之前的定理。但有时一个证明会需要一些繁杂琐碎的事实，
    而这些事实缺乏普遍性，以至于我们甚至都不应该给它们单独取顶级的名字。
    此时，如果能仅在需要时简单地陈述并立即证明所需的“子定理”就会很方便。
    我们可以用 \coqdoctac{assert} 策略来做到。例如，我们之前对 \coqdocvar{mult\_0\_plus}
    定理的证明引用了前一个名为 \coqref{LF.Basics.plus O n}{\coqdoclemma{plus\_O\_n}} 的定理，而我们只需内联使用 \coqdoctac{assert}
    就能陈述并证明 \coqref{LF.Basics.plus O n}{\coqdoclemma{plus\_O\_n}}： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.mult 0 plus'}{mult\_0\_plus'}{\coqdoclemma{mult\_0\_plus'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}0 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n}\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{H}: 0 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvar{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{n}). \{ \coqdoctac{reflexivity}. \}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdoctac{assert} 策略引入两个子目标。第一个为断言本身，通过给它加前缀 \coqdocvariable{H}:
    我们将该断言命名为 \coqdocvariable{H}。（当然也可以用 \coqdockw{as} 来命名该断言，与之前的
    \coqdoctac{destruct} 和 \coqdoctac{induction} 一样。例如 \coqdoctac{assert} (0 + \coqdocvariable{n} = \coqdocvariable{n}) \coqdockw{as} \coqdocvariable{H}。）
    注意我们用花括号 \{ ... \} 将该断言的证明括了起来。这样不仅方便阅读，
    同时也能在交互使用 Coq 时更容易看出该子目标何时得证。第二个目标
    与之前执行 \coqdoctac{assert} 时一样，只是这次在上下文中，我们有了名为 \coqdocvariable{H} 的前提
    0 + \coqdocvariable{n} = \coqdocvariable{n}。也就是说，\coqdoctac{assert} 生成的第一个子目标是我们必须证明的已断言的事实，
    而在第二个子目标中，我们可以使用已断言的事实在一开始尝试证明的事情上取得进展。 

 另一个 \coqdoctac{assert} 的例子... 

 举例来说，假如我们要证明 (\coqdocvariable{n} + \coqdocvariable{m}) + (\coqdocvariable{p} + \coqdocvariable{q}) = (\coqdocvariable{m} + \coqdocvariable{n}) + (\coqdocvariable{p} + \coqdocvariable{q})。
    = 两边唯一不同的就是内层第一个子式中 + 的参数 \coqdocvariable{m} 和 \coqdocvariable{n} 交换了位置，
    我们似乎可以用加法交换律（\coqref{LF.Induction.plus comm}{\coqdoclemma{plus\_comm}}）来改写它。然而，
    \coqdoctac{rewrite} 策略并不知道应该作用在 \textit{'哪里'}。本命题中 + 用了三次 ，
    结果 \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqref{LF.Induction.plus comm}{\coqdoclemma{plus\_comm}} 只对 \textit{'最外层'} 起了作用... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.plus rearrange firsttry}{plus\_rearrange\_firsttry}{\coqdoclemma{plus\_rearrange\_firsttry}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} \coqdocvar{q} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{p} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{q}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{p} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{q}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqref{LF.Induction.plus comm}{\coqdocaxiom{plus\_comm}}.\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
为了在需要的地方使用 \coqref{LF.Induction.plus comm}{\coqdoclemma{plus\_comm}}，我们可以（为此这里讨论的 \coqdocvariable{m} 和 \coqdocvariable{n}）
    引入一个局部引理来陈述 \coqdocvariable{n} + \coqdocvariable{m} = \coqdocvariable{m} + \coqdocvariable{n}，之后用 \coqref{LF.Induction.plus comm}{\coqdoclemma{plus\_comm}} 证明它，
    并用它来进行期望的改写。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.plus rearrange}{plus\_rearrange}{\coqdoclemma{plus\_rearrange}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} \coqdocvar{q} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{p} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{q}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{p} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{q}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{H}: \coqdocvar{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvar{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvar{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvar{n}).\coqdoceol
\coqdocindent{1.00em}
\{ \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqref{LF.Induction.plus comm}{\coqdocaxiom{plus\_comm}}. \coqdoctac{reflexivity}. \}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{H}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{形式化证明 vs. 非形式化证明}



 “\textit{'非形式化证明是算法，形式化证明是代码。'}” 

 数学声明的成功证明由什么构成？这个问题已经困扰了哲学家数千年，
    不过这儿有个还算凑合的定义：数学命题 \coqdocvariable{P} 的证明是一段书面（或口头）的文本，
    它对 \coqdocvariable{P} 的真实性进行无可辩驳的论证，逐步说服读者或听者使其确信 \coqdocvariable{P} 为真。
    也就是说，证明是一种交流行为。


    交流活动会涉及不同类型的读者。一方面，“读者”可以是像 Coq 这样的程序，
    此时灌输的“确信”是 \coqdocvariable{P} 能够从一个确定的，由形式化逻辑规则组成的集合中
    机械地推导出来，而证明则是指导程序检验这一事实的方法。这种方法就是
    \textit{'形式化'} 证明。


    另一方面，读者也可以是人类，这种情况下证明可以用英语或其它自然语言写出，
    因此必然是 \textit{'非形式化'} 的，此时成功的标准不太明确。一个“有效的”证明是让读者
    相信 \coqdocvariable{P}。但同一个证明可能被很多不同的读者阅读，其中一些人可能会被某种特定
    的表述论证方式说服，而其他人则不会。有些读者太爱钻牛角尖，或者缺乏经验，
    或者只是单纯地过于愚钝；说服他们的唯一方法就是细致入微地进行论证。
    不过熟悉这一领域的读者可能会觉得所有细节都太过繁琐，让他们无法抓住
    整体的思路；他们想要的不过是抓住主要思路，因为相对于事无巨细的描述而言，
    让他们自行补充所需细节更为容易。总之，我们没有一个通用的标准，
    因为没有一种编写非形式化证明的方式能够说服所能顾及的每一个读者。


    然而在实践中，数学家们已经发展出了一套用于描述复杂数学对象的约定和习语，
    这让交流（至少在特定的社区内）变得十分可靠。这种约定俗成的交流形式已然成风，
    它为证明的好坏给出了清晰的判断标准。


    由于我们在本课程中使用 Coq，因此会重度使用形式化证明。但这并不意味着我们
    可以完全忽略掉非形式化的证明过程！形式化证明在很多方面都非常有用，
    不过它们对人类之间的思想交流而言 \textit{'并不'} 十分高效。 

 例如，下面是一段加法结合律的证明： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.plus assoc'}{plus\_assoc'}{\coqdoclemma{plus\_assoc'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'} \coqdocvar{IHn'}]. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHn'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Coq 对此表示十分满意。然而人类却很难理解它。我们可以用注释和标号让它
    的结构看上去更清晰一点... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.plus assoc''}{plus\_assoc'{}'}{\coqdoclemma{plus\_assoc'{}'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'} \coqdocvar{IHn'}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHn'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
...而且如果你习惯了 Coq，你可能会在脑袋里逐步过一遍策略，并想象出
    每一处上下文和目标栈的状态。不过若证明再复杂一点，那就几乎不可能了。


    一个（迂腐的）数学家可能把证明写成这样： 


\begin{itemize}
\item  \textit{'定理'}：对于任何 \coqdocvariable{n}、\coqdocvariable{m} 和 \coqdocvariable{p}，


      n + (m + p) = (n + m) + p.


    \textit{'证明'}：对 \coqdocvariable{n} 使用归纳法。



\begin{itemize}
\item  首先，设 \coqdocvariable{n} = 0。我们必须证明


        0 + (m + p) = (0 + m) + p.


      此结论可从 + 的定义直接得到。



\item  然后，设 \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}，其中


        n' + (m + p) = (n' + m) + p.


      我们必须证明


        (S n') + (m + p) = ((S n') + m) + p.


      根据 + 的定义，该式可写成


        S (n' + (m + p)) = S ((n' + m) + p),


      它由归纳假设直接得出。\textit{'证毕'}。 
\end{itemize}

\end{itemize}


 证明的总体形式大体类似，当然这并非偶然：Coq 的设计使其 \coqdoctac{induction}
    策略会像数学家写出的标号那样，按相同的顺序生成相同的子目标。但在细节上则有
    明显的不同：形式化证明在某些方面更为明确（例如对 \coqdoctac{reflexivity} 的使用），
    但在其它方面则不够明确（特别是 Coq 证明中任何一处的“证明状态”都是完全
    隐含的，而非形式化证明则经常反复告诉读者目前证明进行的状态）。 

\paragraph{练习：2 星, advanced, recommended (plus\_comm\_informal)}




    将你对 \coqref{LF.Induction.plus comm}{\coqdoclemma{plus\_comm}} 的解答翻译成非形式化证明：


    定理：加法满足交换律。


    Proof: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Induction.manual grade for plus comm informal}{manual\_grade\_for\_plus\_comm\_informal}{\coqdocdefinition{manual\_grade\_for\_plus\_comm\_informal}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, optional (eqb\_refl\_informal)}




    以 \coqref{LF.Induction.plus assoc}{\coqdoclemma{plus\_assoc}} 的非形式化证明为范本，写出以下定理的非形式化证明。
    不要只是用中文来解释 Coq 策略！


    定理：对于任何 \coqdocvariable{n}，均有 \coqref{LF.Basics.true}{\coqdocconstructor{true}} = \coqdocvariable{n} =? \coqdocvariable{n}。


    证明：  \ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{更多练习}



\paragraph{练习：3 星, standard, recommended (mult\_comm)}




    用 \coqdoctac{assert} 来帮助证明此定理。你应该不需要对 \coqref{LF.Induction.plus swap}{\coqdoclemma{plus\_swap}} 进行归纳。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.plus swap}{plus\_swap}{\coqdoclemma{plus\_swap}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
现在证明乘法交换律。（你在证明过程中可能想要定义并证明一个辅助定理。
    提示：\coqdocvariable{n} \ensuremath{\times} (1 + \coqdocvariable{k}) 是什么？） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.mult comm}{mult\_comm}{\coqdoclemma{mult\_comm}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{m} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard, optional (more\_exercises)}




    找一张纸。对于以下定理，首先请 \textit{'思考'} (a) 它能否能只用化简和改写来证明，
    (b) 它还需要分类讨论（\coqdoctac{destruct}），以及 (c) 它还需要归纳证明。先写下你的
    预判，然后填写下面的证明（你的纸不用交上来，这只是鼓励你先思考再行动！） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.Basics.leb}{\coqdocdefinition{leb}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.leb refl}{leb\_refl}{\coqdoclemma{leb\_refl}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} \coqdocvariable{n}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.zero nbeq S}{zero\_nbeq\_S}{\coqdoclemma{zero\_nbeq\_S}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
0 \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{(}}\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.andb false r}{andb\_false\_r}{\coqdoclemma{andb\_false\_r}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.andb}{\coqdocdefinition{andb}} \coqdocvariable{b} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.plus ble compat l}{plus\_ble\_compat\_l}{\coqdoclemma{plus\_ble\_compat\_l}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{(}}\coqdocvariable{p} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n}\coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{)}} \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{(}}\coqdocvariable{p} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}\coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.S nbeq 0}{S\_nbeq\_0}{\coqdoclemma{S\_nbeq\_0}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{(}}\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{)}} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 0 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.mult 1 l}{mult\_1\_l}{\coqdoclemma{mult\_1\_l}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, 1 \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.all3 spec}{all3\_spec}{\coqdoclemma{all3\_spec}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}},\coqdoceol
\coqdocindent{2.00em}
\coqref{LF.Basics.orb}{\coqdocdefinition{orb}}\coqdoceol
\coqdocindent{3.00em}
(\coqref{LF.Basics.andb}{\coqdocdefinition{andb}} \coqdocvariable{b} \coqdocvariable{c})\coqdoceol
\coqdocindent{3.00em}
(\coqref{LF.Basics.orb}{\coqdocdefinition{orb}} (\coqref{LF.Basics.negb}{\coqdocdefinition{negb}} \coqdocvariable{b})\coqdoceol
\coqdocindent{7.50em}
(\coqref{LF.Basics.negb}{\coqdocdefinition{negb}} \coqdocvariable{c}))\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.mult plus distr r}{mult\_plus\_distr\_r}{\coqdoclemma{mult\_plus\_distr\_r}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{p} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{p}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{m} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{p}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.mult assoc}{mult\_assoc}{\coqdoclemma{mult\_assoc}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{m} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{p}\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{m}\coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, optional (eqb\_refl)}




    证明以下定理。（把 \coqref{LF.Basics.true}{\coqdocconstructor{true}} 放在等式左边可能看起来有点奇怪，不过 Coq 标准库中
    就是这样表示的，我们照做就是。无论按哪个方向改写都一样好用，所以无论我们如何
    表示定理，用起来都没问题。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.eqb refl}{eqb\_refl}{\coqdoclemma{eqb\_refl}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdocvariable{n} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqdocvariable{n}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：2 星, standard, optional (plus\_swap')}




    \coqdoctac{replace} 策略允许你指定一个具体的要改写的子项和你想要将它改写成的项：
    \coqdoctac{replace} (\coqdocvariable{t}) \coqdockw{with} (\coqdocvar{u}) 会将目标中表达式 \coqdocvariable{t}（的所有副本）替换为表达式 \coqdocvar{u}，
    并生成 \coqdocvariable{t} = \coqdocvar{u} 作为附加的子目标。在简单的 \coqdoctac{rewrite} 作用在目标错误的部分上时
    这种做法通常很有用。


   用 \coqdoctac{replace} 策略来证明 \coqref{LF.Induction.plus swap'}{\coqdoclemma{plus\_swap'}}，除了无需 \coqdoctac{assert} (\coqdocvariable{n} + \coqdocvariable{m} = \coqdocvariable{m} + \coqdocvariable{n})
   外和 \coqref{LF.Induction.plus swap}{\coqdoclemma{plus\_swap}} 一样。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.plus swap'}{plus\_swap'}{\coqdoclemma{plus\_swap'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{p}\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard, recommended (binary\_commute)}




    回忆一下你在 \coqdoclibrary{Basics} 中为练习 \coqdocvar{binary} 编写的 \coqref{LF.Basics.incr}{\coqdocdefinition{incr}} 和 \coqref{LF.Basics.bin to nat}{\coqdocdefinition{bin\_to\_nat}}
    函数。证明下图可交换。


                            incr
              bin ----------------------> bin
               |                           |
    bin\_to\_nat |                           |  bin\_to\_nat
               |                           |
               v                           v
              nat ----------------------> nat
                             S


    也就是说，一个二进制数先自增然后将它转换为（一进制）自然数，和先将它转换为
    自然数后再自增会产生相同的结果。将你的定理命名为 \coqdocvar{bin\_to\_nat\_pres\_incr}
    （“pres”即“preserves”的简写，意为“保持原状”）。


    在开始做这个练习之前，将你在 \coqdocvar{binary} 练习的解中的定义复制到这里，
    让这个文件可以被单独评分。若你想要更改你的原始定义以便让此属性更易证明，
    请自便！ \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Induction.manual grade for binary commute}{manual\_grade\_for\_binary\_commute}{\coqdocdefinition{manual\_grade\_for\_binary\_commute}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：5 星, advanced (binary\_inverse)}




    This is a further continuation of the previous exercises about
    binary numbers.  You may find you need to go back and change your
    earlier definitions to get things to work here.


    (a) First, write a function to convert natural numbers to binary
        numbers. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Induction.nat to bin}{nat\_to\_bin}{\coqdocdefinition{nat\_to\_bin}} (\coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.Basics.bin}{\coqdocinductive{bin}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Prove that, if we start with any \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}, convert it to binary, and
    convert it back, we get the same \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} we started with.  (Hint: If
    your definition of \coqref{LF.Induction.nat to bin}{\coqdocdefinition{nat\_to\_bin}} involved any extra functions, you
    may need to prove a subsidiary lemma showing how such functions
    relate to \coqref{LF.Induction.nat to bin}{\coqdocdefinition{nat\_to\_bin}}.) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Induction.nat bin nat}{nat\_bin\_nat}{\coqdoclemma{nat\_bin\_nat}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqref{LF.Basics.bin to nat}{\coqdocaxiom{bin\_to\_nat}} (\coqref{LF.Induction.nat to bin}{\coqdocaxiom{nat\_to\_bin}} \coqdocvariable{n}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Induction.manual grade for binary inverse a}{manual\_grade\_for\_binary\_inverse\_a}{\coqdocdefinition{manual\_grade\_for\_binary\_inverse\_a}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
(b) One might naturally expect that we should also prove the
        opposite direction -- that starting with a binary number,
        converting to a natural, and then back to binary should yield
        the same number we started with.  However, this is not the
        case!  Explain (in a comment) what the problem is. \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Induction.manual grade for binary inverse b}{manual\_grade\_for\_binary\_inverse\_b}{\coqdocdefinition{manual\_grade\_for\_binary\_inverse\_b}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
(c) Define a normalization function -- i.e., a function
        \coqdocvar{normalize} going directly from \coqref{LF.Basics.bin}{\coqdocinductive{bin}} to \coqref{LF.Basics.bin}{\coqdocinductive{bin}} (i.e., \textit{not} by
        converting to \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} and back) such that, for any binary number
        \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}}, converting \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}} to a natural and then back to binary yields
        (\coqdocvar{normalize} \coqref{LF.Poly.MumbleGrumble.b}{\coqdocconstructor{b}}).  Prove it.  (Warning: This part is a bit
        tricky -- you may end up defining several auxiliary lemmas.
        One good way to find out what you need is to start by trying
        to prove the main statement, see where you get stuck, and see
        if you can find a lemma -- perhaps requiring its own inductive
        proof -- that will allow the main proof to make progress.) Don't
        define this using \coqref{LF.Induction.nat to bin}{\coqdocdefinition{nat\_to\_bin}} and \coqref{LF.Basics.bin to nat}{\coqdocdefinition{bin\_to\_nat}}! \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Induction.manual grade for binary inverse c}{manual\_grade\_for\_binary\_inverse\_c}{\coqdocdefinition{manual\_grade\_for\_binary\_inverse\_c}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.Basics}{Library }{LF.Basics}

\begin{coqdoccode}
\end{coqdoccode}
\section{Basics: Coq 函数式编程}

\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\section{引言}



 函数式编程风格建立在简单的、日常的数学直觉之上：若一个过程或方法没有副作用，
    那么在忽略效率的前提下，我们需要理解的一切便只剩下它如何将输入映射到输出了
    —— 也就是说，我们只需将它视作一种计算数学函数的具体方法即可。这也是
    “函数式编程”中“函数式”一词的含义之一。程序与简单数学对象之间这种直接的联系，
    同时支撑了对程序行为进行形式化证明的正确性以及非形式化论证的可靠性。


    函数式编程中“函数式”一词的另一个含义是它强调把函数作为\textit{'一等'}的值
    —— 这类值可以作为参数传递给其它函数，可以作为结果返回，
    也可以包含在数据结构中等等。这种将函数当做数据的方式，
    产生了大量强大而有用的编程习语（Idiom）。


    其它常见的函数式语言特性包括能让构造和处理丰富数据结构更加简单的
    \textit{'代数数据类型（Algebraic Data Type）'}和\textit{'模式匹配（Pattern Matching）'}，
    以及用来支持抽象和代码复用的\textit{'多态类型系统（Polymorphic Type System）'}。
    Coq 提供了所有这些特性。


    本章的前半部分介绍了 Coq 原生的函数式编程语言 \textit{'Gallina'} 中最基本的元素，
    后半部分则介绍了一些基本\textit{'策略（Tactic）'}，它可用于证明 Gallina 程序的简单性质。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{数据与函数}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{枚举类型}



 Coq 的一个不同寻常之处在于它\textit{'极小'}的内建特性集合。
    比如，Coq 并未提供通常的原语（atomic）类型（如布尔、整数、字符串等），
    而是提供了一种极为强大的，可以从头定义新的数据类型的机制
    —— 上面所有常见的类型都是由它定义而产生的实例。


    当然，Coq 发行版同时也提供了内容丰富的标准库，其中定义了布尔值、
    数值，以及如列表、散列表等许多通用的数据结构。
    不过这些库中的定义并没有任何神秘之处，也没有原语（Primitive）的特点。
    为了说明这一点，我们并未在本课程中直接使用标准库中的数据类型，
    而是在整个教程中重新定义了其中的绝大部分。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{一周七日}



 让我们从一个非常简单的例子开始，看看这种定义机制是如何工作的。
    以下声明会告诉 Coq 我们定义了一个数据集合，即一个\textit{'类型（Type）'}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Basics.day}{day}{\coqdocinductive{day}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.monday}{monday}{\coqdocconstructor{monday}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.tuesday}{tuesday}{\coqdocconstructor{tuesday}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.wednesday}{wednesday}{\coqdocconstructor{wednesday}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.thursday}{thursday}{\coqdocconstructor{thursday}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.friday}{friday}{\coqdocconstructor{friday}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.saturday}{saturday}{\coqdocconstructor{saturday}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.sunday}{sunday}{\coqdocconstructor{sunday}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这个新的类型名为 \coqref{LF.Basics.day}{\coqdocinductive{day}}，成员包括 \coqref{LF.Basics.monday}{\coqdocconstructor{monday}}、\coqref{LF.Basics.tuesday}{\coqdocconstructor{tuesday}} 等等。


    定义了 \coqref{LF.Basics.day}{\coqdocinductive{day}} 之后, 我们就能写一些操作星期的函数了。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.next weekday}{next\_weekday}{\coqdocdefinition{next\_weekday}} (\coqdocvar{d}:\coqref{LF.Basics.day}{\coqdocinductive{day}}) : \coqref{LF.Basics.day}{\coqdocinductive{day}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{d} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.monday}{\coqdocconstructor{monday}}    \ensuremath{\Rightarrow} \coqref{LF.Basics.tuesday}{\coqdocconstructor{tuesday}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.tuesday}{\coqdocconstructor{tuesday}}   \ensuremath{\Rightarrow} \coqref{LF.Basics.wednesday}{\coqdocconstructor{wednesday}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.wednesday}{\coqdocconstructor{wednesday}} \ensuremath{\Rightarrow} \coqref{LF.Basics.thursday}{\coqdocconstructor{thursday}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.thursday}{\coqdocconstructor{thursday}}  \ensuremath{\Rightarrow} \coqref{LF.Basics.friday}{\coqdocconstructor{friday}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.friday}{\coqdocconstructor{friday}}    \ensuremath{\Rightarrow} \coqref{LF.Basics.monday}{\coqdocconstructor{monday}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.saturday}{\coqdocconstructor{saturday}}  \ensuremath{\Rightarrow} \coqref{LF.Basics.monday}{\coqdocconstructor{monday}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.sunday}{\coqdocconstructor{sunday}}    \ensuremath{\Rightarrow} \coqref{LF.Basics.monday}{\coqdocconstructor{monday}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
注意，这里显式声明了函数的参数和返回类型。
    和大多数函数式编程语言一样，如果没有显式指定类型，Coq 通常会自己通过
    \textit{'类型推断（Type Inference）'} 得出。不过我们会标上类型使其更加易读。 

 定义了函数之后，我们接下来应该用一些例子来检验它。
    实际上，在 Coq 中，一共有三种不同的检验方式：第一，我们可以用 \coqdockw{Compute}
    指令来计算包含 \coqref{LF.Basics.next weekday}{\coqdocdefinition{next\_weekday}} 的复合表达式： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Compute} (\coqref{LF.Basics.next weekday}{\coqdocdefinition{next\_weekday}} \coqref{LF.Basics.friday}{\coqdocconstructor{friday}}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Compute} (\coqref{LF.Basics.next weekday}{\coqdocdefinition{next\_weekday}} (\coqref{LF.Basics.next weekday}{\coqdocdefinition{next\_weekday}} \coqref{LF.Basics.saturday}{\coqdocconstructor{saturday}})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（我们在注释中写出 Coq 返回的结果。如果你身边就有电脑，
    不妨自己用 Coq 解释器试一试：选一个你喜欢的 IDE，CoqIde 或
    Proof General 都可以。然后从本书附带的 Coq 源码中载入 \coqdocvar{Basics.v}
    文件，找到上面的例子，提交给 Coq，然后查看结果。） 

 第二，我们可以将\textit{'期望'}的结果写成 Coq 的示例： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test next weekday}{test\_next\_weekday}{\coqdocdefinition{test\_next\_weekday}}:\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.next weekday}{\coqdocdefinition{next\_weekday}} (\coqref{LF.Basics.next weekday}{\coqdocdefinition{next\_weekday}} \coqref{LF.Basics.saturday}{\coqdocconstructor{saturday}})\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.tuesday}{\coqdocconstructor{tuesday}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
该声明做了两件事：首先它断言 \coqref{LF.Basics.saturday}{\coqdocconstructor{saturday}} 之后的第二个工作日是
    \coqref{LF.Basics.tuesday}{\coqdocconstructor{tuesday}}；然后它为该断言取了名字以便之后引用它。
    定义好断言后，我们还可以让 Coq 来验证它，就像这样： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
具体细节目前并不重要，不过这段代码基本上可以读作
    “若等式两边的求值结果相同，该断言即可得证。”


    第三，我们可以让 Coq 从 \coqdockw{Definition} 中\textit{'提取（Extract）'}
    出用其它更加常规的编程语言编写的程序
    （如 OCaml、Scheme、Haskell 等），它们拥有高性能的编译器。
    这种能力非常有用，我们可以通过它将 Gallina 编写的 \textit{'证明正确'}
    的算法转译成高效的机器码。（诚然，我们必须信任 OCaml/Haskell/Scheme
    的编译器，以及 Coq 提取工具自身的正确性，然而比起现在大多数软件的开发方式，
    这也是很大的进步了。）实际上，这就是 Coq 最主要的使用方式之一。
    在之后的章节中我们会回到这一主题上来。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{作业提交指南}



 如果你在课堂中使用《软件基础》，你的讲师可能会用自动化脚本来为你的作业评分。
    为了让这些脚本能够正常工作（这样你才能拿到全部学分！），请认真遵循以下规则：

\begin{itemize}
\item  评分脚本在提取你提交的 .\coqdocvariable{v} 文件时会用到其中的特殊标记。因此请勿修改练习的
        “分隔标记”，如练习的标题、名称、以及末尾的 [] 等等。

\item  不要删除练习。如果你想要跳过某个练习（例如它标记为“可选”或你无法解决它），
        可以在 .\coqdocvariable{v} 文件中留下部分证明，这没关系，不过此时请确认它以 \coqdocvar{Admitted}
        结尾（不要用 \coqdockw{Abort} 之类的东西）。

\item  你也可以在解答中使用附加定义（如辅助函数，需要的引理等）。
        你可以将它们放在练习的头部和你要证明的定理之间。

\item  如果你为了证明某定理而需要引入一个额外引理，且未能证明该引理，
        请确保该引理与使用它的原定理都以 \coqdocvar{Admitted} 而非 \coqdockw{Qed} 结尾。
        这样能使在你利用原定理解决其他练习时得到部分分数。

\end{itemize}


    你或许注意到每一章都附带有一个\textit{'测试脚本'}来自动计算该章节已完成
    的作业的分数。这些脚本一般只作为自动评分工具，但你也可以用它们在提交前
    再一次确认作业格式的正确性。
    你可以在一个终端窗口中输入 ``\coqdocvar{make} \coqdocvar{BasicsTest.vo}'' 或下面的命令来运行这些
    测试脚本


       coqc -Q . LF Basics.v
       coqc -Q . LF BasicsTest.v


    你并不需要提交 \coqdocvar{BasicsTest.v} 这种测试脚本（也不需要提交前言 \coqdocvar{Preface.v}）。


    如果你的班级使用 Canvas 系统来提交作业。

\begin{itemize}
\item  如果你提交了多个不同版本的作业，你可能会注意到它们在系统中有着
        不同的名字。这是正常情况，只有最新的提交会被评分。

\item  如果你需要同时提交多个文件（例如一次作业中包含多个不同的章节），
        你需要创建一个一次性包含所有文件的提交。
       （译者注：关于多文件提交细节请查看英文原文。）
        To hand in multiple files at the same time (if more than one
        chapter is assigned in the same week), you need to make a
        single submission with all the files at once using the button
        ``Add another file'' just above the comment box. 
\end{itemize}


 The \coqdockw{Require} \coqdockw{Export} statement on the next line tells Coq to use
    the \coqdoclibrary{String} module from the standard library.  We'll use strings
    ourselves in later chapters, but we need to \coqdockw{Require} it here so
    that the grading scripts can use it for internal purposes. \begin{coqdoccode}
\coqdocnoindent
\coqdockw{From} \coqdocvar{Coq} \coqdockw{Require} \coqdockw{Export} \coqexternalref{}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdoclibrary{String}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{布尔值}



 通过类似的方式，我们可以为布尔值定义常见的 \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 类型，它包括
    \coqref{LF.Basics.true}{\coqdocconstructor{true}} 和 \coqref{LF.Basics.false}{\coqdocconstructor{false}} 两个成员。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Basics.bool}{bool}{\coqdocinductive{bool}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.true}{true}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.false}{false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
布尔值的函数可按照同样的方式来定义： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.negb}{negb}{\coqdocdefinition{negb}} (\coqdocvar{b}:\coqref{LF.Basics.bool}{\coqdocinductive{bool}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{b} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \ensuremath{\Rightarrow} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \ensuremath{\Rightarrow} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.andb}{andb}{\coqdocdefinition{andb}} (\coqdocvar{b1}:\coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{b2}:\coqref{LF.Basics.bool}{\coqdocinductive{bool}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{b1} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \ensuremath{\Rightarrow} \coqdocvariable{b2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \ensuremath{\Rightarrow} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.orb}{orb}{\coqdocdefinition{orb}} (\coqdocvar{b1}:\coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{b2}:\coqref{LF.Basics.bool}{\coqdocinductive{bool}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{b1} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \ensuremath{\Rightarrow} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \ensuremath{\Rightarrow} \coqdocvariable{b2}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（虽然我们正尝试从零开始定义布尔类型，
    但由于 Coq 的标准库中也提供了布尔类型的默认实现，以及大量有用的函数和引理。
    我们会尽量让自己的定义和定理的名字与标准库保持一致。） 

 其中 \coqref{LF.Basics.andb}{\coqdocdefinition{andb}} 和 \coqref{LF.Basics.orb}{\coqdocdefinition{orb}} 演示了如何定义多参函数。
    以下四个“单元测试”则演示了如何应用这些函数，
    它们构成了 \coqref{LF.Basics.orb}{\coqdocdefinition{orb}} 函数的完整规范（Specification），即真值表： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test orb1}{test\_orb1}{\coqdocdefinition{test\_orb1}}:  \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.orb}{\coqdocdefinition{orb}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}  \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test orb2}{test\_orb2}{\coqdocdefinition{test\_orb2}}:  \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.orb}{\coqdocdefinition{orb}} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test orb3}{test\_orb3}{\coqdocdefinition{test\_orb3}}:  \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.orb}{\coqdocdefinition{orb}} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}  \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test orb4}{test\_orb4}{\coqdocdefinition{test\_orb4}}:  \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.orb}{\coqdocdefinition{orb}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}  \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}  \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们也可以为刚定义的布尔运算引入更加熟悉的中缀语法。
    \coqdockw{Notation} 指令能为既有的定义赋予新的符号记法。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Basics.:::x 'x26x26' x}{"}{"}x \&\& y" := (\coqref{LF.Basics.andb}{\coqdocdefinition{andb}} \coqdocvar{x} \coqdocvar{y}).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Basics.:::x '||' x}{"}{"}x || y" := (\coqref{LF.Basics.orb}{\coqdocdefinition{orb}} \coqdocvar{x} \coqdocvar{y}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test orb5}{test\_orb5}{\coqdocdefinition{test\_orb5}}:  \coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqref{LF.Basics.:::x '||' x}{\coqdocnotation{||}} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqref{LF.Basics.:::x '||' x}{\coqdocnotation{||}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\textit{'关于记法的说明'}：在 .\coqdocvariable{v} 文件中，我们用方括号来界定注释中的
    Coq 代码片段；这种约定也在 \coqdocvar{coqdoc} 文档工具中使用，
    它能让代码与周围的文本从视觉上区分开来。
    在 HTML 版的文件中，这部分文本会以\textit{'不同的字体'}显示。 

 下面的例子展示了 Coq 的另一个特性: 条件表达式... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.negb'}{negb'}{\coqdocdefinition{negb'}} (\coqdocvar{b}:\coqref{LF.Basics.bool}{\coqdocinductive{bool}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{if} \coqdocvariable{b} \coqdockw{then} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{else} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.andb'}{andb'}{\coqdocdefinition{andb'}} (\coqdocvar{b1}:\coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{b2}:\coqref{LF.Basics.bool}{\coqdocinductive{bool}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{if} \coqdocvariable{b1} \coqdockw{then} \coqdocvariable{b2}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{else} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.orb'}{orb'}{\coqdocdefinition{orb'}} (\coqdocvar{b1}:\coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{b2}:\coqref{LF.Basics.bool}{\coqdocinductive{bool}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{if} \coqdocvariable{b1} \coqdockw{then} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{else} \coqdocvariable{b2}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Coq 的条件表达式相较于其他语言的，只有一点小小的扩展。由于 \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 类型
    并不是内建类型，Coq 实际上支持对\_任何\_归纳定义的双子句表达式使用 ``if'' 表达式
   （不过恰巧在这里该表达式被称为 \coqref{LF.Basics.bool}{\coqdocinductive{bool}}）。当条件求值后得到的是第一个
    子句的 “构造子” (constructor)，那么条件就会被认为是 “真” \coqref{LF.Basics.true}{\coqdocconstructor{true}}（不过恰巧
    在这里第一个分支的构造子被称为 “真” \coqref{LF.Basics.true}{\coqdocconstructor{true}}，并且如果求值后得到的是第二个子句，
    那么条件就被认为是 “假” \coqref{LF.Basics.false}{\coqdocconstructor{false}}）。 

\paragraph{练习：1 星, standard (nandb)}




    指令 \coqdocvar{Admitted} 被用作不完整证明的占位符。
    我们会在练习中用它来表示你需要完成的部分。你的任务就是将 \coqdocvar{Admitted}
    替换为具体的证明。


    移除“\coqdocvar{Admitted}.”并补完以下函数的定义，然后确保下列每一个 \coqdockw{Example}
    中的断言都能被 Coq 验证通过。（即仿照上文 \coqref{LF.Basics.orb}{\coqdocdefinition{orb}} 测试的格式补充证明，
    并确保 Coq 接受它。）此函数应在两个输入中的任意一个（或者都）包含
    \coqref{LF.Basics.false}{\coqdocconstructor{false}} 时返回 \coqref{LF.Basics.true}{\coqdocconstructor{true}} 。 
    提示：如果 \coqdoctac{simpl} 在你的证明中未能化简目标，那是因为你可能并未使用
    \coqdockw{match} 表达式定义你的 \coqref{LF.Basics.nandb}{\coqdocdefinition{nandb}}。尝试使用另一种 \coqref{LF.Basics.nandb}{\coqdocdefinition{nandb}} 的定义方式，
    或者直接跳过 \coqdoctac{simpl} 直接使用 \coqdoctac{reflexivity}。我们后面会解释为什么
    会发生这种情况。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.nandb}{nandb}{\coqdocdefinition{nandb}} (\coqdocvar{b1}:\coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{b2}:\coqref{LF.Basics.bool}{\coqdocinductive{bool}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test nandb1}{test\_nandb1}{\coqdocdefinition{test\_nandb1}}:               \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.nandb}{\coqdocaxiom{nandb}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test nandb2}{test\_nandb2}{\coqdocdefinition{test\_nandb2}}:               \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.nandb}{\coqdocaxiom{nandb}} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test nandb3}{test\_nandb3}{\coqdocdefinition{test\_nandb3}}:               \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.nandb}{\coqdocaxiom{nandb}} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test nandb4}{test\_nandb4}{\coqdocdefinition{test\_nandb4}}:               \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.nandb}{\coqdocaxiom{nandb}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：1 星, standard (andb3)}




    与此前相同，完成下面的 \coqref{LF.Basics.andb3}{\coqdocdefinition{andb3}} 函数。
    此函数应在所有输入均为 \coqref{LF.Basics.true}{\coqdocconstructor{true}} 时返回 \coqref{LF.Basics.true}{\coqdocconstructor{true}}，否则返回 \coqref{LF.Basics.false}{\coqdocconstructor{false}}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.andb3}{andb3}{\coqdocdefinition{andb3}} (\coqdocvar{b1}:\coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{b2}:\coqref{LF.Basics.bool}{\coqdocinductive{bool}}) (\coqdocvar{b3}:\coqref{LF.Basics.bool}{\coqdocinductive{bool}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test andb31}{test\_andb31}{\coqdocdefinition{test\_andb31}}:                 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.andb3}{\coqdocaxiom{andb3}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test andb32}{test\_andb32}{\coqdocdefinition{test\_andb32}}:                 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.andb3}{\coqdocaxiom{andb3}} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test andb33}{test\_andb33}{\coqdocdefinition{test\_andb33}}:                 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.andb3}{\coqdocaxiom{andb3}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqref{LF.Basics.false}{\coqdocconstructor{false}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test andb34}{test\_andb34}{\coqdocdefinition{test\_andb34}}:                 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.andb3}{\coqdocaxiom{andb3}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{类型}



 Coq 中的每个表达式都有类型，它描述了该表达式所计算的东西的类别。
    \coqdockw{Check} 指令会让 Coq 显示一个表达式的类型。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
如果在被 \coqdockw{Check} 的表达式后加上一个分号和你想验证的类型，那么 Coq 会
    验证该表达式是否属于你提供的类型。当两者不一致时，Coq 会报错并终止执行。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{2.00em}
: \coqref{LF.Basics.bool}{\coqdocinductive{bool}}.\coqdoceol
\coqdocnoindent
\coqdockw{Check} (\coqref{LF.Basics.negb}{\coqdocdefinition{negb}} \coqref{LF.Basics.true}{\coqdocconstructor{true}})\coqdoceol
\coqdocindent{2.00em}
: \coqref{LF.Basics.bool}{\coqdocinductive{bool}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
像 \coqref{LF.Basics.negb}{\coqdocdefinition{negb}} 这样的函数本身也是数据值，就像 \coqref{LF.Basics.true}{\coqdocconstructor{true}} 和 \coqref{LF.Basics.false}{\coqdocconstructor{false}} 一样。
    它们的类型被称为\textit{'函数类型'}，用带箭头的类型表示。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqref{LF.Basics.negb}{\coqdocdefinition{negb}}\coqdoceol
\coqdocindent{2.00em}
: \coqref{LF.Basics.bool}{\coqdocinductive{bool}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqref{LF.Basics.negb}{\coqdocdefinition{negb}} 的类型写作 \coqref{LF.Basics.bool}{\coqdocinductive{bool}} \ensuremath{\rightarrow} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}，读做“\coqref{LF.Basics.bool}{\coqdocinductive{bool}} 箭头 \coqref{LF.Basics.bool}{\coqdocinductive{bool}}”，
    可以理解为“给定一个 \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 类型的输入，该函数产生一个 \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 类型的输出。”
    同样，\coqref{LF.Basics.andb}{\coqdocdefinition{andb}} 的类型写作 \coqref{LF.Basics.bool}{\coqdocinductive{bool}} \ensuremath{\rightarrow} \coqref{LF.Basics.bool}{\coqdocinductive{bool}} \ensuremath{\rightarrow} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}，可以理解为
    “给定两个 \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 类型的输入，该函数产生一个 \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 类型的输出。” \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{由旧类型构造新类型}



 到目前为止，我们定义的类型都是“枚举类型”：它们的定义显式地枚举了
    一个元素的有限集，其中每个元素都只是一个裸构造子（译注：即无参数构造子）。
    下面是一个更加有趣的类型定义，其中有个构造子接受一个参数： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Basics.rgb}{rgb}{\coqdocinductive{rgb}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.red}{red}{\coqdocconstructor{red}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.green}{green}{\coqdocconstructor{green}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.blue}{blue}{\coqdocconstructor{blue}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Basics.color}{color}{\coqdocinductive{color}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.black}{black}{\coqdocconstructor{black}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.white}{white}{\coqdocconstructor{white}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.primary}{primary}{\coqdocconstructor{primary}} (\coqdocvar{p} : \coqref{LF.Basics.rgb}{\coqdocinductive{rgb}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
像 \coqdoctac{red}、\coqref{LF.Basics.green}{\coqdocconstructor{green}}、\coqref{LF.Basics.blue}{\coqdocconstructor{blue}}、\coqref{LF.Basics.black}{\coqdocconstructor{black}}、\coqref{LF.Basics.white}{\coqdocconstructor{white}} 以及 \coqref{LF.Basics.primary}{\coqdocconstructor{primary}}（还有
    \coqref{LF.Basics.true}{\coqdocconstructor{true}}、\coqref{LF.Basics.false}{\coqdocconstructor{false}}、\coqref{LF.Basics.monday}{\coqdocconstructor{monday}} 等）这样的原子标识符叫做\textit{'构造子（Constructor）'}。


    我们可以用它们来构建\textit{'构造子表达式（Constructor Expression）'}，
    其中每一个要么是一个简单的构造子，要么就是一个构造子应用于一个或多个参数
    （每个这样的参数也都是构造子表达式）。 

 我们来仔细研究一下。每个归纳定义的类型（如 \coqref{LF.Basics.day}{\coqdocinductive{day}}、\coqref{LF.Basics.bool}{\coqdocinductive{bool}}、\coqref{LF.Basics.rgb}{\coqdocinductive{rgb}}、\coqref{LF.Basics.color}{\coqdocinductive{color}} 等）
    都描述了一组由\textit{'构造子'}构成的\textit{'构造子表达式'}。



\begin{itemize}
\item  我们从有限的一组\textit{'构造子'}开始。例如
      \coqdoctac{red}、\coqref{LF.Basics.primary}{\coqdocconstructor{primary}}、\coqref{LF.Basics.true}{\coqdocconstructor{true}}、\coqref{LF.Basics.false}{\coqdocconstructor{false}}、\coqref{LF.Basics.monday}{\coqdocconstructor{monday}}
      等等都是构造子。



\item  \textit{'构造子表达式'}通过将构造子应用到一个或多个构造子表达式上构成。例如
         \coqdoctac{red}、\coqref{LF.Basics.true}{\coqdocconstructor{true}}、\coqref{LF.Basics.primary}{\coqdocconstructor{primary}}、\coqref{LF.Basics.primary}{\coqdocconstructor{primary}} \coqdoctac{red}、\coqdoctac{red} \coqref{LF.Basics.primary}{\coqdocconstructor{primary}}、\coqdoctac{red} \coqref{LF.Basics.true}{\coqdocconstructor{true}}、
         \coqref{LF.Basics.primary}{\coqdocconstructor{primary}} (\coqref{LF.Basics.primary}{\coqdocconstructor{primary}} \coqref{LF.Basics.primary}{\coqdocconstructor{primary}}) 等等



\item  每个 \coqdockw{Inductive} 定义都刻画了一个构造子表达式的子集并赋予了它们名字，如
      \coqref{LF.Basics.bool}{\coqdocinductive{bool}}、\coqref{LF.Basics.rgb}{\coqdocinductive{rgb}} 或 \coqref{LF.Basics.color}{\coqdocinductive{color}}。

\end{itemize}


 具体来说，\coqref{LF.Basics.rgb}{\coqdocinductive{rgb}} 和 \coqref{LF.Basics.color}{\coqdocinductive{color}} 的定义描述了如何构造这两个集合中的构造子表达式：



\begin{itemize}
\item  构造子表达式 \coqdoctac{red}、\coqref{LF.Basics.green}{\coqdocconstructor{green}} 和 \coqref{LF.Basics.blue}{\coqdocconstructor{blue}} 属于集合 \coqref{LF.Basics.rgb}{\coqdocinductive{rgb}}；

\item  构造子表达式 \coqref{LF.Basics.black}{\coqdocconstructor{black}} 和 \coqref{LF.Basics.white}{\coqdocconstructor{white}} 属于集合 \coqref{LF.Basics.color}{\coqdocinductive{color}}；

\item  若 \coqdocvariable{p} 是属于 \coqref{LF.Basics.rgb}{\coqdocinductive{rgb}} 的构造子表达式，则 \coqref{LF.Basics.primary}{\coqdocconstructor{primary}} \coqdocvariable{p}（读作“构造子 \coqref{LF.Basics.primary}{\coqdocconstructor{primary}}
      应用于参数 \coqdocvariable{p}）是属于集合 \coqref{LF.Basics.color}{\coqdocinductive{color}} 的构造子表达式；且

\item  通过这些方式构造的构造子表达式\textit{'只属于'}集合 \coqref{LF.Basics.rgb}{\coqdocinductive{rgb}} 和 \coqref{LF.Basics.color}{\coqdocinductive{color}}。 
\end{itemize}


 我们可以像之前的 \coqref{LF.Basics.day}{\coqdocinductive{day}} 和 \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 那样用模式匹配为 \coqref{LF.Basics.color}{\coqdocinductive{color}} 定义函数。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.monochrome}{monochrome}{\coqdocdefinition{monochrome}} (\coqdocvar{c} : \coqref{LF.Basics.color}{\coqdocinductive{color}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{c} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.black}{\coqdocconstructor{black}} \ensuremath{\Rightarrow} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.white}{\coqdocconstructor{white}} \ensuremath{\Rightarrow} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.primary}{\coqdocconstructor{primary}} \coqdocvar{p} \ensuremath{\Rightarrow} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
鉴于 \coqref{LF.Basics.primary}{\coqdocconstructor{primary}} 构造子接收一个参数，匹配到 \coqref{LF.Basics.primary}{\coqdocconstructor{primary}} 的模式应当带有一个
    变量或常量。变量可以取任意名称，如上文所示；常量需有适当的类型，例如： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.isred}{isred}{\coqdocdefinition{isred}} (\coqdocvar{c} : \coqref{LF.Basics.color}{\coqdocinductive{color}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{c} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.black}{\coqdocconstructor{black}} \ensuremath{\Rightarrow} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.white}{\coqdocconstructor{white}} \ensuremath{\Rightarrow} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.primary}{\coqdocconstructor{primary}} \coqref{LF.Basics.red}{\coqdocconstructor{red}} \ensuremath{\Rightarrow} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{LF.Basics.primary}{\coqdocconstructor{primary}} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这里的模式 \coqref{LF.Basics.primary}{\coqdocconstructor{primary}} \coqdocvar{\_} 是“构造子 \coqref{LF.Basics.primary}{\coqdocconstructor{primary}} 应用到除 \coqdoctac{red}
    之外的任何 \coqref{LF.Basics.rgb}{\coqdocinductive{rgb}} 构造子上”的简写形式（通配模式 \coqdocvar{\_} 的效果与
    \coqref{LF.Basics.monochrome}{\coqdocdefinition{monochrome}} 定义中的哑（dummy）模式变量 \coqdocvariable{p} 相同。） \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{元组}



 一个多参数的单构造子可以用来创建元组类型。例如，为了让一个
    半字节（nybble）表示四个比特。我们首先定义一个 \coqref{LF.Basics.bit}{\coqdocinductive{bit}} 数据类型
    来类比 \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 数据。并且使用 \coqref{LF.Basics.B0}{\coqdocconstructor{B0}} 和 \coqref{LF.Basics.B1}{\coqdocconstructor{B1}} 两种构造子来表示其可能的取值。
    最后定义 \coqref{LF.Basics.nybble}{\coqdocinductive{nybble}} 这种数据类型，也就是一个四比特的元组。\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Basics.bit}{bit}{\coqdocinductive{bit}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.B0}{B0}{\coqdocconstructor{B0}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.B1}{B1}{\coqdocconstructor{B1}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Basics.nybble}{nybble}{\coqdocinductive{nybble}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.bits}{bits}{\coqdocconstructor{bits}} (\coqdocvar{b0} \coqdocvar{b1} \coqdocvar{b2} \coqdocvar{b3} : \coqref{LF.Basics.bit}{\coqdocinductive{bit}}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqref{LF.Basics.bits}{\coqdocconstructor{bits}} \coqref{LF.Basics.B1}{\coqdocconstructor{B1}} \coqref{LF.Basics.B0}{\coqdocconstructor{B0}} \coqref{LF.Basics.B1}{\coqdocconstructor{B1}} \coqref{LF.Basics.B0}{\coqdocconstructor{B0}})\coqdoceol
\coqdocindent{2.00em}
: \coqref{LF.Basics.nybble}{\coqdocinductive{nybble}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这里的 \coqref{LF.Basics.bit}{\coqdocinductive{bit}} 构造子起到了对它内容的包装作用。
    解包可以通过模式匹配来实现，就如同下面的 \coqref{LF.Basics.all zero}{\coqdocdefinition{all\_zero}} 函数一样，
    其通过解包来验证一个半字节的所有比特是否都为 \coqref{LF.Basics.B0}{\coqdocconstructor{B0}}。
    我们用\textit{'通配符'} \coqdocvar{\_} 来避免创建不需要的变量名。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.all zero}{all\_zero}{\coqdocdefinition{all\_zero}} (\coqdocvar{nb} : \coqref{LF.Basics.nybble}{\coqdocinductive{nybble}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{nb} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} (\coqref{LF.Basics.bits}{\coqdocconstructor{bits}} \coqref{LF.Basics.B0}{\coqdocconstructor{B0}} \coqref{LF.Basics.B0}{\coqdocconstructor{B0}} \coqref{LF.Basics.B0}{\coqdocconstructor{B0}} \coqref{LF.Basics.B0}{\coqdocconstructor{B0}}) \ensuremath{\Rightarrow} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} (\coqref{LF.Basics.bits}{\coqdocconstructor{bits}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_}) \ensuremath{\Rightarrow} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Compute} (\coqref{LF.Basics.all zero}{\coqdocdefinition{all\_zero}} (\coqref{LF.Basics.bits}{\coqdocconstructor{bits}} \coqref{LF.Basics.B1}{\coqdocconstructor{B1}} \coqref{LF.Basics.B0}{\coqdocconstructor{B0}} \coqref{LF.Basics.B1}{\coqdocconstructor{B1}} \coqref{LF.Basics.B0}{\coqdocconstructor{B0}})).\coqdoceol
\coqdocnoindent
\coqdockw{Compute} (\coqref{LF.Basics.all zero}{\coqdocdefinition{all\_zero}} (\coqref{LF.Basics.bits}{\coqdocconstructor{bits}} \coqref{LF.Basics.B0}{\coqdocconstructor{B0}} \coqref{LF.Basics.B0}{\coqdocconstructor{B0}} \coqref{LF.Basics.B0}{\coqdocconstructor{B0}} \coqref{LF.Basics.B0}{\coqdocconstructor{B0}})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{模块}



 Coq 提供了\textit{'模块系统'}来帮助组织大规模的开发。在本课程中，
    我们不太会用到这方面的特性。不过其中有一点非常有用：
    如果我们将一组定义放在 \coqdockw{Module} \coqref{LF.Imp.X}{\coqdocdefinition{X}} 和 \coqdockw{End} \coqref{LF.Imp.X}{\coqdocdefinition{X}} 标记之间，那么在文件中的
    \coqdockw{End} 之后，我们就可以通过像 \coqdocvar{X.foo} 这样的名字来引用，而不必直接用
    \coqref{LF.Tactics.foo}{\coqdocdefinition{foo}} 了。在这里，我们通过此特性在内部模块中引入了 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 类型的定义，
    这样就不会覆盖标准库中的同名定义了（我们会在本书后面的部分中使用它，
    因为它提供了一些简便的特殊记法。）\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Basics.NatPlayground}{NatPlayground}{\coqdocmodule{NatPlayground}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{数值}



 目前我们定义的所有类型都是有限的。无论是像 \coqref{LF.Basics.day}{\coqdocinductive{day}}, \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 和 \coqref{LF.Basics.bit}{\coqdocinductive{bit}} 
    这样的“枚举类型”，抑或是像 \coqref{LF.Basics.nybble}{\coqdocinductive{nybble}} 这样基于“枚举类型”的元组类型，
    本质上都是有限的集合。而自然数（natural numbers）是一个无限集合，
    因此我们需要一种更强大的类型声明方式来表示它们。


    数字的表示方法有许多种。我们最为熟悉的便是十进制（base 10），利用
    0～9 十个数字来表示一个数，例如用 1，2 和 3 来表示 123 （一百二十三）。
    你或许也接触过十六进制（base 16），在十六进制中，它被表示为 7B。类似的还有
    173 （八进制表示）和 111011（二进制表示）。我们可以使用枚举类型
    来定义以上任何一种数字表示方式。它们在不同的场景下有着不同的用途。


    二进制表示在计算机硬件中起着举足轻重的作用。它只需要两种不同的电平
    来表示，因此它的硬件电路可以被设计十分简单。同样的，
    我们也希望选择一种自然数的表示方式，来让我们的\_证明\_变得更加简单。


    实际上，比起二进制，还有一种更加简单的数字表示方式，一进制（base 1），
    也就是只使用单个数字的表示方式（就如同我们的祖先山顶洞人在洞穴上
    刻“痕迹”计算日子一般）。为了在 Coq 中表示一进制数，我们使用两个构造子。
    大写的 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} 构造子用来表示“零”，而大写的 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 构造子用来表示“后继”
    （或者洞穴上的“痕迹”）。当 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 构造子被应用于一个自然数 n 的表示上时，
    结果会是自然数 n + 1 的表示。下面是完整的数据类型定义。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Basics.NatPlayground.nat}{nat}{\coqdocinductive{nat}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.NatPlayground.O}{O}{\coqdocconstructor{O}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.NatPlayground.S}{S}{\coqdocconstructor{S}} (\coqdocvar{n} : \coqref{LF.Basics.nat}{\coqdocinductive{nat}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在这种定义下， 0 被表示为 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}}, 1 则被表示为 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}},
    2 则是 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}})，以此类推 

 非形式化地说，此定义中的子句可读作：

\begin{itemize}
\item  \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} 是一个自然数（注意这里是字母“\coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}}”，不是数字“0”）。

\item  \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 可被放在一个自然数之前来产生另一个自然数 ——
        也就是说，如果 \coqdocvariable{n} 是一个自然数，那么 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n} 也是。 
\end{itemize}


 同样，我们来仔细观察这个定义。
    \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 的定义描述了集合 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 中的表达式是如何构造的：



\begin{itemize}
\item  构造子表达式 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} 属于集合 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}；

\item  如果 \coqdocvariable{n} 是属于集合 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 的构造子表达式，
      那么 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n} 也是属于集合 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 的构造子表达式；并且

\item  只有以这两种产生的方式构造字表达式才属于集合 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}。 
\end{itemize}


 这些条件精确刻画了这个“归纳” \coqdockw{Inductive} 声明。它们意味着，构造子表达式 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}}、
    \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}}、\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}})、\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}})) 等等都属于集合 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}，而其它的构造子表达式，如
    \coqref{LF.Basics.true}{\coqdocconstructor{true}}、\coqref{LF.Basics.andb}{\coqdocdefinition{andb}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}、\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}) 以及 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} (\coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} (\coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}})) 等则不属于 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}。


    关键之处在于，我们目前只是定义了一种数字的\textit{'表示'}方式，
    即一种写下它们的方式。名称 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} 和 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 是任意的，在这一点上它们没有特殊的意义，
    它们只是我们能用来写下数字的两个不同的记号（以及一个说明了任何 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}
    都能写成一串 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 后跟一个 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} 的规则）。如果你喜欢，完全可以将同样的定义写成： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Basics.NatPlayground.nat'}{nat'}{\coqdocinductive{nat'}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.NatPlayground.stop}{stop}{\coqdocconstructor{stop}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.NatPlayground.tick}{tick}{\coqdocconstructor{tick}} (\coqdocvar{foo} : \coqref{LF.Basics.nat'}{\coqdocinductive{nat'}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
这些记号的\textit{'解释'}完全取决于我们如何用它进行计算。 

 我们可以像之前的布尔值或日期那样，
    编写一个函数来对上述自然数的表示进行模式匹配。
    例如，以下为前趋函数：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.NatPlayground.pred}{pred}{\coqdocdefinition{pred}} (\coqdocvar{n} : \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}) : \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{n} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqdocvar{n'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
第二个分支可以读作：“如果 \coqdocvariable{n} 对于某个 \coqdocvariable{n'} 的形式为 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}，
    那么就返回 \coqdocvariable{n'}。” 

 下面的 \coqdockw{End} 指令会关闭当前的模块，所以 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 会重新代表标准库中的类型而非我们
    自己定义的 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.Basics.NatPlayground}{\coqdocmodule{NatPlayground}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
为了让自然数使用起来更加自然，Coq 内建了一小部分解析打印功能：
    普通的十进制数可视为“一进制”自然数的另一种记法，以代替 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 与 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} 构造子；
    反过来，Coq 也会默认将自然数打印为十进制形式： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}})))).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.minustwo}{minustwo}{\coqdocdefinition{minustwo}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{n} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n'}) \ensuremath{\Rightarrow} \coqdocvar{n'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Compute} (\coqref{LF.Basics.minustwo}{\coqdocdefinition{minustwo}} 4).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
构造子 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 的类型为 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} \ensuremath{\rightarrow} \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}，与 \coqref{LF.Basics.NatPlayground.pred}{\coqdocdefinition{pred}} 和 \coqref{LF.Basics.minustwo}{\coqdocdefinition{minustwo}} 之类的函数相同： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}}        : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}.\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqexternalref{pred}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{pred}}     : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}.\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqref{LF.Basics.minustwo}{\coqdocdefinition{minustwo}} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
以上三个东西均可作用于自然数，并产生自然数结果，但第一个 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}}
    与后两者有本质区别：\coqref{LF.Basics.NatPlayground.pred}{\coqdocdefinition{pred}} 和 \coqref{LF.Basics.minustwo}{\coqdocdefinition{minustwo}} 这类函数是通过给定的\textit{'计算规则'}定义的——
    例如 \coqref{LF.Basics.NatPlayground.pred}{\coqdocdefinition{pred}} 的定义表明 \coqref{LF.Basics.NatPlayground.pred}{\coqdocdefinition{pred}} 2 可化简为 1——但 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 的定义不包含此类行为。
    虽然 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 可以作用于参数这点与函数\textit{'相似'}，但其作用仅限于构造数字，而并不用于计算。


    （考虑标准的十进制数：数字 1 不代表任何计算，只表示一部分数据。
    用 111 指代数字一百一十一，实则使用三个 1 符号表示此数各位。）


    现在我们来为数值定义更多的函数。


    简单的模式匹配不足以描述很多有趣的数值运算，我们还需要递归定义。
    例如：给定自然数 \coqdocvariable{n}，欲判定其是否为偶数，则需递归检查 \coqdocvariable{n}-2 是否为偶数。
    关键字 \coqdockw{Fixpoint} 可用于定义此类函数。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Basics.evenb}{evenb}{\coqdocdefinition{evenb}} (\coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{n} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}}        \ensuremath{\Rightarrow} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}}      \ensuremath{\Rightarrow} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n'}) \ensuremath{\Rightarrow} \coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvar{n'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们可以使用类似的 \coqdockw{Fixpoint} 声明来定义 \coqdocvar{odd} 函数，
    不过还有种更简单方式：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.oddb}{oddb}{\coqdocdefinition{oddb}} (\coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.negb}{\coqdocdefinition{negb}} (\coqref{LF.Basics.evenb}{\coqdocdefinition{evenb}} \coqdocvariable{n}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test oddb1}{test\_oddb1}{\coqdocdefinition{test\_oddb1}}:    \coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} 1 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test oddb2}{test\_oddb2}{\coqdocdefinition{test\_oddb2}}:    \coqref{LF.Basics.oddb}{\coqdocdefinition{oddb}} 4 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（如果你逐步检查完这些证明，就会发现 \coqdoctac{simpl} 其实没什么作用
    —— 所有工作都被 \coqdoctac{reflexivity} 完成了。我们之后会讨论为什么会这样。)


    当然，我们也可以用递归定义多参函数。  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdef{LF.Basics.NatPlayground2}{NatPlayground2}{\coqdocmodule{NatPlayground2}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Basics.NatPlayground2.plus}{plus}{\coqdocdefinition{plus}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{n} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqdocvariable{m}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqref{LF.Basics.plus}{\coqdocdefinition{plus}} \coqdocvar{n'} \coqdocvariable{m})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
三加二等于五，不出意料。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Compute} (\coqref{LF.Basics.NatPlayground2.plus}{\coqdocdefinition{plus}} 3 2).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Coq 所执行的化简步骤如下所示： \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
为了书写方便，如果两个或更多参数具有相同的类型，那么它们可以写在一起。
    在下面的定义中，(\coqdocvariable{n} \coqdocvariable{m} : \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}) 的意思与 (\coqdocvariable{n} : \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}) (\coqdocvariable{m} : \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}) 相同。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Basics.NatPlayground2.mult}{mult}{\coqdocdefinition{mult}} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{n} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqref{LF.Basics.NatPlayground2.plus}{\coqdocdefinition{plus}} \coqdocvariable{m} (\coqref{LF.Basics.mult}{\coqdocdefinition{mult}} \coqdocvar{n'} \coqdocvariable{m})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.NatPlayground2.test mult1}{test\_mult1}{\coqdocdefinition{test\_mult1}}: \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.NatPlayground2.mult}{\coqdocdefinition{mult}} 3 3\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 9.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
你可以在两个表达式之间添加逗号来同时匹配它们：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Basics.NatPlayground2.minus}{minus}{\coqdocdefinition{minus}} (\coqdocvar{n} \coqdocvar{m}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{n}, \coqdocvariable{m} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}}   , \coqdocvar{\_}    \ensuremath{\Rightarrow} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{\_} , \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}}    \ensuremath{\Rightarrow} \coqdocvariable{n}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n'}, \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{m'} \ensuremath{\Rightarrow} \coqref{LF.Basics.minus}{\coqdocdefinition{minus}} \coqdocvar{n'} \coqdocvar{m'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{LF.Basics.NatPlayground2}{\coqdocmodule{NatPlayground2}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Basics.exp}{exp}{\coqdocdefinition{exp}} (\coqdocvar{base} \coqdocvar{power} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{power} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{p} \ensuremath{\Rightarrow} \coqexternalref{mult}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{mult}} \coqdocvariable{base} (\coqref{LF.Basics.exp}{\coqdocdefinition{exp}} \coqdocvariable{base} \coqdocvar{p})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, standard (factorial)}




    回想一下标准的阶乘函数：


       factorial(0)  =  1
       factorial(n)  =  n * factorial(n-1)     (if n>0)


    把它翻译成 Coq 代码。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Basics.factorial}{factorial}{\coqdocdefinition{factorial}} (\coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test factorial1}{test\_factorial1}{\coqdocdefinition{test\_factorial1}}:          \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.factorial}{\coqdocaxiom{factorial}} 3\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 6.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test factorial2}{test\_factorial2}{\coqdocdefinition{test\_factorial2}}:          \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.factorial}{\coqdocaxiom{factorial}} 5\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqexternalref{mult}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{mult}} 10 12\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 我们可以通过引入加法、乘法和减法的\textit{'记法（Notation）'}来让数字表达式更加易读。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Basics.::nat scope:x '+' x}{"}{"}x + y" := (\coqexternalref{plus}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{plus}} \coqdocvar{x} \coqdocvar{y})\coqdoceol
\coqdocindent{11.50em}
(\coqdoctac{at} \coqdockw{level} 50, \coqdoctac{left} \coqdockw{associativity})\coqdoceol
\coqdocindent{11.50em}
: \coqdocvar{nat\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Basics.::nat scope:x '-' x}{"}{"}x - y" := (\coqexternalref{minus}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{minus}} \coqdocvar{x} \coqdocvar{y})\coqdoceol
\coqdocindent{11.50em}
(\coqdoctac{at} \coqdockw{level} 50, \coqdoctac{left} \coqdockw{associativity})\coqdoceol
\coqdocindent{11.50em}
: \coqdocvar{nat\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Basics.::nat scope:x '*' x}{"}{"}x * y" := (\coqexternalref{mult}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{mult}} \coqdocvar{x} \coqdocvar{y})\coqdoceol
\coqdocindent{11.50em}
(\coqdoctac{at} \coqdockw{level} 40, \coqdoctac{left} \coqdockw{associativity})\coqdoceol
\coqdocindent{11.50em}
: \coqdocvar{nat\_scope}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}0 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（\coqdockw{level}、\coqdockw{associativity} 和 \coqdocvar{nat\_scope} 标记控制着 Coq
    语法分析器如何处理上述记法。目前无需关注这些细节。有兴趣的读者可参阅本章末尾
    “关于记法的更多内容”一节。）


    注意，这些声明并不会改变我们之前的定义，而只是让 Coq 语法分析器接受用
    \coqdocvariable{x} + \coqdocvariable{y} 来代替 \coqref{LF.Basics.NatPlayground2.plus}{\coqdocdefinition{plus}} \coqdocvariable{x} \coqdocvariable{y}，并在 Coq 美化输出时反过来将 \coqref{LF.Basics.NatPlayground2.plus}{\coqdocdefinition{plus}} \coqdocvariable{x} \coqdocvariable{y}
    显示为 \coqdocvariable{x} + \coqdocvariable{y}。 

 Coq 几乎不包含任何内置定义，甚至连数值间的相等关系都是由用户来实现。
    \coqref{LF.Basics.eqb}{\coqdocdefinition{eqb}} 函数定义如下：该函数检验自然数 \coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 间是否满足相等关系 \coqref{LF.ProofObjects.MyEquality.eq}{\coqdocinductive{eq}}，
    并以布尔值 \coqref{LF.Basics.bool}{\coqdocinductive{bool}} 表示。注意该定义使用嵌套匹配 \coqdockw{match}
    （亦可仿照 \coqref{LF.Basics.NatPlayground2.minus}{\coqdocdefinition{minus}} 使用并列匹配）。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Basics.eqb}{eqb}{\coqdocdefinition{eqb}} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{n} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvariable{m} \coqdockw{with}\coqdoceol
\coqdocindent{4.50em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{4.50em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{m'} \ensuremath{\Rightarrow} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{4.50em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvariable{m} \coqdockw{with}\coqdoceol
\coqdocindent{6.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{6.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{m'} \ensuremath{\Rightarrow} \coqref{LF.Basics.eqb}{\coqdocdefinition{eqb}} \coqdocvar{n'} \coqdocvar{m'}\coqdoceol
\coqdocindent{6.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
类似地，\coqref{LF.Basics.leb}{\coqdocdefinition{leb}} 函数检验其第一个参数是否小于等于第二个参数，以布尔值表示。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Basics.leb}{leb}{\coqdocdefinition{leb}} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{n} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqref{LF.Basics.true}{\coqdocconstructor{true}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{match} \coqdocvariable{m} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqref{LF.Basics.false}{\coqdocconstructor{false}}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{m'} \ensuremath{\Rightarrow} \coqref{LF.Basics.leb}{\coqdocdefinition{leb}} \coqdocvar{n'} \coqdocvar{m'}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test leb1}{test\_leb1}{\coqdocdefinition{test\_leb1}}:                \coqref{LF.Basics.leb}{\coqdocdefinition{leb}} 2 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test leb2}{test\_leb2}{\coqdocdefinition{test\_leb2}}:                \coqref{LF.Basics.leb}{\coqdocdefinition{leb}} 2 4 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test leb3}{test\_leb3}{\coqdocdefinition{test\_leb3}}:                \coqref{LF.Basics.leb}{\coqdocdefinition{leb}} 4 2 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
我们之后会经常用到它们（特别是 \coqref{LF.Basics.eqb}{\coqdocdefinition{eqb}}），因此先定义好它们的中缀记法： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Basics.::nat scope:x '=?' x}{"}{"}x =? y" := (\coqref{LF.Basics.eqb}{\coqdocdefinition{eqb}} \coqdocvar{x} \coqdocvar{y}) (\coqdoctac{at} \coqdockw{level} 70) : \coqdocvar{nat\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Basics.::nat scope:x '<=?' x}{"}{"}x <=? y" := (\coqref{LF.Basics.leb}{\coqdocdefinition{leb}} \coqdocvar{x} \coqdocvar{y}) (\coqdoctac{at} \coqdockw{level} 70) : \coqdocvar{nat\_scope}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test leb3'}{test\_leb3'}{\coqdocdefinition{test\_leb3'}}: \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}4 \coqref{LF.Basics.::nat scope:x '<=?' x}{\coqdocnotation{<=?}} 2\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：1 星, standard (ltb)}




    \coqref{LF.Basics.ltb}{\coqdocdefinition{ltb}} 函数检验自然数间的小于关系，以布尔值表示。
    请利用前文定义的函数写出该定义，不要使用 \coqdockw{Fixpoint} 构造新的递归。
    （只需前文中的一个函数即可实现该定义，不过也可两者皆用。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.ltb}{ltb}{\coqdocdefinition{ltb}} (\coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Basics.::nat scope:x '<?' x}{"}{"}x <? y" := (\coqref{LF.Basics.ltb}{\coqdocaxiom{ltb}} \coqdocvar{x} \coqdocvar{y}) (\coqdoctac{at} \coqdockw{level} 70) : \coqdocvar{nat\_scope}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test ltb1}{test\_ltb1}{\coqdocdefinition{test\_ltb1}}:             \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.ltb}{\coqdocaxiom{ltb}} 2 2\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test ltb2}{test\_ltb2}{\coqdocdefinition{test\_ltb2}}:             \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.ltb}{\coqdocaxiom{ltb}} 2 4\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test ltb3}{test\_ltb3}{\coqdocdefinition{test\_ltb3}}:             \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.ltb}{\coqdocaxiom{ltb}} 4 2\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{基于化简的证明}



 至此，我们已经定义了一些数据类型和函数。让我们把问题转到如何表述和证明
    它们行为的性质上来。其实我们已经开始这样做了：前几节中的每个 \coqdockw{Example}
    都对几个函数在某些特定输入上的行为做出了准确的断言。这些断言的证明方法都一样：
    使用 \coqdoctac{simpl} 来化简等式两边，然后用 \coqdoctac{reflexivity} 来检查两边是否具有相同的值。


    这类“基于化简的证明”还可以用来证明更多有趣的性质。例如，对于“0
    出现在左边时是加法 + 的‘幺元’”这一事实，我们只需读一遍 \coqref{LF.Basics.NatPlayground2.plus}{\coqdocdefinition{plus}} 的定义，
    即可通过观察“对于 0 + \coqdocvariable{n}，无论 \coqdocvariable{n} 的值为多少均可化简为 \coqdocvariable{n}”而得到证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.plus O n}{plus\_O\_n}{\coqdoclemma{plus\_O\_n}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, 0 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
（或许你会注意到以上语句在你的 IDE 中和在浏览器渲染的 HTML
    中不大一样，我们用保留标识符“forall”来表示全称量词
    \coqdockw{\ensuremath{\forall}}。当 .\coqdocvariable{v} 文件转换为 HTML 后，它会变成一个倒立的“A”。）


    现在是时候说一下 \coqdoctac{reflexivity} 了，它其实比我们想象的更为强大。
    在前面的例子中，其实并不需要调用 \coqdoctac{simpl} ，因为 \coqdoctac{reflexivity}
    在检查等式两边是否相等时会自动做一些化简；我们加上 \coqdoctac{simpl} 只是为了看到化简之后，
    证明结束之前的中间状态。下面是对同一定理更短的证明：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.plus O n'}{plus\_O\_n'}{\coqdoclemma{plus\_O\_n'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, 0 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
此外，\coqdoctac{reflexivity} 在某些方面做了比 \coqdoctac{simpl} \textit{'更多'}的化简 ——
    比如它会尝试“展开”已定义的项，将它们替换为该定义右侧的值。
    了解这一点会很有帮助。产生这种差别的原因是，当自反性成立时，
    整个证明目标就完成了，我们不必再关心 \coqdoctac{reflexivity} 化简和展开了什么；
    而当我们必须去观察和理解新产生的证明目标时，我们并不希望盲目地展开定义，
    将证明目标留在混乱的声明中。这种情况下就要用到 \coqdoctac{simpl} 了。


    我们刚刚声明的定理形式及其证明与前面的例子基本相同，它们只有一点差别。


    首先，我们使用了关键字 \coqdockw{Theorem} 而非 \coqdockw{Example}。这种差别纯粹是风格问题；
    在 Coq 中，关键字 \coqdockw{Example} 和 \coqdockw{Theorem}（以及其它一些，包括 \coqdockw{Lemma}、\coqdockw{Fact}
    和 \coqdockw{Remark}）都表示完全一样的东西。


    其次，我们增加了量词 \coqdockw{\ensuremath{\forall}} \coqdocvariable{n}:\coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}，因此我们的定理讨论了\textit{'所有的'} 自然数 \coqdocvariable{n}。
    在非形式化的证明中，为了证明这种形式的定理，我们通常会说“\textit{'假设'}
    存在一个任意自然数 \coqdocvariable{n}...”。而在形式化证明中，这是用 \coqdoctac{intros} \coqdocvariable{n}
    来实现的，它会将量词从证明目标转移到当前假设的\textit{'上下文'}中。
    注意在 \coqdoctac{intros} 从句中，我们可以使用别的标识符来代替 \coqdocvariable{n}
    （当然这可能会让阅读证明的人感到困惑）：
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.plus O n''}{plus\_O\_n'{}'}{\coqdoclemma{plus\_O\_n'{}'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, 0 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
关键字 \coqdoctac{intros}、\coqdoctac{simpl} 和 \coqdoctac{reflexivity} 都是\textit{'策略（Tactic）'}的例子。
    策略是一条可以用在 \coqdockw{Proof}（证明）和 \coqdockw{Qed}（证毕）之间的指令，它告诉 Coq
    如何来检验我们所下的一些断言的正确性。在本章剩余的部分及以后的课程中，
    我们会见到更多的策略。 

 其它类似的定理可通过相同的模式证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.plus 1 l}{plus\_1\_l}{\coqdoclemma{plus\_1\_l}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, 1 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.mult 0 l}{mult\_0\_l}{\coqdoclemma{mult\_0\_l}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}, 0 \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
上述定理名称的后缀 \coqdocvar{\_l} 读作“在左边”。 

 跟进这些证明的每个步骤，观察上下文及证明目标的变化是非常值得的。
    你可能要在 \coqdoctac{reflexivity} 前面加上 \coqdoctac{simpl} 调用，以便观察 Coq
    在检查它们的相等关系前进行的化简。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{基于改写的证明}



 下面这个定理比我们之前见过的更加有趣： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.plus id example}{plus\_id\_example}{\coqdoclemma{plus\_id\_example}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m}:\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
该定理并未对自然数 \coqdocvariable{n} 和 \coqdocvariable{m} 所有可能的值做全称断言，而是讨论了仅当
    \coqdocvariable{n} = \coqdocvariable{m} 时这一更加特定情况。箭头符号读作“蕴含”。


    与此前相同，我们需要在能够假定存在自然数 \coqdocvariable{n} 和 \coqdocvariable{m} 的基础上进行推理。
    另外我们需要假定有前提 \coqdocvariable{n} = \coqdocvariable{m}。\coqdoctac{intros} 策略用来将这三条前提从证明目标
    移到当前上下文的假设中。


    由于 \coqdocvariable{n} 和 \coqdocvariable{m} 是任意自然数，我们无法用化简来证明此定理，
    不过可以通过观察来证明它。如果我们假设了 \coqdocvariable{n} = \coqdocvariable{m}，那么就可以将证明目标中的
    \coqdocvariable{n} 替换成 \coqdocvariable{m} 从而获得两边表达式相同的等式。用来告诉 Coq
    执行这种替换的策略叫做\textit{'改写'} \coqdoctac{rewrite}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
证明的第一行将全称量词变量 \coqdocvariable{n} 和 \coqdocvariable{m} 移到上下文中。第二行将前提
    \coqdocvariable{n} = \coqdocvariable{m} 移到上下文中，并将其命名为 \coqdocvariable{H}。第三行告诉 Coq
    改写当前目标（\coqdocvariable{n} + \coqdocvariable{n} = \coqdocvariable{m} + \coqdocvariable{m}），把前提等式 \coqdocvariable{H} 的左边替换成右边。


    (\coqdoctac{rewrite} 中的箭头与蕴含无关：它指示 Coq 从左往右地应用改写。
    若要从右往左改写，可以使用 \coqdoctac{rewrite} \ensuremath{\leftarrow}。在上面的证明中试一试这种改变，
    看看 Coq 的反应有何不同。) 

\paragraph{练习：1 星, standard (plus\_id\_exercise)}




    删除 ``\coqdocvar{Admitted}.'' 并补完证明。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.plus id exercise}{plus\_id\_exercise}{\coqdoclemma{plus\_id\_exercise}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{o} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{m} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{m} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqdocvariable{o}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 \coqdocvar{Admitted} 指令告诉 Coq 我们想要跳过此定理的证明，而将其作为已知条件，
    这在开发较长的证明时很有用。在进行一些较大的命题论证时，我们能够声明一些附加的事实。
    既然我们认为这些事实对论证是有用的，就可以用 \coqdocvar{Admitted} 先不加怀疑地接受这些事实，
    然后继续思考大命题的论证。直到确认了该命题确实是有意义的，
    再回过头去证明刚才跳过的证明。但是要小心：每次你使用 \coqdocvar{Admitted}，
    你就为 Coq 这个完好、严密、形式化且封闭的世界开了一个毫无逻辑的后门。 

 \coqdockw{Check} 命令也可用来检查以前声明的引理和定理。下面两个关于乘法引理来自于标准库。
    （在下一章中，我们会亲自证明它们。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqexternalref{mult n O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdoclemma{mult\_n\_O}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqexternalref{mult n Sm}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdoclemma{mult\_n\_Sm}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
除了上下文中现有的假设外，我们还可以通过 \coqdoctac{rewrite} 策略来运用前期证明过的定理。
    如果前期证明的定理的语句中包含量词变量，如前例所示，Coq 会通过匹配当前的证明目标
    来尝试实例化（Instantiate）它们。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.mult n 0 m 0}{mult\_n\_0\_m\_0}{\coqdoclemma{mult\_n\_0\_m\_0}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} 0\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{(}}\coqdocvariable{m} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} 0\coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{mult n O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdoclemma{mult\_n\_O}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqexternalref{mult n O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdoclemma{mult\_n\_O}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard (mult\_n\_1)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.mult n 1}{mult\_n\_1}{\coqdoclemma{mult\_n\_1}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{n} \coqexternalref{::nat scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{\ensuremath{\times}}} 1 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{利用分类讨论来证明}



 当然，并非一切都能通过简单的计算和改写来证明。通常，一些未知的，
    假定的值（如任意数值、布尔值、列表等等）会阻碍化简。
    例如，如果我们像以前一样使用 \coqdoctac{simpl} 策略尝试证明下面的事实，就会被卡住。
    （现在我们用 \coqdockw{Abort} 指令来放弃证明。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.plus 1 neq 0 firsttry}{plus\_1\_neq\_0\_firsttry}{\coqdoclemma{plus\_1\_neq\_0\_firsttry}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{)}} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 0 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
原因在于：根据 \coqref{LF.Basics.eqb}{\coqdocdefinition{eqb}} 和 + 的定义，其第一个参数先被 \coqdockw{match} 匹配。
    但此处 + 的第一个参数 \coqdocvariable{n} 未知，而 \coqref{LF.Basics.eqb}{\coqdocdefinition{eqb}} 的第一个参数 \coqdocvariable{n} + 1
    是复合表达式，二者均无法化简。


    欲进行规约，则需分情况讨论 \coqdocvariable{n} 的所有可能构造。如果 \coqdocvariable{n} 为 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}}，
    则可验算 (\coqdocvariable{n} + 1) =? 0 的结果确实为 \coqref{LF.Basics.false}{\coqdocconstructor{false}}；如果 \coqdocvariable{n} 由 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'} 构造，
    那么即使我们不知道 \coqdocvariable{n} + 1 表示什么，但至少知道它的构造子为 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}}，
    因而足以得出 (\coqdocvariable{n} + 1) =? 0 的结果为 \coqref{LF.Basics.false}{\coqdocconstructor{false}}。


    告诉 Coq 分别对 \coqdocvariable{n} = 0 和 \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'} 这两种情况进行分析的策略，叫做 \coqdoctac{destruct}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.plus 1 neq 0}{plus\_1\_neq\_0}{\coqdoclemma{plus\_1\_neq\_0}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{)}} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 0 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{destruct} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}] \coqdocvar{eqn}:\coqdocvar{E}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdoctac{destruct} 策略会生成\_两个\_子目标，为了让 Coq 认可这个定理，
    我们必须接下来证明这两个子目标。


    \coqdockw{as} [| \coqdocvariable{n'}] 这种标注被称为 \textit{'引入模式'}。它告诉 Coq 应当在每个子目标中
    使用什么样的变量名。总体而言，在方括号之间的是一个由 \ensuremath{|} 隔开的
    \textit{'列表的列表'}（译者注：list of lists）。在上面的例子中，第一个元素是
    一个空列表，因为 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} 构造子是一个空构造子（它没有任何参数）。
    第二个元素提供了包含单个变量名 \coqdocvariable{n'} 的列表，因为 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 是一个单构造子。


    在每个子目标中，Coq 会记录这个子目标中关于 \coqdocvariable{n} 的假设，\coqdocvariable{n} = 0 还是
    对于某个 n', \coqdocvariable{n} = \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'}。而 \coqdocvar{eqn}:\coqdocvar{E} 记号则告知 Coq 以 \coqdocvar{E} 来命名这些
    假设。省略 \coqdocvar{eqn}:\coqdocvar{E} 会导致 Coq 省略这些假设。这种省略能够使得一些不需要
    显式用到这类假设的证明显得更加流畅。但在实践中最好还是保留他们，
    因为他们可以作为一种说明文档来在证明过程中指引你。


    第二行和第三行中的 - 符号叫做\textit{'标号'}，它标明了这两个生成的子目标所对应的证明部分。
    （译注：此处的“标号”应理解为一个项目列表中每个 \textit{'条目'} 前的小标记，如 ‣ 或 •。）
    标号后面的证明脚本是一个子目标的完整证明。在本例中，每个子目标都简单地使用
    \coqdoctac{reflexivity} 完成了证明。通常，\coqdoctac{reflexivity} 本身会执行一些化简操作。
    例如，第二段证明将 \coqdoctac{at} (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'} + 1) 0 化简成 \coqref{LF.Basics.false}{\coqdocconstructor{false}}，是通过先将
    (\coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} \coqdocvariable{n'} + 1) 转写成 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} (\coqdocvariable{n'} + 1)，接着展开 \coqdocvar{beq\_nat}，之后再化简 \coqdockw{match} 完成的。


    用标号来区分情况是可选的：如果没有标号，Coq 只会简单地要求你依次证明每个子目标。
    尽管如此，使用标号仍然是一个好习惯。原因有二：首先，它能让证明的结构更加清晰易读。
    其次，标号能指示 Coq 在开始验证下一个目标前确认上一个子目标已完成，
    防止不同子目标的证明搅和在一起。这一点在大型开发中尤为重要，
    因为一些证明片段会导致很耗时的排错过程。


    在 Coq 中并没有既严格又便捷的规则来格式化证明 —— 尤其指应在哪里断行，
    以及证明中的段落应如何缩进以显示其嵌套结构。然而，无论格式的其它方面如何布局，
    只要在多个子目标生成的地方为每行开头标上标号，那么整个证明就会有很好的可读性。


    这里也有必要提一下关于每行代码长度的建议。Coq 的初学者有时爱走极端，
    要么一行只有一个策略语句，要么把整个证明都写在一行里。更好的风格则介于两者之间。
    一个合理的习惯是给自己设定一个每行 80 个字符的限制。更长的行会很难读，
    也不便于显示或打印。很多编辑器都能帮你做到。


    \coqdoctac{destruct} 策略可用于任何归纳定义的数据类型。比如，我们接下来会用它来证明
    布尔值的取反是对合（Involutive）的 —— 即，取反是自身的逆运算。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.negb involutive}{negb\_involutive}{\coqdoclemma{negb\_involutive}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.negb}{\coqdocdefinition{negb}} (\coqref{LF.Basics.negb}{\coqdocdefinition{negb}} \coqdocvariable{b}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{b}. \coqdoctac{destruct} \coqdocvar{b} \coqdocvar{eqn}:\coqdocvar{E}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
注意这里的 \coqdoctac{destruct} 没有 \coqdockw{as} 子句，因为此处 \coqdoctac{destruct}
    生成的子分类均无需绑定任何变量，因此也就不必指定名字。
    实际上，我们也可以省略 \textit{'任何'} \coqdoctac{destruct} 中的 \coqdockw{as} 子句，
    Coq 会自动填上变量名。不过这通常是个坏习惯，因为如果任其自由决定的话，
    Coq 经常会选择一些容易令人混淆的名字。


    有时在一个子目标内调用 \coqdoctac{destruct}，产生出更多的证明义务（Proof Obligation）
    也非常有用。这时候，我们使用不同的标号来标记目标的不同“层级”，比如： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.andb commutative}{andb\_commutative}{\coqdoclemma{andb\_commutative}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c}, \coqref{LF.Basics.andb}{\coqdocdefinition{andb}} \coqdocvariable{b} \coqdocvariable{c} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.andb}{\coqdocdefinition{andb}} \coqdocvariable{c} \coqdocvariable{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{b} \coqdocvar{c}. \coqdoctac{destruct} \coqdocvar{b} \coqdocvar{eqn}:\coqdocvar{Eb}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} \coqdocvar{c} \coqdocvar{eqn}:\coqdocvar{Ec}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} \coqdocvar{c} \coqdocvar{eqn}:\coqdocvar{Ec}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
每一对 \coqdoctac{reflexivity} 调用和紧邻其上的 \coqdoctac{destruct}
    执行后生成的子目标对应。 

 除了 - 和 + 之外，还可以使用 \ensuremath{\times}（星号）或任何重复的标号符（如
    -- 或 ***）作为标号。我们也可以用花括号将每个子证明目标括起来： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.andb commutative'}{andb\_commutative'}{\coqdoclemma{andb\_commutative'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c}, \coqref{LF.Basics.andb}{\coqdocdefinition{andb}} \coqdocvariable{b} \coqdocvariable{c} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.andb}{\coqdocdefinition{andb}} \coqdocvariable{c} \coqdocvariable{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{b} \coqdocvar{c}. \coqdoctac{destruct} \coqdocvar{b} \coqdocvar{eqn}:\coqdocvar{Eb}.\coqdoceol
\coqdocindent{1.00em}
\{ \coqdoctac{destruct} \coqdocvar{c} \coqdocvar{eqn}:\coqdocvar{Ec}.\coqdoceol
\coqdocindent{2.00em}
\{ \coqdoctac{reflexivity}. \}\coqdoceol
\coqdocindent{2.00em}
\{ \coqdoctac{reflexivity}. \} \}\coqdoceol
\coqdocindent{1.00em}
\{ \coqdoctac{destruct} \coqdocvar{c} \coqdocvar{eqn}:\coqdocvar{Ec}.\coqdoceol
\coqdocindent{2.00em}
\{ \coqdoctac{reflexivity}. \}\coqdoceol
\coqdocindent{2.00em}
\{ \coqdoctac{reflexivity}. \} \}\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
由于花括号同时标识了证明的开始和结束，因此它们可以同时用于不同的子目标层级，
    如上例所示。此外，花括号还允许我们在一个证明中的多个层级下使用同一个标号。
    使用大括号、标号还是二者结合都纯粹是个人偏好问题。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.andb3 exchange}{andb3\_exchange}{\coqdoclemma{andb3\_exchange}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d}, \coqref{LF.Basics.andb}{\coqdocdefinition{andb}} (\coqref{LF.Basics.andb}{\coqdocdefinition{andb}} \coqdocvariable{b} \coqdocvariable{c}) \coqdocvariable{d} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.andb}{\coqdocdefinition{andb}} (\coqref{LF.Basics.andb}{\coqdocdefinition{andb}} \coqdocvariable{b} \coqdocvariable{d}) \coqdocvariable{c}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d}. \coqdoctac{destruct} \coqdocvar{b} \coqdocvar{eqn}:\coqdocvar{Eb}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} \coqdocvar{c} \coqdocvar{eqn}:\coqdocvar{Ec}.\coqdoceol
\coqdocindent{2.00em}
\{ \coqdoctac{destruct} \coqdocvar{d} \coqdocvar{eqn}:\coqdocvar{Ed}.\coqdoceol
\coqdocindent{3.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
- \coqdoctac{reflexivity}. \}\coqdoceol
\coqdocindent{2.00em}
\{ \coqdoctac{destruct} \coqdocvar{d} \coqdocvar{eqn}:\coqdocvar{Ed}.\coqdoceol
\coqdocindent{3.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
- \coqdoctac{reflexivity}. \}\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{destruct} \coqdocvar{c} \coqdocvar{eqn}:\coqdocvar{Ec}.\coqdoceol
\coqdocindent{2.00em}
\{ \coqdoctac{destruct} \coqdocvar{d} \coqdocvar{eqn}:\coqdocvar{Ed}.\coqdoceol
\coqdocindent{3.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
- \coqdoctac{reflexivity}. \}\coqdoceol
\coqdocindent{2.00em}
\{ \coqdoctac{destruct} \coqdocvar{d} \coqdocvar{eqn}:\coqdocvar{Ed}.\coqdoceol
\coqdocindent{3.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
- \coqdoctac{reflexivity}. \}\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
在本章结束之前，我们最后再说一种简便写法。或许你已经注意到了，
    很多证明在引入变量之后会立即对它进行情况分析：


       intros x y. destruct y as \ensuremath{|}\coqdocvariable{y} eqn:E.


    这种写法是如此的常见以至于 Coq 为它提供了一种简写：我们可以在引入
    一个变量的同时对他使用\textit{'引入模式'}来进行分类讨论。例如，下面是一个对
    \coqref{LF.Basics.plus 1 neq 0}{\coqdoclemma{plus\_1\_neq\_0}} 的更简短证明。（这种简写的缺点也显而易见，
    我们无法再记录在每个子目标中所使用的假设，而之前我们可以通过
    \coqdocvar{eqn}:\coqdocvar{E} 将它们标注出来。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.plus 1 neq 0'}{plus\_1\_neq\_0'}{\coqdoclemma{plus\_1\_neq\_0'}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{)}} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} 0 \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} [|\coqdocvar{n}].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
如果没有需要命名的构造子参数，我们只需写上 [] 即可进行情况分析。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.andb commutative''}{andb\_commutative'{}'}{\coqdoclemma{andb\_commutative'{}'}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c}, \coqref{LF.Basics.andb}{\coqdocdefinition{andb}} \coqdocvariable{b} \coqdocvariable{c} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.andb}{\coqdocdefinition{andb}} \coqdocvariable{c} \coqdocvariable{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} [] [].\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{练习：2 星, standard (andb\_true\_elim2)}




    证明以下断言, 当使用 \coqdoctac{destruct} 时请用标号标出情况（以及子情况）。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.andb true elim2}{andb\_true\_elim2}{\coqdoclemma{andb\_true\_elim2}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}},\coqdoceol
\coqdocindent{1.00em}
\coqref{LF.Basics.andb}{\coqdocdefinition{andb}} \coqdocvariable{b} \coqdocvariable{c} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdocvariable{c} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.true}{\coqdocconstructor{true}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：1 星, standard (zero\_nbeq\_plus\_1)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.zero nbeq plus 1}{zero\_nbeq\_plus\_1}{\coqdoclemma{zero\_nbeq\_plus\_1}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}},\coqdoceol
\coqdocindent{1.00em}
0 \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{=?}} \coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{(}}\coqdocvariable{n} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} 1\coqref{LF.Basics.::nat scope:x '=?' x}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.false}{\coqdocconstructor{false}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{关于记法的更多内容 (可选)}



 （通常，标为可选的部分对于跟进本书其它部分的学习来说不是必须的，
    除了那些也标记为可选的部分。在初次阅读时，你可以快速浏览这些部分，
    以便在将来遇到时能够想起来这里讲了些什么。）


    回忆一下中缀加法和乘法的记法定义：\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Basics.::nat scope:x '+' x}{"}{"}x + y" := (\coqexternalref{plus}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{plus}} \coqdocvar{x} \coqdocvar{y})\coqdoceol
\coqdocindent{11.50em}
(\coqdoctac{at} \coqdockw{level} 50, \coqdoctac{left} \coqdockw{associativity})\coqdoceol
\coqdocindent{11.50em}
: \coqdocvar{nat\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} \coqdef{LF.Basics.::nat scope:x '*' x}{"}{"}x * y" := (\coqexternalref{mult}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocabbreviation{mult}} \coqdocvar{x} \coqdocvar{y})\coqdoceol
\coqdocindent{11.50em}
(\coqdoctac{at} \coqdockw{level} 40, \coqdoctac{left} \coqdockw{associativity})\coqdoceol
\coqdocindent{11.50em}
: \coqdocvar{nat\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
对于 Coq 中的每个记法符号，我们可以指定它的 \textit{'优先级'} 和 \textit{'结合性'}。
    优先级 \coqdocvariable{n} 用 \coqdoctac{at} \coqdockw{level} \coqdocvariable{n} 来表示，这样有助于 Coq 分析复合表达式。
    结合性的设置有助于消除表达式中相同符号出现多次时产生的歧义。比如，
    上面这组对 + 和 \ensuremath{\times} 的参数定义的表达式 1+2*3*4 是 (1+((2*3)*4)) 的
    简写。Coq 使用 0 到 100 的优先级等级，同时支持 \textit{'左结合'}、\textit{'右结合'}
    和 \textit{'不结合'} 三种结合性。之后我们在别的章节会看到更多与此相关的例子，比如
    \coqdoclibrary{Lists} 一章。


    每个记法符号还与 \textit{'记法范围（Notation Scope）'}相关。Coq 会尝试根据上下文来猜测
    你所指的范围，因此当你写出 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}}(0*0) 时，它猜测是 \coqdocvar{nat\_scope}；而当你
    写出积（元组）类型 \coqref{LF.Basics.bool}{\coqdocinductive{bool}}\ensuremath{\times}\coqref{LF.Basics.bool}{\coqdocinductive{bool}} 时，它猜测是 \coqdocvar{type\_scope}。
    有时你可能必须百分号记法 (\coqdocvariable{x}\ensuremath{\times}\coqdocvariable{y})\%\coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 来帮助 Coq 确定范围。
    另外，有时 Coq 打印的结果中也用 \%\coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}} 来指示记法所在的范围。


    记法范围同样适用于数值记法（3、4、5、42 等等），因此你有时候会看到
    0\%\coqref{LF.Basics.NatPlayground.nat}{\coqdocinductive{nat}}，表示 0（即我们在本章中使用的自然数零 0），而 0\%\coqref{LF.Basics.Z}{\coqdocconstructor{Z}} 表示整数零
    （来自于标准库中的另一个部分）。


    专业提示：Coq 的符号机制不是特别强大，别期望太多。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{不动点 \texorpdfstring{\protect\coqdockw{Fixpoint}}{Fixpoint} 和结构化递归 (可选)}



 以下是加法定义的一个副本： \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Basics.plus'}{plus'}{\coqdocdefinition{plus'}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) (\coqdocvar{m} : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvariable{n} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{O}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{O}} \ensuremath{\Rightarrow} \coqdocvariable{m}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqexternalref{S}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{S}} (\coqref{LF.Basics.plus'}{\coqdocdefinition{plus'}} \coqdocvar{n'} \coqdocvariable{m})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
当 Coq 查看此定义时，它会注意到“\coqref{LF.Basics.plus'}{\coqdocdefinition{plus'}} 的第一个参数是递减的”。
    这意味着我们对参数 \coqdocvariable{n} 执行了\textit{'结构化递归'}。换言之，我们仅对严格递减的
    \coqdocvariable{n} 值进行递归调用。这一点蕴含了“对 \coqref{LF.Basics.plus'}{\coqdocdefinition{plus'}} 的调用最终会停止”。
    Coq 要求每个 \coqdockw{Fixpoint} 定义中的某些参数必须是“递减的”。


    这项要求是 Coq 的基本特性之一，它保证了 Coq 中定义的所有函数对于所有输入都会终止。
    然而，由于 Coq 的“递减分析”不是非常精致，
    因此有时必须用一点不同寻常的方式来编写函数。 

\paragraph{练习：2 星, standard, optional (decreasing)}




    为了更好的理解这一点，请尝试写一个对于所有输入都\_的确\_终止的 \coqdockw{Fixpoint}
    定义。但这个定义需要违背上述的限制，以此来让 Coq 拒绝。（如果您决定将这个可选
    练习作为作业，请确保您将您的解答注释掉以防止 Coq 拒绝执行整个文件。） \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\section{更多练习}



 Each SF chapter comes with a tester file (e.g.  \coqdocvar{BasicsTest.v}),
    containing scripts that check most of the exercises. You can run
    \coqdocvar{make} \coqdocvar{BasicsTest.vo} in a terminal and check its output to make
    sure you didn't miss anything. 

\paragraph{练习：1 星, standard (identity\_fn\_applied\_twice)}




    用你学过的策略证明以下关于布尔函数的定理。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.identity fn applied twice}{identity\_fn\_applied\_twice}{\coqdoclemma{identity\_fn\_applied\_twice}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{f} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{LF.Basics.bool}{\coqdocinductive{bool}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} (\coqdocvar{x} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}), \coqdocvariable{f} \coqdocvariable{x} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{x}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{b} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}), \coqdocvariable{f} (\coqdocvariable{f} \coqdocvariable{b}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：1 星, standard (negation\_fn\_applied\_twice)}




    现在声明并证明定理 \coqdocvar{negation\_fn\_applied\_twice}，与上一个类似，
    但是第二个前提说明函数 \coqdocvariable{f} 有 \coqdocvariable{f} \coqdocvariable{x} = \coqref{LF.Basics.negb}{\coqdocdefinition{negb}} \coqdocvariable{x} 的性质。 \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{LF.Basics.manual grade for negation fn applied twice}{manual\_grade\_for\_negation\_fn\_applied\_twice}{\coqdocdefinition{manual\_grade\_for\_negation\_fn\_applied\_twice}} : \coqexternalref{option}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{option}} (\coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqexternalref{::type scope:x '*' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}}\coqexternalref{string}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Strings.String}{\coqdocinductive{string}}) := \coqexternalref{None}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocconstructor{None}}.\coqdoceol
\end{coqdoccode}
(The last definition is used by the autograder.)


    \ensuremath{\Box} 

\paragraph{练习：3 星, standard, optional (andb\_eq\_orb)}




    请证明下列定理。（提示：此定理的证明可能会有点棘手，取决于你如何证明它。
    或许你需要先证明一到两个辅助引理。或者，你要记得未必要同时引入所有前提。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{LF.Basics.andb eq orb}{andb\_eq\_orb}{\coqdoclemma{andb\_eq\_orb}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{b} \coqdocvar{c} : \coqref{LF.Basics.bool}{\coqdocinductive{bool}}),\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.andb}{\coqdocdefinition{andb}} \coqdocvariable{b} \coqdocvariable{c} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.orb}{\coqdocdefinition{orb}} \coqdocvariable{b} \coqdocvariable{c}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{1.00em}
\coqdocvariable{b} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqdocvariable{c}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{练习：3 星, standard (binary)}






    我们可以将对于自然数的一进制表示推广成更高效的二进制数表达方式。
    对于一个二进制数，我们可以将它看成一个由 \coqref{LF.Basics.A}{\coqdocconstructor{A}} 构造子和 \coqref{LF.Basics.B}{\coqdocconstructor{B}} 构造子
    组成的序列（它们分别表示 0 和 1），而这个序列的结束符为 \coqref{LF.Basics.Z}{\coqdocconstructor{Z}}。
    类似的，一个数的一进制表示可以看成一个由 \coqref{LF.Basics.NatPlayground.S}{\coqdocconstructor{S}} 构造子组成，并由 \coqref{LF.Basics.NatPlayground.O}{\coqdocconstructor{O}} 
    构造子结束的序列。 * )


    For example:


        decimal            binary                           unary
           0                   Z                              O
           1                 B Z                            S O
           2              A (B Z)                        S (S O)
           3              B (B Z)                     S (S (S O))
           4           A (A (B Z))                 S (S (S (S O)))
           5           B (A (B Z))              S (S (S (S (S O))))
           6           A (B (B Z))           S (S (S (S (S (S O)))))
           7           B (B (B Z))        S (S (S (S (S (S (S O))))))
           8        A (A (A (B Z)))    S (S (S (S (S (S (S (S O)))))))


    注意到在上面的表示中，二进制数的低位被写在左边而高位写在右边。
   （与通常的二进制写法相反，这种写法可以让我们在证明中更好的操作他们。） \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{LF.Basics.bin}{bin}{\coqdocinductive{bin}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.Z}{Z}{\coqdocconstructor{Z}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.A}{A}{\coqdocconstructor{A}} (\coqdocvar{n} : \coqref{LF.Basics.bin}{\coqdocinductive{bin}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdef{LF.Basics.B}{B}{\coqdocconstructor{B}} (\coqdocvar{n} : \coqref{LF.Basics.bin}{\coqdocinductive{bin}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
补全下面二进制自增函数 \coqref{LF.Basics.incr}{\coqdocdefinition{incr}} 的定义。并且补全二进制数与一进制自然数转换的
    函数 \coqref{LF.Basics.bin to nat}{\coqdocdefinition{bin\_to\_nat}}。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Basics.incr}{incr}{\coqdocdefinition{incr}} (\coqdocvar{m}:\coqref{LF.Basics.bin}{\coqdocinductive{bin}}) : \coqref{LF.Basics.bin}{\coqdocinductive{bin}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{LF.Basics.bin to nat}{bin\_to\_nat}{\coqdocdefinition{bin\_to\_nat}} (\coqdocvar{m}:\coqref{LF.Basics.bin}{\coqdocinductive{bin}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}}\coqdoceol
\coqdocindent{1.00em}
. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
下面这些针对单增函数和二进制转换函数的“单元测试”可以验算你的定义的正确性。
    当然，这些单元测试并不能确保你的定义在所有输入下都是正确的！我们在下一章的
    末尾会重新回到这个话题。 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test bin incr1}{test\_bin\_incr1}{\coqdocdefinition{test\_bin\_incr1}} : \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.incr}{\coqdocaxiom{incr}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}})\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.A}{\coqdocconstructor{A}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}}).\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test bin incr2}{test\_bin\_incr2}{\coqdocdefinition{test\_bin\_incr2}} : \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.incr}{\coqdocaxiom{incr}} (\coqref{LF.Basics.A}{\coqdocconstructor{A}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}}))\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.B}{\coqdocconstructor{B}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}}).\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test bin incr3}{test\_bin\_incr3}{\coqdocdefinition{test\_bin\_incr3}} : \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqref{LF.Basics.incr}{\coqdocaxiom{incr}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}}))\coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{LF.Basics.A}{\coqdocconstructor{A}} (\coqref{LF.Basics.A}{\coqdocconstructor{A}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}})).\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test bin incr4}{test\_bin\_incr4}{\coqdocdefinition{test\_bin\_incr4}} : \coqref{LF.Basics.bin to nat}{\coqdocaxiom{bin\_to\_nat}} (\coqref{LF.Basics.A}{\coqdocconstructor{A}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 2.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test bin incr5}{test\_bin\_incr5}{\coqdocdefinition{test\_bin\_incr5}} :\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.Basics.bin to nat}{\coqdocaxiom{bin\_to\_nat}} (\coqref{LF.Basics.incr}{\coqdocaxiom{incr}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}})) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 1 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqref{LF.Basics.bin to nat}{\coqdocaxiom{bin\_to\_nat}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}}).\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdef{LF.Basics.test bin incr6}{test\_bin\_incr6}{\coqdocdefinition{test\_bin\_incr6}} :\coqdoceol
\coqdocindent{4.00em}
\coqref{LF.Basics.bin to nat}{\coqdocaxiom{bin\_to\_nat}} (\coqref{LF.Basics.incr}{\coqdocaxiom{incr}} (\coqref{LF.Basics.incr}{\coqdocaxiom{incr}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}}))) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} 2 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqref{LF.Basics.bin to nat}{\coqdocaxiom{bin\_to\_nat}} (\coqref{LF.Basics.B}{\coqdocconstructor{B}} \coqref{LF.Basics.Z}{\coqdocconstructor{Z}}).\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{LF.Preface}{Library }{LF.Preface}

\begin{coqdoccode}
\end{coqdoccode}
\section{Preface: 前言}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{欢迎}



 这里是\textit{'软件基础'}系列书籍的起点，本书阐明了可靠软件背后的数学根基。
    书中的主题包括基本的逻辑概念、计算机辅助定理证明、Coq 证明助理、
    函数式编程、操作语义、用于论证软件的逻辑和技术、静态类型系统、基于性质的随机测试、
    以及对实践中 C 代码的验证。
    本书可供高年级本科生、研究生、科研工作者及同等学力的广大读者学习参考。
    阅读本书无需具备逻辑学、程序语言等背景知识，但一定的数学基础有助于理解书中内容。


    本书最大的创新之处在于，书中全文均已形式化并由机器检验。换言之，本书内容即为
    Coq 脚本，可在 Coq 的交互界面下阅读。书中大部分习题也在 Coq 中完成。


    本书中的文件都经过了精心组织：核心章节作为主线贯穿始终，涵盖了一学期的内容；
    “支线”中则包含附加的主题。所有核心章节都适合高年级本科生和研究生学习。


    本书为第一卷\textit{'《逻辑基础》'}，它向读者介绍了函数式编程的基本概念、构造逻辑以及
    Coq 证明助理，为其余诸卷的学习奠定了基础。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{概览}



 构建可靠的软件非常，非常地困难。现代系统的规模、复杂度、参与构建过程的人数，
    还有置于系统之上的需求范围，让构建或多或少地正确的软件变得极为困难，
    更不用说百分之百地正确了。同时，由于信息处理技术继续渗透到社会的各个层面，
    人们为程序错误和漏洞付出的代价变得越来越高昂。


    为了应对这些挑战，计算机科学家和软件工程师们发展了一套完整的提升软件质量的方法，
    从为管理软件项目的团队提供建议（如极限编程，Extreme Programming），
    到库的设计原理（如模型-视图-控制器，Model-View-Controller；发布-订阅模式，
    Publish-Subscribe）以及编程语言的设计哲学（面向对象编程，Object Oriented Programmin；
    面向剖面编程，Aspect Oriented Programming；函数式编程，Functional Programming），
    还有用于阐明和论证软件性质的数学技术，以及验证这些性质的工具。
    \textit{'《软件基础》'}系列着重于最后一种方法。


    本书将以下三种概念穿插在一起：


    （1）\textit{'逻辑学'}中的基本工具，用于准确地提出并论证关于程序的假设；


    （2）\textit{'证明助理'}用于构造严谨的逻辑论据；


    （3）\textit{'函数式编程'}思想，同时作为一种编程方法来简化程序的论证，
         以及架起程序和逻辑学之间的桥梁。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{逻辑学}



 逻辑学是研究\textit{'证明'}的领域，即对特定命题的真伪性进行不容置疑的论证。
    有关逻辑学在计算机科学中核心作用的书卷汗牛充栋。Manna 和 Waldinger
    称之为“计算机科学的微积分”，而 Halpern 的论文
    \textit{'On the Unusual Effectiveness of Logic in Computer Science'}
    中则收录了大量逻辑学为计算机科学提供的洞察力和至关重要的工具。
    的确，他们发现：“实际上，逻辑学对计算机科学来说远比在数学中更加有效。
    这相当引人注目，特别是过去一百年来，逻辑学发展的动力大都来自于数学。”


    具体来说，\textit{'归纳证明'}的基本概念在计算机科学中无处不在。
    你以前肯定见过它们，比如说在离散数学或算法分析中。不过在本课程中，
    我们会在你未曾涉及的深度下对它进行探讨。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{证明助理}



 逻辑学和计算机科学之间的思想交流并不是单向的，
    计算机科学也为逻辑学做出了重要的贡献，
    其中之一就是发展了帮助逻辑命题构造证明的软件工具。
    这些工具分为两大类：



\begin{itemize}
\item  \textit{'自动定理证明器'} 提供了一键式操作：它们接受一个命题，
         然后返回\textit{'真'}或\textit{'假'}（有时为\textit{'未知：超时'} ）。
         尽管它们的能力仅限于特定种类的推理，然而在近几年却快速成熟，
         并应用到了多种场景中。此类工具包括 SAT 求解器，SMT 求解器以及模型检查器
         （Model Checker）。



\item  \textit{'证明助理'} 是一种混合式工具，它能将证明的构建中比较常规的部分自动化，
         而更加困难的部分则依赖人类来解决。广泛使用的证明助理包括
         Isabelle、Agda、Twelf、ACL2、PVS 以及 Coq 等等。

\end{itemize}


    本课程围绕 Coq 展开，它是个自 1983 年以来主要在法国开发的证明助理，
    近年来吸引了大量来自研究机构和业界的社区用户。
    Coq 为机器验证的形式化论证的交互式开发提供了丰富的环境。Coq
    系统的内核是一个简单的证明检查器，它保证只会执行正确的推理步骤。
    在此内核之上，Coq 环境提供了高级的证明开发功能，包括一个庞大的库，
    其中包含各种定义和引理；强大策略，用于半自动化构造证明；
    还有一个专用的编程语言，能够为特殊情况定义新的自动证明策略。


    Coq 已成为跨计算机科学和数学研究的关键推动者：



\begin{itemize}
\item  作为一个\textit{'编程语言的建模平台'}，
      Coq 成为了研究员对复杂的语言定义进行描述和论证的标准工具。
      例如，它被用来检查 JavaCard 平台的安全性，得到了最高等级的通用准则验证，
      它还被用在 x86 和 LLVM 指令集以及 C 等编程语言的形式化规范中。



\item  作为一个\textit{'形式化软件验证的开发环境'}，Coq 被用来构建：
      CompCert，一个完全验证的 C 优化编译器；
      CertiKos，一个完全验证的工具，用于证明涉及浮点数的精妙算法的正确性；
      Coq 也是 CertiCrypt 的基础，一个用于论证密码学算法安全性的环境。
      Coq 还被用来构建开源 RISC-V 处理器架构的验证实现。



\item  作为一个\textit{'依赖类型函数式编程的现实环境'}，Coq 激发了大量的创新。
      例如 Ynot 系统嵌入了“关系式霍尔推理”（一个 \textit{'霍尔逻辑'} 的扩展，
      我们之后会看到它）。



\item  作为一个\textit{'高阶逻辑的证明助理'}，Coq 被用来验证数学中一些重要的结果。
      例如 Coq 可在证明中包含复杂计算的能力，使其开发出了第一个形式化验证的四色定理证明。
      此前数学家们对该证明颇有争议，因为它需要用程序对大量组态进行检验。
      在 Coq 的形式化中，所有东西都被检验过，自然也包括计算的正确性。
      近年来，Feit-Thompson 定理经过了更大的努力用 Coq 形式化了，
      它是对有限单群进行分类的十分重要的第一步。

\end{itemize}


   顺便一提，如果你对 Coq 这个名字感到好奇，INRIA (法国国家研究实验室，Coq
   主要在这里开发）上的 Coq 官方网站给出了解释：
   “一些法国计算机科学家有用动物命名软件的传统：像 Caml、Elan、Foc、Phox
   都心照不宣地遵循这种默契。在法国，“Coq”是雄鸡，发音也像构造演算
   （Calculus of Constructions）的首字母缩写（CoC），它是 Coq 的基础。”
   高卢雄鸡是法国的象征。C-o-q 还是 Thierry Coquand 名字的前三个字母，
   他是 Coq 的早期开发者之一。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{函数式编程}



 \textit{'函数式编程'}不仅表示可以在几乎任何编程语言中使用的各种习语（Idiom），
    还代表着一族以这些习语为侧重点设计的编程语言，包括
    Haskell、OCaml、Standard ML、F\#、Scala、Scheme、Racket、Common Lisp、Erlang
    还有 Coq。


    函数式编程已经有数十年的历史了--实际上，它甚至可以追溯到 1930
    年代 Church 发明的 λ-演算，那时还没有电子计算机呢！自 90 年代初以来，
    函数式编程激起了业内软件工程师和语言设计者浓厚的兴趣，它们还在
    Jane Street Capital、Microsoft、Facebook、Twitter 和 Ericsson
    等公司的高价值系统中发挥着关键的作用。


    函数式编程最根本的原则是，计算应当尽可能地\textit{'纯粹'}，也就是说，
    执行代码的唯一作用应当是只产生一个结果。计算应当没有\textit{'副作用'}，
    即它与输入/输出、可变量的赋值、指针重定向等相分离。例如，\textit{'指令式'}
    的排序函数会接受一个数字列表，通过重组指针使列表得以排序；
    而一个纯粹的排序函数则会接受一个列表，返回一个含有同样数字，
    但是已经排序的新列表。


    这种编程风格最明显的好处之一，就是它能让程序变得更容易理解和论证。
    如果对某个数据结构的所有操作都会返回新的数据结构，而旧有的结构没有变动，
    那么我们便无需担心它的共享方式，因为程序中一部分的改变并不会破坏另一部分的属性。
    在并发程序中，线程间共享的每一个可变状态都是致命 Bug 的潜在来源，
    因此这方面的考虑尤为关键。事实上，业界最近对函数式编程的兴趣大部分来源于此，
    即它在并发中表现出的简单行为。


    人们对函数式编程感到兴奋的另一原因与前文所述的原因相关：
    函数式程序通常比指令式程序更容易并行化和物理分布式化。
    如果一个计算除了产生结果之外没有其它的作用，那么它在 \textit{'何时'}
    执行便不再重要。同样，如果一个数据结构不会被破坏性地修改，
    那么它可以跨核心或网络地被随意复制。其实，“映射-归约”（Map-Reduce）
    的惯用法就是函数式编程的经典例子，它在大规模分布式查询处理器（如 Hadoop）
    中处于核心地位，并被 Google 用来索引整个互联网。


    对本课程而言，函数式编程还有另一个重要的吸引力：
    它在逻辑和计算机科学之间架起了一座桥梁。事实上，Coq
    本身即可视作一个小巧却有着极强表达能力的函数式编程语言，
    以及一组用于陈述和证明逻辑断言的工具的结合体。进而言之，
    当我们更加深入地审视它时，会发现 Coq 的这两方面其实基于完全相同的底层机制 --
    \textit{'命题即类型，程序即证明'}，可谓殊途同归。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{扩展阅读}



 本书旨在自成一体，不过想要对特定主题进行深入研究的读者，可以在
    \coqdoclibrary{Postscript} 一章中找到推荐的扩展阅读。所有引用的参考文献可在
    \coqdoclibrary{Bib} 文件中找到。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{实践指南}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{系统要求}



 Coq 可以在 Windows、Linux 和 macOS 上运行。我们需要：



\begin{itemize}
\item  安装近期版本的 Coq，它可以从 Coq 主页获得。本书中的文件均已通过了
      Coq 8.9.1 的测试。



\item  一个能跟 Coq 交互的 IDE。目前有两种选择：



\begin{itemize}
\item  Proof General 是一个基于 Emacs 的 IDE，Emacs 用户应该更喜欢这个。
          它需要单独安装（Google 搜索“Proof General”）。


          爱冒险的 Emacs 用户也可以试试 \coqdocvar{company}-\coqdocvar{coq} 和 \coqdocvar{control}-\coqdocvar{lock}
          之类的扩展。



\item  CoqIDE 是个更加简单的独立 IDE。它随 Coq 一起发布，
          所以如果你安装了 Coq，它应该就能用。你也可以从头编译安装它，
          不过在某些平台上还需要额外安装 GUI 之类的库。


          用户在运行 CoqIDE 时可以考虑关闭“异步”和“错误恢复”模式：

\end{itemize}

\end{itemize}


  coqide -async-proofs off -async-proofs-command-error-resilience off Foo.v \&
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{练习}



 每一章都包含大量的习题。每个习题都有标有“星级”，其含义是：



\begin{itemize}
\item  一星：很简单习题，强调课程的重点。对于大部分读者而言，
         一两分钟应该足够了。养成看到一个做一个的习惯。



\item  二星：直截了当的习题（5 到 10 分钟）。



\item  三星：需要一点思考的习题（10 分钟到半小时）。



\item  四或五星：更加困难的习题（半小时以上）。

\end{itemize}


    Those using SF in a classroom setting should note that the autograder
    assigns extra points to harder exercises:


      1 star  = 1 point
      2 stars = 2 points
      3 stars = 3 points
      4 stars = 6 points
      5 stars = 10 points


    有些习题标注为“进阶”，有些习题标注为“可选”。
    只做非进阶、非可选的习题已经能将核心概念掌握得很不错了。
    可选习题会对一些关键概念提供额外的练习，还有一些读者可能会感兴趣的次级主题。
    进阶练习则留给想要更多挑战和更深理解的读者。


     \textit{'请勿公布习题解答！'} 


    《软件基础》已被广泛地用作自学教程和大学课程。如果习题解答很容易获得，
    那么本书的效用将大打折扣，对于会为作业评分的大学课程来说尤其如此。
    我们特别请求读者，切勿将习题答案放在任何能够被搜索引擎找到的地方。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{下载 Coq 文件}



 本书的“英文发布版”以及所有源代码的压缩包
    （其中包含一组 Coq 脚本和 HTML 文件）可访问
    https://softwarefoundations.cis.upenn.edu 获取。


    本书的中文版和压缩包可访问 https://github.com/Coq-zh/SF-zh 获取。


    如果你是在一门课程中使用本书的，那么你的教授可能会让你使用本地的修改版，
    此时你应当使用它们而非发布版，这样你可以获得所有该学期的本地更新。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{章节依赖}



 章节之间的依赖关系图以及建议的学习路线可以在文件
    \coqdocvar{deps.html}
    中查看。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{推荐的引用格式}



 如果你想在自己的作品中引用本书，请采用以下格式：


   @book            \{$FIRSTAUTHOR:SF$VOLUMENUMBER,
   author       =   \{$AUTHORS},
   title        =   "$VOLUMENAME``,
   series       =   ''Software Foundations``,
   volume       =   ''$VOLUMENUMBER",
   year         =   "$VOLUMEYEAR``,
   publisher    =   ''Electronic textbook``,
   note         =   \{Version $VERSION, \URLhttp://softwarefoundations.cis.upenn.edu },
   }
$\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{资源}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{模拟题}



 宾夕法尼亚大学的 CIS500（软件基础）课程提供了大量的考试大纲，可访问
    https://www.seas.upenn.edu/\~{}cis500/current/exams/index.html 获取。
    近年来书中的记法有所变动，但大部分问题仍与本文对应。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{课程视频}



 \textit{'《逻辑基础》'}夏季加强班（DeepSpec 夏季班系列之一）的课程讲义可访问
    https://deepspec.org/event/dsss17 和 https://deepspec.org/event/dsss18/
    获取。2017 年的视频清晰度不高，但在之后的课程中会更好。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{对授课员的要求}



 如果您有意用这些课件授课，那肯定会发现希望改进、提高或增加的材料。
    我们欢迎您的贡献！


    为保证法律上的简单性和单一责任制，任何情况下都不应出现许可协议条款的的调整，
    授权的转移等等，我们要求所有贡献者（即，任何可访问开发者仓库的人）根据
    “作者记录”为他们的贡献赋予如下版权信息：



\begin{itemize}
\item  I hereby assign copyright in my past and future contributions
        to the Software Foundations project to the Author of Record of
        each volume or component, to be licensed under the same terms
        as the rest of Software Foundations.  I understand that, at
        present, the Authors of Record are as follows: For Volumes 1
        and 2, known until 2016 as ''Software Foundations`` and from
        2016 as (respectively) ''Logical Foundations`` and ''Programming
        Foundations,`` and for Volume 4, ''QuickChick: Property-Based
        Testing in Coq,`` the Author of Record is Benjamin C. Pierce.
        For Volume 3, ''Verified Functional Algorithms``, the Author of
        Record is Andrew W. Appel. For components outside of
        designated volumes (e.g., typesetting and grading tools and
        other software infrastructure), the Author of Record is
        Benjamin Pierce.

\end{itemize}


    要参与贡献，请向 Benjamin Pierce 发送一封电子邮件，
    介绍一下自己，说明你打算如何使用这些材料，信中需包含
    (1) 上面的版权移交文本，以及 (2) 你的 Github 用户名。


    我们会赋予你访问 Git 源码库和开发者邮件列表的权限。你可以在源码库中找到
    \coqdocvar{INSTRUCTORS} 文件获取更多指示。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{译本}



 感谢翻译志愿者团队的努力，\textit{'《软件基础》'}
    已有日文版可以享用 http://proofcafe.org/sf。
    中文版还在填坑= =|| \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{鸣谢}



 \textit{'《软件基础》'} 系列的开发，部分由国家科学基金会
    （National Science Foundation）在 NSF 科研赞助 1521523 号
    \textit{'深度规范科学'} 下提供支持。 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\end{document}
